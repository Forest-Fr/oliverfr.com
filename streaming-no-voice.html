<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Mini-GPT</title>
<link rel="icon" href="MeFan Logo.png" type="image/x-icon">
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root {
  --radius: 24px;
  --grey: #e4e4e7;
  --bubble: #f7f7f8;
  --side-gap: 190px;
  --font: 16px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  overflow: hidden;
  font: var(--font);
  background: #fafafa;
}

body { padding: 40px var(--side-gap) 220px; }

/* å¼€åœºæç¤º */
/* æ¬¢è¿è¯­å›ºå®šåº•éƒ¨ï¼ˆåŠ¨æ€ JS è°ƒæ•´ bottomï¼‰ */
#welcome{
  position:fixed;left:50%;transform:translateX(-50%);
  font-size:21px;font-weight:600;line-height:1.2;
  z-index:3000;pointer-events:none;text-align:center;
  max-width:90%;bottom:60px; /* åˆå§‹å…œåº• */
}

/* èŠå¤©åŒº */
#chat {
  display: flex;
  flex-direction: column;
  gap: 16px;
  height: calc(100vh - 190px);
  padding-left: var(--side-gap);
  overflow-x: auto;
  overflow-y: auto;
  scroll-behavior: smooth;
}

/* èŠå¤©æ°”æ³¡ */
.msg {
  max-width: 100%;
  width: fit-content;
  position: relative;
  padding: 12px 16px;
  background: var(--bubble);
  border-radius: 12px;
  font-size: 15px;
  line-height: 1.55;
  color: #111;
  word-break: break-word;
  white-space: pre-wrap;
}
.msg.bot { align-self: flex-start; }
.msg.user { align-self: flex-end; background: #e0f2ff; }
.msg.system { align-self: center; background:#fff3cd; color:#7a5a00; }

/* Clarify ç‰¹æ®Šæ°”æ³¡ */
.msg.clarify {
  background: #fffbe6;
  border: 1px solid #f5d36b;
  color: #7a5a00;
}

/* Streaming é«˜äº®åŠ¨ç”» */
.msg.streaming {
  background: #eef6ff;
  box-shadow: 0 0 0 1px #d0e6ff inset;
  position: relative;
}
.msg.streaming:after {
  content: '';
  position: absolute;
  right: 6px; bottom: 6px;
  width: 8px; height: 8px;
  border-radius: 50%;
  background: #3b82f6;
  animation: pulseDot 1.2s ease-in-out infinite;
}
@keyframes pulseDot {
  0% { transform: scale(.7); opacity:.4; }
  50% { transform: scale(1); opacity:1; }
  100% { transform: scale(.7); opacity:.4; }
}

/* å›¾ç‰‡ç½‘æ ¼ */
.pics {
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
  gap: 8px;
  margin-bottom: 8px;
  max-width: 100%;
  overflow-x: auto;
}
.pics img {
  height: 160px;
  width: auto;
  border-radius: 8px;
  object-fit: cover;
  cursor: pointer;
  transition: filter .2s;
}
.pics img:hover { filter: brightness(.9); }
.pics:has(img:only-child) img { height: auto; max-width: 60%; }

/* å¤åˆ¶æŒ‰é’® */
.copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 50%;
  background: #0001;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  color: #555;
  cursor: pointer;
  opacity: 0;
  transition: .15s;
}
.msg.bot:hover .copy-btn { opacity: 1; }
.copy-btn:hover { transform: scale(1.15); }

/* ç”¨æˆ·æ¶ˆæ¯å¤–ä¾§æ“ä½œæŒ‰é’® */
.msg.user .actions {
  position: absolute;
  bottom: -8px;
  right: -48px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: .15s;
}
.msg.user:hover .actions { opacity: 1; }
.action-btn {
  width: 34px;
  height: 34px;
  border-radius: 8px;
  background: #f4f4f4;
  border: 1px solid var(--grey);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: .15s;
}
.action-btn:hover { background: #eaeaea; transform: scale(1.05); }
.action-btn svg { width: 18px; height: 18px; fill: #555; }

.copy-tip {
  position: absolute;
  bottom: 42px;
  right: -2px;
  padding: 4px 8px;
  font-size: 12px;
  background: #000;
  color: #fff;
  border-radius: 6px;
  pointer-events: none;
  opacity: 0;
  animation: tip 2s forwards;
}
@keyframes tip {
  0% { opacity: 0; transform: translateY(4px); }
  10% { opacity: 1; transform: translateY(0); }
  80% { opacity: 1; }
  100% { opacity: 0; transform: translateY(4px); }
}

/* è¾“å…¥åŒº */
.composer {
  position: fixed;
  left: 50%;
  bottom: 27px;
  transform: translateX(-50%);
  width: clamp(280px, 90%, 800px);
  z-index: 3000;
}
.box {
  position: relative;
  background: #fff;
  border: 1px solid var(--grey);
  border-radius: var(--radius);
  padding: 16px 64px 60px 64px;
  transition: .2s;
}
.box:focus-within { border-color: #8ab4ff; }
textarea {
  width: 100%;
  min-height: 24px;
  max-height: 180px;
  resize: none;
  overflow-y: auto;
  border: none;
  outline: none;
  background: none;
  font: var(--font);
}
.icon-btn {
  position: absolute;
  bottom: 12px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  cursor: pointer;
}
.plus {
  left: 12px;
  background: #fff;
  border: 1px solid var(--grey);
  font-size: 26px;
}
.plus:hover { background: #f1f1f1; }
.send {
  right: 12px;
  background: #000;
  color: #fff;
  transition: .15s;
}
.send.disabled { opacity: .35; cursor: default; }
.send.loading { opacity: .4; cursor: wait; }
.send.ready:hover { transform: scale(1.08); }
.send svg { width: 24px; height: 24px; fill: #fff; }
.spinner {
  width: 24px;
  height: 24px;
  border: 3px solid #fff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin .8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Clarify Banner */
#clarifyBanner {
  position: absolute;
  left: 16px;
  right: 16px;
  top: 12px;
  background: #fffbe6;
  border: 1px solid #f5d36b;
  color: #7a5a00;
  font-size: 13px;
  padding: 6px 8px;
  border-radius: 8px;
  display: none;
  line-height: 1.35;
}

/* ç¼©ç•¥å›¾ */
.thumbs { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
.thumbs img { width: 64px; height: 64px; border-radius: 8px; }
.close {
  position: absolute;
  right: 2px;
  top: 2px;
  width: 20px;
  height: 20px;
  border: none;
  background: #000a;
  color: #fff;
  border-radius: 50%;
  cursor: pointer;
}

/* é®ç½© */
#mask {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  background: #fafafa;
  pointer-events: none;
  z-index: 2999;
}

/* å›åˆ°åº•éƒ¨ç®­å¤´ */
#scrollBottom {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  width: 44px;
  height: 44px;
  border: 1px solid var(--grey);
  border-radius: 50%;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  box-shadow: 0 1px 3px #0002;
  opacity: 0;
  pointer-events: none;
  transition: .18s;
  z-index: 3001;
}
#scrollBottom.show { opacity: 1; pointer-events: auto; }
#scrollBottom:hover { transform: translateX(-50%) scale(1.08); }

/* footer æ³¨è„š */
.footnote {
  position: fixed;
  left: 50%;
  bottom: 2px;
  transform: translateX(-50%);
  font-size: 13px;
  color: #888;
  white-space: nowrap;
  padding: 2px 6px;
  z-index: 3000;
}

/* ç¯ç®± */
#lightbox {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 4000;
}
#lightbox img {
  max-width: 90vw;
  max-height: 90vh;
  border-radius: 8px;
}

/* å°å±é€‚é… */
@media (max-width: 600px) {
  :root { --side-gap: 12px; }
  body {
    padding-left: var(--side-gap);
    padding-right: var(--side-gap);
  }
  #chat { padding-left: var(--side-gap); }
  .box { padding: 16px 56px 60px 56px; }
  #clarifyBanner { position: static; margin-bottom: 8px; }
}

/* â€”â€” æˆæƒå¼¹çª— â€”â€” */
#authModal {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0);
  z-index: 1000;
}
#authModal .box {
    position: absolute;
  top: 60px;                /* âœ… å…³é”®ï¼šè·ç¦»é¡¶éƒ¨190px */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,0.95);
  border-radius: 12px;
  padding: 24px 32px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
  text-align: center;
  min-width: 320px;
}
#authModal h2 { font-size: 1.5rem; margin-bottom: 1rem; }
#authModal input {
  width: 100%; padding: .75rem; font-size: 1rem;
  border: 1px solid #ccc; border-radius: 6px; margin-bottom: 1rem;
}
#authModal button {
  width: 100%; padding: .75rem; font-size: 1rem;
  border: none; border-radius: 6px; background: #3b82f6;
  color: #fff; cursor: pointer; transition: background .2s;
}
#authModal button:disabled { background: #8fbefc; cursor: not-allowed; }
#authErr { color: #d9534f; margin-top: .5rem; font-size: .9rem; display: none; }

/* â€”â€” GPT Markdown å¯è§†åŒ–æ”¯æŒï¼ˆåŸæ ·ä¿ç•™ï¼‰ â€”â€” */
.msg.bot code {
  background: #f5f5f5;
  padding: 2px 4px;
  border-radius: 4px;
  font-family: Menlo, Consolas, monospace;
  font-size: 0.95em;
}
.msg.bot pre {
  background: #1e1e1e;
  color: #f8f8f2;
  padding: 1em;
  border-radius: 6px;
  overflow-x: auto;
  margin: 1em 0;
}
.msg.bot pre code { background: none; color: inherit; padding: 0; border-radius: 0; }
pre.qa-report {
  background: #f2f7ff;
  border-left: 4px solid #3b82f6;
  padding: 12px;
  border-radius: 6px;
  margin: 1em 0;
  overflow-x: auto;
  font-family: Menlo, Consolas, monospace;
  font-size: 0.95em;
  color: #1a202c;
}
pre.qa-report code { background: none; padding: 0; color: inherit; white-space: pre-wrap; word-break: break-word; }
.msg.bot blockquote {
  border-left: 4px solid #dfe2e5;
  background: #f9f9f9;
  padding: 0.5em 1em;
  margin: 1em 0;
  color: #555;
}
.msg.bot blockquote.callout { border-left-color: #38a169; background: #f0fff4; }
.msg.bot blockquote.callout > p:first-child { font-weight: bold; }
.msg.bot hr { border: none; border-top: 1px solid #ddd; margin: 1.5em 0; }
.msg.bot ul, .msg.bot ol { margin: 1em 0; padding-left: 1.5em; }
.msg.bot ul ul, .msg.bot ol ol, .msg.bot ul ol, .msg.bot ol ul {
  margin-top: 0.5em; margin-bottom: 0.5em;
}
.msg.bot li.task-list-item {
  list-style: none;
  display: flex;
  align-items: flex-start;
}
.msg.bot li.task-list-item > input[type="checkbox"] {
  margin-right: 0.5em;
  vertical-align: middle;
}
.msg.bot table {
  width: 100%;
  border-collapse: collapse;
  margin: 1em 0;
}
.msg.bot th, .msg.bot td {
  border: 1px solid #ccc;
  padding: 0.6em;
  text-align: left;
}
.msg.bot th { background: #f3f4f6; }
.msg.bot img {
  max-width: 100%;
  border-radius: 6px;
  margin: 1em 0;
}
.msg.bot a { color: #3b82f6; text-decoration: none; }
.msg.bot a:hover { text-decoration: underline; }
.msg.bot .math, .msg.bot .katex {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.msg._meta {
  display: flex !important;
  justify-content: flex-start !important;
  align-items: center !important;
  background: transparent !important;
  padding: 4px 8px !important;
  margin: 4px 0 !important;
}
.msg._meta > * { max-width: none !important; }
.msg._meta .copy-btn { display: none !important; }
</style>
</head>
<body>

<h1 id="welcome">ä»Šå¤©æœ‰ä»€ä¹ˆè®®ç¨‹ï¼Ÿ</h1>

<main id="chat"></main>
<div id="mask"></div>
<button id="scrollBottom" aria-label="æ»šåŠ¨åˆ°åº•éƒ¨">â†“</button>

<div class="composer">
  <div class="box">
    <div id="clarifyBanner"></div> <!-- === NEW Clarify Banner -->
    <div id="thumbs" class="thumbs"></div>
    <textarea id="prompt" rows="1" placeholder="è¯¢é—®ä»»ä½•é—®é¢˜"
              spellcheck="false" autocomplete="off"></textarea>
    <button id="plus" class="icon-btn plus">+</button>
    <button id="send" class="icon-btn send disabled">
      <svg viewBox="0 0 24 24"><path d="M3 20v-6l9-2-9-2V4l18 8z"/></svg>
    </button>
    <input id="file" type="file" accept="image/*" multiple hidden>
  </div>
</div>

<p class="footnote">Miniâ€‘GPT ä¹Ÿå¯èƒ½ä¼šçŠ¯é”™ã€‚è¯·æ ¸æŸ¥é‡è¦ä¿¡æ¯ã€‚</p>

<div id="lightbox"><img alt=""></div>

<div id="authModal">
  <div class="box">
    <h2>è¯·è¾“å…¥æˆæƒç </h2>
    <input id="authInput" type="password" placeholder="æˆæƒç "/>
    <button id="authBtn" disabled>ç¡®è®¤</button>
    <div id="authErr"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
 /*-- if (window._MGPT && window._MGPT.__VERSION__){
  console.warn('[INIT] å‘ç°å·²æœ‰ _MGPT ç‰ˆæœ¬', window._MGPT.__VERSION__, ' -> ç»ˆæ­¢å†æ¬¡åˆå§‹åŒ–ã€‚');
  return;
}
const FRONTEND_VERSION = 'fe-stream-20250720-01';--**/

/* ================== Marked é…ç½® ================== */
marked.setOptions({
  gfm: true,
  breaks: false,
  sanitize: false,
  mangle: false,
  headerIds: false,
  allowDangerousHtml: true
});

document.addEventListener('DOMContentLoaded', () => {
  if (!window._MGPT) window._MGPT = {};

  /* ================== åŸºç¡€é…ç½® ================== */
  const BASE        = "https://streaming-tts.mefans.workers.dev";
  const API_URL     = BASE + "/admin-api/ws";
  const AUTH_URL    = BASE + "/admin-api/validate-code";
  const DEV_MODE    = false;
  const DEBUG       = true;
  /**
   * USE_SSE å–å€¼ï¼š
   *  false  => æ°¸è¿œ NDJSON
   *  true   => å¼ºåˆ¶ SSE (Accept:text/event-stream)
   *  'auto' => å…ˆæ¢æµ‹ï¼Œå¤±è´¥è‡ªåŠ¨é™çº§ NDJSON
   */
  let   USE_SSE     = false;   // éœ€è¦è‡ªåŠ¨æ¢æµ‹å¯æ”¹ 'auto'
  const MAX_CTX_USER_QUERIES = 8;

  /* ================== DOM å¼•ç”¨ ================== */
  const chat       = document.getElementById('chat');
  const txt        = document.getElementById('prompt');
  const sendBtn    = document.getElementById('send');
  const plusBtn    = document.getElementById('plus');
  const fileInput  = document.getElementById('file');
  const thumbs     = document.getElementById('thumbs');
  const arrow      = document.getElementById('scrollBottom');
  const composer   = document.querySelector('.composer');
  const welcome    = document.getElementById('welcome');
  const mask       = document.getElementById('mask');
  const lightbox   = document.getElementById('lightbox');
  const lightImg   = lightbox?.querySelector('img') || new Image();
  const clarifyBanner = document.getElementById('clarifyBanner');
  const authModal  = document.getElementById('authModal');
  const authInput  = document.getElementById('authInput');
  const authBtn    = document.getElementById('authBtn');
  const authErr    = document.getElementById('authErr');

  /* ================== ä¼šè¯/çŠ¶æ€ ================== */
  let sessionId = localStorage.getItem('session_id');
  if (!sessionId) {
    sessionId = crypto.randomUUID();
    localStorage.setItem('session_id', sessionId);
  }
  const HISTORY_KEY = `chat_history_${sessionId}`;

  let uploads        = [];
  let isAuthorized   = false;
  let isStreaming    = false;
  let clarifyMode    = false;
  let streamingNode  = null;
  let abortCtrl      = null;
  let deltaBuffer    = '';
  let flushScheduled = false;
  let firstMessage   = true;
  let lastFullAnswer = '';
  let rawAnswerBuffer = '';  // ç´¯è®¡ delta
let gotDone = false;       // æ–°å¢: æ ‡è®°æ˜¯å¦æ”¶åˆ°done
  let gotStart = false;    // æ–°å¢ï¼šæ”¶åˆ° start è¡Œ
  let sseAvailable   = null; // 'yes' | 'no' | null

  window.SESSION_STATE = window.SESSION_STATE || {
    status: 'final_answer',
    lastClarifyQ: '',
    clarifyTimes: 0
  };
  window.USER_ROLES = window.USER_ROLES || [];
  window.SELECTED_INDUSTRY = window.SELECTED_INDUSTRY || '';
  window.SELECTED_SUB_INDUSTRY = window.SELECTED_SUB_INDUSTRY || '';
  let code = '';

  /* ================== å†å² ================== */
  function loadHistory() {
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      if (!raw) return;
      const arr = JSON.parse(raw);
      arr.forEach(m => replayMessage(m));
      if (arr.length) {
        document.body.style.overflow = 'auto';
        welcome && welcome.remove();
      }
    } catch (e) { console.warn('å†å²è¯»å–å¤±è´¥', e); }
  }
  function saveMessage(role, content, meta={}) {
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      arr.push({ role, content, meta, ts: Date.now() });
      localStorage.setItem(HISTORY_KEY, JSON.stringify(arr));
    } catch(e){ console.warn('å†å²å†™å…¥å¤±è´¥', e); }
  }
  function replayMessage(m) {
    appendMessage(m.role, m.content, { noSave: true, meta: m.meta });
  }

  /* ================== å·¥å…·å‡½æ•° ================== */
  function chatAtBottom(pad=200){
    if (!chat) return true;
    return chat.scrollHeight - chat.scrollTop - chat.clientHeight < pad;
  }
  function scrollToBottom(force=false){
    if (!chat) return;
    if (force || chatAtBottom()) chat.scrollTop = chat.scrollHeight;
  }
  function autoResize() {
    if (!txt) return;
    txt.style.height = '24px';
    txt.style.height = Math.min(txt.scrollHeight, 180) + 'px';
  }
  function renderMarkdown(md) {
    if (!md) return '';
    try { return marked.parse(md); }
    catch(e){
      return md.replace(/[&<>]/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[s])).replace(/\n/g,'<br>');
    }
  }
  function safeText(t) {
    if (typeof t !== 'string') return '';
    return t.replace(/imageHint is not defined/g, 'ã€åç«¯ imageHint æœªå®šä¹‰ - è¯·æ£€æŸ¥ Workerã€‘');
  }
  function createMsgDiv(role, extraClass='') {
    const div = document.createElement('div');
    div.className = `msg ${role} ${extraClass}`.trim();
    chat && chat.appendChild(div);
    return div;
  }
  function appendMessage(role, text, {
    images = [],
    streaming = false,
    noSave = false,
    meta = null,
    clarify = false
  } = {}) {
    if (!chat) return;
    if (!text && !images.length) return;
    const extras = [];
    if (streaming) extras.push('streaming');
    if (clarify)  extras.push('clarify');
    const div = createMsgDiv(role, extras.join(' '));

    if (images.length) {
      const pics = document.createElement('div');
      pics.className = 'pics';
      images.forEach(src=>{
        const im = new Image();
        im.src = src;
        im.loading = 'lazy';
        im.onclick = () => {
          if (!lightbox) return;
          lightImg.src = src;
          lightbox.style.display = 'flex';
        };
        pics.appendChild(im);
      });
      div.appendChild(pics);
    }
    if (text) div.innerHTML += renderMarkdown(safeText(text));

    if (role === 'bot' && !streaming && !clarify) {
      const copy = document.createElement('button');
      copy.className = 'copy-btn';
      copy.textContent = 'â§‰';
      copy.title = 'å¤åˆ¶';
      copy.onclick = () => {
        navigator.clipboard.writeText(stripMarkdown(text));
        copy.textContent = 'âœ”';
        setTimeout(()=>copy.textContent='â§‰', 1500);
      };
      div.appendChild(copy);
    }
    if (role === 'user') {
      const acts = document.createElement('div');
      acts.className = 'actions';
      const copyBtn = document.createElement('button');
      copyBtn.className='action-btn';
      copyBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
      copyBtn.onclick = ()=>{
        navigator.clipboard.writeText(text);
        showCopyTip(div);
      };
      const editBtn = document.createElement('button');
      editBtn.className='action-btn';
      editBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM21.41 6.34a1.25 1.25 0 0 0 0-1.77l-2.99-2.99a1.25 1.25 0 0 0-1.77 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/></svg>';
      editBtn.onclick = ()=>{
        if (!txt) return;
        txt.value = text;
        autoResize();
        txt.focus();
      };
      acts.append(copyBtn, editBtn);
      div.appendChild(acts);
    }
    if (!noSave && role !== 'stream-temp') {
      saveMessage(role, text, { images, meta, clarify });
    }
    scrollToBottom(true);
    return div;
  }
  function showCopyTip(parent){
    const tip = document.createElement('div');
    tip.className='copy-tip';
    tip.textContent='å·²å¤åˆ¶';
    parent.appendChild(tip);
    setTimeout(()=>tip.remove(),1600);
  }
  function stripMarkdown(md=''){
    return md
      .replace(/```[\s\S]*?```/g,'')
      .replace(/`([^`]+)`/g,'$1')
      .replace(/\!\[[^\]]*\]\([^)]+\)/g,'')
      .replace(/\[[^\]]*\]\(([^)]+)\)/g,'$1')
      .replace(/[#>*_~`]/g,'')
      .trim();
  }

  /* ================== æˆæƒ ================== */
  function unlockUI(){
    txt && (txt.disabled = false);
    plusBtn && (plusBtn.disabled = false);
    sendBtn && (sendBtn.disabled = false);
    refreshSendState();
    mask && (mask.style.display='none');
  }
  function lockUI(){
    txt && (txt.disabled = true);
    plusBtn && (plusBtn.disabled = true);
    sendBtn && (sendBtn.disabled = true);
  }
  function initAuth(){
    if (DEV_MODE) {
      isAuthorized = true;
      code = 'dev-bypass';
      authModal && (authModal.style.display='none');
      unlockUI();
      return;
    }
    const saved = localStorage.getItem('auth_code');
    if (saved) {
      isAuthorized = true;
      code = saved;
      authModal && (authModal.style.display='none');
      unlockUI();
    } else {
      isAuthorized = false;
      lockUI();
      authModal && (authModal.style.display='flex');
    }
  }
  authInput?.addEventListener('input', ()=>{
    authBtn && (authBtn.disabled = !authInput.value.trim());
    authErr && (authErr.style.display='none');
  });
  authBtn?.addEventListener('click', async ()=>{
    authBtn.disabled = true;
    const val = authInput.value.trim();
    try {
      const r = await fetch(AUTH_URL, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ code: val })
      }).then(r=>r.json());
      if(!r.ok) throw new Error('æˆæƒå¤±è´¥');
      isAuthorized = true;
      code = val;
      localStorage.setItem('auth_code', val);
      authModal && (authModal.style.display='none');
      unlockUI();
    } catch(e){
      authErr && (authErr.textContent = e.message || 'æˆæƒé”™è¯¯');
      authErr && (authErr.style.display = 'block');
    } finally {
      authBtn.disabled = false;
    }
  });
  function checkAuthOrWarn(){
    if (DEV_MODE || isAuthorized) return true;
    alert('è¯·å…ˆè¾“å…¥æˆæƒç ï¼');
    return false;
  }

  /* ================== è¾“å…¥ & æŒ‰é’®çŠ¶æ€ ================== */
  function anyUploading(){ return uploads.some(u=>u.uploading); }
  function refreshSendState() {
    if (!sendBtn) return;
    if (isStreaming && !clarifyMode) {
      sendBtn.className = 'icon-btn send loading';
      sendBtn.innerHTML = '<div class="spinner"></div>';
      return;
    }
    const t = (txt?.value||'').trim();
    const canSend = (t || uploads.length) && !anyUploading();
    let cls = 'icon-btn send';
    if (canSend) cls += ' ready'; else cls += ' disabled';
    if (anyUploading()) cls += ' loading';
    sendBtn.className = cls;
    sendBtn.innerHTML = anyUploading()
      ? '<div class="spinner"></div>'
      : (isStreaming && !clarifyMode
          ? '<svg viewBox="0 0 24 24"><path d="M6 19L19 6M6 6l13 13"/></svg>'
          : '<svg viewBox="0 0 24 24"><path d="M3 20v-6l9-2-9-2V4l18 8z"/></svg>');
  }
  txt?.addEventListener('input', () => { autoResize(); refreshSendState(); });

  /* ================== å¸ƒå±€ & æ»šåŠ¨ ================== */
  function refreshOverlay(){
    if (!composer) return;
    const h = composer.offsetHeight;
    mask && (mask.style.height = h + 'px');
    arrow && (arrow.style.bottom = (h + 40) + 'px');
    welcome && (welcome.style.bottom = (h + 60) + 'px');
  }
  window.addEventListener('resize', refreshOverlay);
  function toggleArrow(){ arrow && arrow.classList.toggle('show', !chatAtBottom()); }
  chat?.addEventListener('scroll', toggleArrow);
  arrow?.addEventListener('click', ()=> chat.scrollTop = chat.scrollHeight);

  /* ================== Lightbox ================== */
  lightbox?.addEventListener('click', ()=> lightbox.style.display='none');
  window.addEventListener('keyup', e=>{ if (e.key === 'Escape' && lightbox) lightbox.style.display='none'; });

  /* ================== ä¸Šä¼ ï¼ˆMockï¼‰ ================== */
  function mockUpload(file){
    return new Promise(res=>{
      setTimeout(()=> res(URL.createObjectURL(file)), 500 + Math.random()*400);
    });
  }
  function handleFiles(list) {
    [...list].forEach(f=>{
      if(!f.type.startsWith('image/')) return;
      const wrap = document.createElement('div');
      wrap.style.position='relative';
      wrap.innerHTML = `<img src="${URL.createObjectURL(f)}"><button class="close">âœ•</button>`;
      thumbs.appendChild(wrap);
      const obj = { file:f, url:'', uploading:true, node:wrap };
      uploads.push(obj);
      refreshSendState();
      wrap.querySelector('.close').onclick = ()=>{
        uploads = uploads.filter(u=>u!==obj);
        wrap.remove();
        refreshSendState();
      };
      mockUpload(f).then(u=>{
        obj.url = u; obj.uploading = false; refreshSendState();
      });
    });
  }
  plusBtn?.addEventListener('click', ()=> fileInput?.click());
  fileInput?.addEventListener('change', ()=> handleFiles(fileInput.files));
  document.addEventListener('paste', e=>{
    if (!e.clipboardData) return;
    for (const it of e.clipboardData.items) {
      if (it.type.startsWith('image/')) handleFiles([it.getAsFile()]);
    }
  });
  ['dragover','drop'].forEach(evt=>{
    txt?.addEventListener(evt, e=>{
      if (evt==='dragover') e.preventDefault();
      if (evt==='drop') { e.preventDefault(); handleFiles(e.dataTransfer.files); }
    });
  });

  /* ================== Clarify æ§åˆ¶ ================== */
  function enterClarify(question) {
    clarifyMode = true;
    window.SESSION_STATE.status = 'clarify';
    window.SESSION_STATE.lastClarifyQ = question;
    window.SESSION_STATE.clarifyTimes++;
    if (clarifyBanner) {
      clarifyBanner.style.display='block';
      clarifyBanner.innerHTML = `<strong>éœ€è¦æ¾„æ¸…ï¼š</strong>${escapeHtml(question)}<br><span style="font-size:12px;opacity:.8">è¯·è¡¥å……ä¿¡æ¯åå†æ¬¡å‘é€ã€‚</span>`;
    }
    appendMessage('bot', question, { clarify:true });
    refreshSendState();
  }
  function exitClarify() {
    clarifyMode = false;
    if (clarifyBanner) {
      clarifyBanner.style.display='none';
      clarifyBanner.textContent='';
    }
    window.SESSION_STATE.status = 'final_answer';
    refreshSendState();
  }
  function escapeHtml(str=''){
    return str.replace(/[&<>"]/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[s]));
  }

  /* ================== æµå¼æ¸²æŸ“ ================== */
  function startStreaming() {
    isStreaming = true;
    deltaBuffer = '';
    rawAnswerBuffer = '';
    streamingNode = appendMessage('bot', '', { streaming:true });
    if (streamingNode) streamingNode.classList.add('cursor'); // å¯åœ¨ CSS é‡ŒåŠ é—ªçƒåŠ¨ç”»
    refreshSendState();
  }
  function stopStreaming() {
    isStreaming = false;
    streamingNode && streamingNode.classList.remove('streaming');
    refreshSendState();
  }
  function scheduleFlush() {
    if (flushScheduled) return;
    flushScheduled = true;
    requestAnimationFrame(()=>{ flushScheduled = false; flushDelta(); });
  }
  function flushDelta() {
    if (!streamingNode) return;
    streamingNode.innerHTML = renderMarkdown(deltaBuffer);
    scrollToBottom();
  }
  function appendDelta(text) {
    deltaBuffer += text;
    scheduleFlush();
  }
/* startStreaming / appendDelta æ—¥å¿—ï¼ˆç¡®ä¿è°ƒç”¨ï¼‰-*/
  function startStreaming(){
  console.log('[STREAM] startStreaming');
  isStreaming = true;
  deltaBuffer = '';
  rawAnswerBuffer = '';
  streamingNode = appendMessage('bot', '', { streaming:true });
  refreshSendState();
}
function appendDelta(text){
  deltaBuffer += text;
  scheduleFlush();
}

  /* ================== æ³¨å†Œ _MGPTï¼ˆå¯¹å¤–ï¼‰ ================== */
 // ==== (å®šä½: DOMContentLoaded ä¸‹æ–¹ â€œæ³¨å†Œ _MGPTâ€ å¤„) ====
window._MGPT = {
  // é…ç½®
  BASE, API_URL,
  // å…ƒç´ /æ¥å£
  sendBtn, txt,
  // çŠ¶æ€è®¿é—®å™¨
  codeRef: () => code,
  sessionId,
  firstMessageRef: () => firstMessage,
  setFirstMessage: v => firstMessage = v,
  lastFullAnswerRef: () => lastFullAnswer,
  setLastFullAnswer: v => lastFullAnswer = v,
  // ä¸Šä¼ 
  uploads,
  getUploads: () => uploads,
  setUploads: v => uploads = v,
  anyUploading,
  // Streaming èŠ‚ç‚¹/æ§åˆ¶
  streamingNodeRef: () => streamingNode,              // <== ç¡®ä¿æ˜¯å‡½æ•°
  setStreamingNode: n => { streamingNode = n; },
  isStreamingRef: () => isStreaming,
  clarifyModeRef: () => clarifyMode,
  setAbortCtrl: c => abortCtrl = c,
  getAbortCtrl: () => abortCtrl,
  // UI æ“ä½œ
  appendMessage,
  startStreaming,
  stopStreaming,
  appendDelta,
  flushDelta,
  scrollToBottom,
  refreshSendState,
  enterClarify,
  exitClarify,
  escapeHtml,
  autoResize,
  refreshOverlay,
  stripMarkdown,
  scheduleFlush,
  renderMarkdown,
  // ä¼šè¯æ•°æ®
  SESSION_STATE: window.SESSION_STATE,
  HISTORY_KEY,
  // Debug è¾…åŠ©
  debug: DEBUG
};
console.log('[INIT] _MGPT keys:', Object.keys(_MGPT));

  /* ================== ä¸Šä¸‹æ–‡ & Payload ================== */
  function collectRecentUserQueries(latest) {
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      const users = arr.filter(m=>m.role==='user').map(m=>m.content);
      if (latest) users.push(latest);
      return users.slice(-MAX_CTX_USER_QUERIES);
    } catch {
      return latest ? [latest] : [];
    }
  }
  function buildPayload(inputText) {
    const imgs = uploads.filter(u=>!u.uploading && u.url).map(u=>u.url);
    return {
      code,
      session_id: sessionId,
      lastUserQueries: collectRecentUserQueries(inputText),
      images: imgs,
      userRoles: window.USER_ROLES || [],
      industry: window.SELECTED_INDUSTRY || '',
      subIndustry: window.SELECTED_SUB_INDUSTRY || '',
      sessionState: {
        status: window.SESSION_STATE.status,
        lastClarifyQ: window.SESSION_STATE.lastClarifyQ,
        clarifyTimes: window.SESSION_STATE.clarifyTimes
      },
      debug: DEBUG
    };
  }

  /* ================== è‡ªåŠ¨æ¢æµ‹ SSE ï¼ˆå¯é€‰ï¼‰ ================== */
  async function detectSSEOnce() {
    if (sseAvailable !== null) return sseAvailable;
    try {
      const testResp = await fetch(API_URL, {
        method:'POST',
        headers:{
          'Content-Type':'application/json',
          'Accept':'text/event-stream'
        },
        body: JSON.stringify({ code:'__ping__', lastUserQueries:['ping'] })
      });
      // åªè¦ 200 ä¸” Content-Type SSE å°±è®¤ä¸ºå¯ç”¨ï¼›ç«‹å³å–æ¶ˆè¯»å–
      if (/text\/event-stream/i.test(testResp.headers.get('Content-Type')||'')) {
        sseAvailable = 'yes';
      } else {
        sseAvailable = 'no';
      }
    } catch {
      sseAvailable = 'no';
    }
    return sseAvailable;
  }

  /* ================== æµè¯·æ±‚ ================== */
  const MAX_BYTES_DISPLAY = 128000;

  function displayLargeUserInput(str, imgs){
    const enc = new TextEncoder();
    const bytes = enc.encode(str);
    if (bytes.length <= MAX_BYTES_DISPLAY) {
      appendMessage('user', str, { images: imgs });
      return;
    }
    let offset=0, part=0;
    while (offset < bytes.length) {
      const slice = bytes.slice(offset, offset+MAX_BYTES_DISPLAY);
      offset += MAX_BYTES_DISPLAY;
      const chunk = new TextDecoder().decode(slice);
      appendMessage('user', `[ç¬¬ ${++part} éƒ¨åˆ†]\n${chunk}`);
    }
    if (imgs.length) appendMessage('user', '[å›¾ç‰‡]', { images: imgs });
  }

  async function streamRequest(payload) {
    if (USE_SSE === 'auto') {
      const ok = await detectSSEOnce();
      USE_SSE = (ok === 'yes');
      if (DEBUG) console.log('[SSE_DETECT]', ok);
    }
    const useSSENow = (USE_SSE === true);
    const ctrl = new AbortController();
    abortCtrl = ctrl;
    let httpResp;
    try {
      httpResp = await fetch(API_URL + (DEBUG ? '?debug=1':''),
        {
          method:'POST',
            headers:{
              'Content-Type':'application/json',
              ...(useSSENow ? { 'Accept':'text/event-stream' } : {})
            },
            body: JSON.stringify(payload),
            signal: ctrl.signal
        }
      );
      if (DEBUG) {
        console.log('<< /admin-api/ws status', httpResp.status);
        console.log('[resp headers]', [...httpResp.headers.entries()]);
      }
    } catch(e) {
      appendMessage('bot', `âš ï¸ ç½‘ç»œé”™è¯¯ï¼š${e.message||e}`, {});
      stopStreaming();
      return;
    }
    if (!httpResp.ok || !httpResp.body) {
      appendMessage('bot', `âš ï¸ HTTP ${httpResp.status}`, {});
      stopStreaming();
      return;
    }

    const isSSE = /text\/event-stream/i.test(httpResp.headers.get('Content-Type')||'');
    if (useSSENow && !isSSE) {
      // æœåŠ¡å™¨æ²¡æŒ‰é¢„æœŸè¿”å› SSEï¼Œé™çº§
      if (DEBUG) console.warn('[SSE_EXPECTED_BUT_NOT]');
    }
    DEBUG && console.log('[STREAM_MODE]', isSSE ? 'SSE' : 'NDJSON');

    startStreaming();
    const reader  = httpResp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let gotDone = false;

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream:true });

        if (isSSE) {
          let idx;
          while ((idx = buffer.indexOf('\n\n')) !== -1) {
            const block = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 2);
            if (!block) continue;
            let eventName = 'message';
            let dataLine = '';
            block.split('\n').forEach(line=>{
              if (line.startsWith('event:')) eventName = line.replace(/^event:\s*/, '');
              else if (line.startsWith('data:')) dataLine += line.replace(/^data:\s*/, '');
            });
            if (!dataLine) continue;
            let obj;
            try { obj = JSON.parse(dataLine); } catch { continue; }
            if (eventName === 'done') gotDone = true;
            handleEvent(obj, eventName);
          }
        } else { // NDJSON
          let nl;
while ((nl = buffer.indexOf('\n')) !== -1) {
  let line = buffer.slice(0, nl);
  buffer = buffer.slice(nl + 1);
  line = line.replace(/^\uFEFF/, '').trim();
  if (!line) continue;
  let obj;
  try { obj = JSON.parse(line); }
  catch (e) {
    DEBUG && console.warn('[PARSE] bad line len=', line.length, 'head50=', line.slice(0,50), e);
    continue;
  }
  handleEvent(obj, obj.event);
}


        }
      }
      // EOF ä½†æœªæ”¶åˆ° doneï¼šä¹Ÿ finalize
   // === è¯»å–ç»“æŸ ===
if (isStreaming) {
  if (!gotDone) {
    const tail = buffer.trim();
    if (tail) {
      try {
        const tailObj = JSON.parse(tail.replace(/^\uFEFF/, ''));
        if (!tailObj.event) {
          if (tailObj.full) tailObj.event = 'done';
          else if (tailObj.text) tailObj.event = 'delta';
          else tailObj.event = 'error';
        }
        handleEvent(tailObj, tailObj.event);
      } catch(e){
        DEBUG && console.warn('[TAIL_PARSE_FAIL]', e, tail);
      }
    }
  }
  if (!gotStart) {
    DEBUG && console.warn('[WARN] æ²¡æ”¶åˆ° start è¡Œï¼Œå¯èƒ½ Worker æœªå†™å…¥æˆ–è¢«ç¼“å­˜');
  }
  flushDelta();
  finalizeAnswer(rawAnswerBuffer);
}


    } catch (e) {
      if (ctrl.signal.aborted) appendMessage('bot', 'âš ï¸ å·²å–æ¶ˆã€‚');
      else appendMessage('bot', 'âš ï¸ æµä¸­æ–­ï¼š' + e.message);
    } finally {
      stopStreaming();
    }
  }

 function handleEvent(evt, eventName) {
  const type = eventName || evt.event;
  if (DEBUG) console.debug('[evt]', type, evt);

  switch (type) {
    case 'start':
      if (!isStreaming) startStreaming();
      // å¯é€‰ï¼šæ˜¾ç¤ºæ¨¡å‹
      if (evt.model && streamingNode && !streamingNode.dataset.modelShown) {
        streamingNode.dataset.modelShown = '1';
        streamingNode.innerHTML = `<div class="model-tag">ğŸ§  ${evt.model}</div>`;
        deltaBuffer = ''; // åç»­ delta æ¥ç€
      }
      break;

    case 'delta':
      if (!isStreaming) startStreaming();
      if (evt.text) {
        rawAnswerBuffer += evt.text;
        appendDelta(evt.text);
      }
      break;

    case 'clarify':
      flushDelta(); stopStreaming();
      evt.text && enterClarify(evt.text);
      break;

    case 'debug':
      // å»ºè®®ï¼šæŠŠ debug è¾“å‡ºåˆ°ä¸€ä¸ªéšè—åŒº
      logDebug(evt);
      break;

    case 'done':
      flushDelta();
      if (evt.full) rawAnswerBuffer = evt.full;
      finalizeAnswer(rawAnswerBuffer, evt.usage);
      break;

    case 'error':
      flushDelta(); stopStreaming();
      appendMessage('bot', `âš ï¸ å‡ºé”™ï¼š${evt.text || 'Unknown error'}`);
      break;

    default:
      if (DEBUG) console.debug('[evt] æœªè¯†åˆ«', type);
  }
}

  function logDebug(evt){
  let panel = document.getElementById('debugPanel');
  if (!panel) {
    panel = document.createElement('pre');
    panel.id = 'debugPanel';
    panel.style.cssText = 'position:fixed;right:6px;bottom:6px;max-width:420px;max-height:220px;overflow:auto;background:#111;color:#0f0;padding:6px;font:11px/1.4 monospace;z-index:9999;opacity:.85;';
    panel.innerHTML = '[DEBUG PANEL]\n';
    document.body.appendChild(panel);
  }
  panel.textContent += `[${evt.tag||'evt'}] ${evt.text||JSON.stringify(evt)}\n`;
}


function finalizeAnswer(full='', usage){
  console.log('[STREAM] finalizeAnswer fullLen=', full.length, 'deltaLen=', deltaBuffer.length);
  stopStreaming();
  const node = streamingNode;
  if (!node) return;
  const finalText = full || rawAnswerBuffer || deltaBuffer || '(ç©ºå›ç­”)';
  node.classList.remove('streaming');
  node.innerHTML = marked.parse(finalText);

  // usage ä¿¡æ¯
  if (usage && (usage.prompt || usage.completion)) {
    const meta = document.createElement('div');
    meta.className = 'usage';
    const total = (usage.prompt||0) + (usage.completion||0);
    meta.textContent = `ğŸ§® Tokens P:${usage.prompt||0} C:${usage.completion||0} T:${total}`;
    node.appendChild(meta);
  }

  addCopyButton(node, stripMarkdown(finalText));
  lastFullAnswer = finalText;
  exitClarify();
}

  function addCopyButton(node, rawText) {
    if (node.querySelector('.copy-btn')) return;
    const btn = document.createElement('button');
    btn.className = 'copy-btn'; btn.textContent = 'â§‰'; btn.title='å¤åˆ¶';
    btn.onclick = ()=>{
      navigator.clipboard.writeText(rawText);
      btn.textContent='âœ”'; setTimeout(()=>btn.textContent='â§‰',1300);
    };
    node.appendChild(btn);
  }

  function abortStreaming() {
    if (abortCtrl) {
      abortCtrl.abort();
      appendMessage('bot','â¹ å·²æ‰‹åŠ¨åœæ­¢ã€‚');
      stopStreaming();
    }
  }

  /* ================== å‘é€ ================== */
  function uploadsReadyURLs() {
    return uploads.filter(u=>!u.uploading && u.url).map(u=>u.url);
  }
  function clearUploads() {
    uploads.forEach(u=>u.node && u.node.remove());
    uploads = [];
  }

  async function trySend() {
    if (!checkAuthOrWarn()) return;
    if (anyUploading()) return;
    if (!txt) return;
    const inputText = txt.value.trim();
    const images = uploadsReadyURLs();
    if (!inputText && !images.length) return;

    if (clarifyMode) exitClarify();
    if (firstMessage) {
      firstMessage = false;
      document.body.style.overflow = 'auto';
      welcome && welcome.remove();
    }

    displayLargeUserInput(inputText, images);
    txt.value=''; autoResize(); clearUploads();
    refreshSendState();

    const payload = buildPayload(inputText);
    DEBUG && console.log('>> /admin-api/ws payload', payload);
    DEBUG && console.log('[payload.code length]', (payload.code||'').length);
    streamRequest(payload);
  }

  /* ================== äº‹ä»¶ç»‘å®š ================== */
  sendBtn?.addEventListener('click', ()=>{
    if (isStreaming && !clarifyMode) abortStreaming();
    else trySend();
  });
  txt?.addEventListener('keydown', e=>{
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      trySend();
    }
  });
  function updateSendButtonLabel() {
    if (!sendBtn) return;
    if (isStreaming && !clarifyMode) sendBtn.title='ç»ˆæ­¢æœ¬æ¬¡å›ç­”';
    else if (clarifyMode) sendBtn.title='å‘é€æ¾„æ¸…è¡¥å……';
    else sendBtn.title='å‘é€';
  }
  setInterval(updateSendButtonLabel, 400);
  window.addEventListener('beforeunload', e=>{
    if (isStreaming) { e.preventDefault(); e.returnValue=''; }
  });
  window.demoAsk = (q)=>{
    if (!txt) return;
    txt.value=q; autoResize(); refreshSendState(); trySend();
  };

  /* ================== è¯Šæ–­å·¥å…· (å¯é€‰) ================== */
  window.MGPT_TEST_DIAG = async () => {
    try {
      const r = await fetch(BASE + '/diag').then(r=>r.json());
      console.log('[DIAG]', r);
      appendMessage('bot', 'è¯Šæ–­ç»“æœ:\n```json\n'+JSON.stringify(r,null,2)+'\n```');
    } catch(e){
      appendMessage('bot', 'è¯Šæ–­å¤±è´¥: ' + e.message);
    }
  };

  /* ================== åˆå§‹åŒ–é¡ºåº ================== */
  autoResize();
  refreshOverlay();
  refreshSendState();
  toggleArrow();
  initAuth();
  loadHistory();
});
</script>








</body>
</html>
