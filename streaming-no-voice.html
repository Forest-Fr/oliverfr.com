<head>
<meta charset="UTF-8">
<title>Mini-GPT</title>
<link rel="icon" href="MeFan Logo.png" type="image/x-icon">
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root {
  --radius: 24px;
  --grey: #e4e4e7;
  --bubble: #f7f7f8;
  --side-gap: 190px;
  --font: 16px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  overflow-y: auto;           /* 恢复根容器纵向滚动原overflow: hidden; */
    overscroll-behavior-y: auto;/* 允许边界“橡皮筋”回弹并触发浏览器原生下拉刷新 */
  font: var(--font);
  background: #fafafa;
}

body { padding: 40px var(--side-gap) 220px; }

/* 开场提示 */
/* 欢迎语固定底部（动态 JS 调整 bottom） */
#welcome{
  position:fixed;left:50%;transform:translateX(-50%);
  font-size:21px;font-weight:600;line-height:1.2;
  z-index:3000;pointer-events:none;text-align:center;
  max-width:90%;bottom:60px; /* 初始兜底 */
}

/* 聊天区 */
#chat {
  display: flex;
  flex-direction: column;
  gap: 16px;
  height: calc(100vh - 190px);
  padding-left: var(--side-gap);
  overflow-x: auto;
  overflow-y: auto;
  scroll-behavior: smooth;
}
.msg {
  max-width: 100%;
  width: fit-content;
  position: relative;
  padding: 12px 16px;
  background: var(--bubble);
  border-radius: 12px;
  font-size: 15px;
  line-height: 1.55;
  color: #111;
  word-break: break-word;
  white-space: pre-wrap;
}

.msg.bot {
  align-self: flex-start;
  margin-left: calc(-1 * var(--left-gap)) !important;
  transform: translateX(55px);
}

.msg.user {
  align-self: flex-end;
  background: #e0f2ff;
}


/* 聊天气泡 */
.msg {
  max-width: 100%;
  width: fit-content;
  position: relative;
  padding: 12px 16px;
  background: var(--bubble);
  border-radius: 12px;
  font-size: 15px;
  line-height: 1.55;
  color: #111;
  word-break: break-word;
  white-space: pre-wrap;
}
.msg.bot { align-self: flex-start; margin-left: calc(-1 * var(--side-gap)) !important }
.msg.user { align-self: flex-end; background: #e0f2ff; }
.msg.system { align-self: center; background:#fff3cd; color:#7a5a00; }

/* Clarify 特殊气泡 */
.msg.clarify {
  background: #fffbe6;
  border: 1px solid #f5d36b;
  color: #7a5a00;
}

/* Streaming 高亮动画 */
.msg.streaming {
  background: #eef6ff;
  box-shadow: 0 0 0 1px #d0e6ff inset;
  position: relative;
}
.msg.streaming:after {
  content: '';
  position: absolute;
  right: 6px; bottom: 6px;
  width: 8px; height: 8px;
  border-radius: 50%;
  background: #3b82f6;
  animation: pulseDot 1.2s ease-in-out infinite;
}
@keyframes pulseDot {
  0% { transform: scale(.7); opacity:.4; }
  50% { transform: scale(1); opacity:1; }
  100% { transform: scale(.7); opacity:.4; }
}

/* 图片网格 */
.pics {
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
  gap: 8px;
  margin-bottom: 8px;
  max-width: 100%;
  overflow-x: auto;
}
.pics img {
  height: 160px;
  width: auto;
  border-radius: 8px;
  object-fit: cover;
  cursor: pointer;
  transition: filter .2s;
}
.pics img:hover { filter: brightness(.9); }
.pics:has(img:only-child) img { height: auto; max-width: 60%; }

/* 复制按钮 */
.copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 50%;
  background: #0001;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  color: #555;
  cursor: pointer;
  opacity: 0;
  transition: .15s;
}
.msg.bot:hover .copy-btn { opacity: 1; }
.copy-btn:hover { transform: scale(1.15); }

/* 用户消息外侧操作按钮 */
.msg.user .actions {
  position: absolute;
  bottom: -8px;
  right: -48px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: .15s;
}
.msg.user:hover .actions { opacity: 1; }
.action-btn {
  width: 34px;
  height: 34px;
  border-radius: 8px;
  background: #f4f4f4;
  border: 1px solid var(--grey);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: .15s;
}
.action-btn:hover { background: #eaeaea; transform: scale(1.05); }
.action-btn svg { width: 18px; height: 18px; fill: #555; }

.copy-tip {
  position: absolute;
  bottom: 42px;
  right: -2px;
  padding: 4px 8px;
  font-size: 12px;
  background: #000;
  color: #fff;
  border-radius: 6px;
  pointer-events: none;
  opacity: 0;
  animation: tip 2s forwards;
}
@keyframes tip {
  0% { opacity: 0; transform: translateY(4px); }
  10% { opacity: 1; transform: translateY(0); }
  80% { opacity: 1; }
  100% { opacity: 0; transform: translateY(4px); }
}

/* 输入区 */
.composer {
  position: fixed;
  left: 50%;
  bottom: 27px;
  transform: translateX(-50%);
  width: clamp(280px, 90%, 800px);
  z-index: 3000;
}

.box {
  position: relative;
  background: #fff;
  border: 1px solid var(--grey);
  border-radius: var(--radius);
  padding: 16px 64px 60px 64px;
  transition: .2s;
}
.box:focus-within { border-color: #8ab4ff; }
textarea {
  width: 100%;
  min-height: 24px;
  max-height: 180px;
  resize: none;
  overflow-y: auto;
  border: none;
  outline: none;
  background: none;
  font: var(--font);
}
.icon-btn {
  position: absolute;
  bottom: 12px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  cursor: pointer;
}
.plus {
  left: 12px;
  background: #fff;
  border: 1px solid var(--grey);
  font-size: 26px;
}
.plus:hover { background: #f1f1f1; }
.send {
  right: 12px;
  background: #000;
  color: #fff;
  transition: .15s;
}
.send.disabled { opacity: .35; cursor: default; }
.send.loading { opacity: .4; cursor: wait; }
.send.ready:hover { transform: scale(1.08); }
.send svg { width: 24px; height: 24px; fill: #fff; }
.spinner {
  width: 24px;
  height: 24px;
  border: 3px solid #fff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin .8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Clarify Banner */
#clarifyBanner {
  position: absolute;
  left: 16px;
  right: 16px;
  top: 12px;
  background: #fffbe6;
  border: 1px solid #f5d36b;
  color: #7a5a00;
  font-size: 13px;
  padding: 6px 8px;
  border-radius: 8px;
  display: none;
  line-height: 1.35;
}

/* 缩略图 */
.thumbs { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
.thumbs img { width: 64px; height: 64px; border-radius: 8px; }
.close {
  position: absolute;
  right: 2px;
  top: 2px;
  width: 20px;
  height: 20px;
  border: none;
  background: #000a;
  color: #fff;
  border-radius: 50%;
  cursor: pointer;
}

/* 遮罩 */
#mask {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  background: #fafafa;
  pointer-events: none;
  z-index: 2999;
    display: none;       /新增的* 默认隐藏 */
}

/* 回到底部箭头 */
#scrollBottom {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  width: 44px;
  height: 44px;
  border: 1px solid var(--grey);
  border-radius: 50%;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  box-shadow: 0 1px 3px #0002;
  opacity: 0;
  pointer-events: none;
  transition: .18s;
  z-index: 3001;
}
#scrollBottom.show { opacity: 1; pointer-events: auto; }
#scrollBottom:hover { transform: translateX(-50%) scale(1.08); }

/* footer 注脚 */
.footnote {
  position: fixed;
  left: 50%;
  bottom: 2px;
  transform: translateX(-50%);
  font-size: 13px;
  color: #888;
  white-space: nowrap;
  padding: 2px 6px;
  z-index: 3000;
}

/* 灯箱 */
#lightbox {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 4000;
}
#lightbox img {
  max-width: 90vw;
  max-height: 90vh;
  border-radius: 8px;
}

/* 小屏适配 */
@media (max-width: 600px) {
  :root { --side-gap: 12px; }
  body {
    padding-left: var(--side-gap);
    padding-right: var(--side-gap);
  }
  #chat { padding-left: var(--side-gap); }
  .box { padding: 16px 56px 60px 56px; }
  #clarifyBanner { position: static; margin-bottom: 8px; }
}

/* —— 授权弹窗 —— */
#authModal {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0);
  z-index: 1000;
}
#authModal .box {
    position: absolute;
  top: 60px;                /* ✅ 关键：距离顶部190px */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,0.95);
  border-radius: 12px;
  padding: 24px 32px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
  text-align: center;
  min-width: 320px;
}
#authModal h2 { font-size: 1.5rem; margin-bottom: 1rem; }
#authModal input {
  width: 100%; padding: .75rem; font-size: 1rem;
  border: 1px solid #ccc; border-radius: 6px; margin-bottom: 1rem;
}
#authModal button {
  width: 100%; padding: .75rem; font-size: 1rem;
  border: none; border-radius: 6px; background: #3b82f6;
  color: #fff; cursor: pointer; transition: background .2s;
}
#authModal button:disabled { background: #8fbefc; cursor: not-allowed; }
#authErr { color: #d9534f; margin-top: .5rem; font-size: .9rem; display: none; }

/* —— GPT Markdown 可视化支持（原样保留） —— */
.msg.bot code {
  background: #f5f5f5;
  padding: 2px 4px;
  border-radius: 4px;
  font-family: Menlo, Consolas, monospace;
  font-size: 0.95em;
}
.msg.bot pre {
  background: #1e1e1e;
  color: #f8f8f2;
  padding: 1em;
  border-radius: 6px;
  overflow-x: auto;
  margin: 1em 0;
}
.msg.bot pre code { background: none; color: inherit; padding: 0; border-radius: 0; }
pre.qa-report {
  background: #f2f7ff;
  border-left: 4px solid #3b82f6;
  padding: 12px;
  border-radius: 6px;
  margin: 1em 0;
  overflow-x: auto;
  font-family: Menlo, Consolas, monospace;
  font-size: 0.95em;
  color: #1a202c;
}
pre.qa-report code { background: none; padding: 0; color: inherit; white-space: pre-wrap; word-break: break-word; }
.msg.bot blockquote {
  border-left: 4px solid #dfe2e5;
  background: #f9f9f9;
  padding: 0.5em 1em;
  margin: 1em 0;
  color: #555;
}
.msg.bot blockquote.callout { border-left-color: #38a169; background: #f0fff4; }
.msg.bot blockquote.callout > p:first-child { font-weight: bold; }
.msg.bot hr { border: none; border-top: 1px solid #ddd; margin: 1.5em 0; }
.msg.bot ul, .msg.bot ol { margin: 1em 0; padding-left: 1.5em; }
.msg.bot ul ul, .msg.bot ol ol, .msg.bot ul ol, .msg.bot ol ul {
  margin-top: 0.5em; margin-bottom: 0.5em;
}
.msg.bot li.task-list-item {
  list-style: none;
  display: flex;
  align-items: flex-start;
}
.msg.bot li.task-list-item > input[type="checkbox"] {
  margin-right: 0.5em;
  vertical-align: middle;
}
.msg.bot table {
  width: 100%;
  border-collapse: collapse;
  margin: 1em 0;
}
.msg.bot th, .msg.bot td {
  border: 1px solid #ccc;
  padding: 0.6em;
  text-align: left;
}
.msg.bot th { background: #f3f4f6; }
.msg.bot img {
  max-width: 100%;
  border-radius: 6px;
  margin: 1em 0;
}
.msg.bot a { color: #3b82f6; text-decoration: none; }
.msg.bot a:hover { text-decoration: underline; }
.msg.bot .math, .msg.bot .katex {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.msg._meta {
  display: flex !important;
  justify-content: flex-start !important;
  align-items: center !important;
  background: transparent !important;
  padding: 4px 8px !important;
  margin: 4px 0 !important;
}
.msg._meta > * { max-width: none !important; }
.msg._meta .copy-btn { display: none !important; }

/* —— ChatGPT 样式侧栏 —— */
#hamburger {
  position: absolute;
  top: 12px; left: 12px;
  z-index: 1000;
  padding: 6px;
  border: none;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  display: none;
}
@media (max-width: 767px) {
  #hamburger { display: block; }
}

aside#sidebar {
  position: fixed; top: 0; left: 0;
  width: 240px; height: 100%;
  padding: 16px;
  background: #202123; color: #fff;
  transform: translateX(0);
  transition: transform .2s ease;
  z-index: 1001;
}
@media (max-width: 767px) {
  aside#sidebar { transform: translateX(-100%); }
  aside#sidebar.show { transform: translateX(0); }
}

#sidebarOverlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,.4);
  opacity: 0; visibility: hidden;
  transition: opacity .2s ease;
  z-index: 1000;
}
#sidebarOverlay.show {
  opacity: 1; visibility: visible;
}

/* 复用你已有的 .btn, .search-box 样式 */
/* 新增列表项样式 */
#chatList {
  margin-top: 12px;
  overflow-y: auto;
  max-height: calc(100% - 80px);
}
.chat-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 8px;
  cursor: pointer;
}
.chat-item:hover { background: #343541; }
.chat-item span {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: #fff;
}
.chat-item button {
  background: none;
  border: none;
  color: #aaa;
  margin-left: 4px;
  cursor: pointer;
}
.chat-item button:hover { color: #fff; }

/* === 三点菜单样式 === */
.chat-item {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  padding: 6px 12px 6px 10px;
  cursor: pointer;
}
.chat-item.active      { background:#343541; }
.chat-item:hover .dots { opacity: 1; }

.chat-item .title {
  flex: 1;
  max-width: 160px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color:#fff;
}

.menu.dots{
  opacity:.0;
  border:none; background:none;
  font-size:18px; color:#aaa;
  cursor:pointer;
}
.menu.dots:hover{color:#fff}

.pop{
  position:absolute; right:34px; top:6px;
  background:#fff; color:#111;
  border:1px solid #eee; border-radius:8px;
  box-shadow:0 4px 18px rgb(0 0 0 / .15);
  padding:4px 0; min-width:120px;
  display:none;  z-index:5000;
}
.pop.show{display:block}

.pop button{
  width:100%; border:none; background:none;
  padding:8px 14px; font-size:14px; text-align:left;
  cursor:pointer;
}
.pop button:hover{background:#f3f4f6}
.pop .del-btn{color:#d92d20}
/* === END 三点菜单样式 === */

/* === mobile slide‑out effect === */
@media (max-width: 767px) {
  body.slide-right {                       /* 主面板随侧栏平移 */
    transform: translateX(240px);          /* 侧栏宽度 */
    transition: transform .25s ease;
    overflow: hidden;                      /* 禁止背景滚动 */
  }
  aside#sidebar { transition: transform .25s ease; }
}

//


  @media (max-width: 767px) {
  body.slide-right {                       
    transform: translateX(240px);
    transition: transform .25s ease;
    overflow: hidden;
  }
  aside#sidebar { transition: transform .25s ease; }

  /* —— 新增：当 body.slide-right 时，也把 fixed 的 composer 推过去 —— */
  body.slide-right .composer {
    /* 原本 .composer 是 translateX(-50%) 居中，
       这里在它的计算里 +240px，才能和聊天区保持一致 */
    transform: translateX(calc(-50% + 240px));
  }
}


  

  /* ====== Mobile drawer patch pack ====== */
@media (max-width: 767px) {
  :root { --drawer-w: 240px; }

  /* 1) 主体整体右移（你已有，但整合成一处） */
  body.slide-right {
    transform: translateX(var(--drawer-w));
    transition: transform .25s ease;
    overflow: hidden;
  }
  aside#sidebar { transition: transform .25s ease; }

  /* 2) 所有 fixed 元素跟着右移（和 ChatGPT 一样整体推走） */
  body.slide-right .composer,
  body.slide-right .footnote,
  body.slide-right #welcome,
  body.slide-right #scrollBottom,
  body.slide-right #mask,
  body.slide-right #authModal .box,
  body.slide-right #lightbox img /* 仅当你希望灯箱也跟着推；不需要可删 */
  {
    transform: translateX(calc(var(--drawer-w))) translateX(-50%) !important;
  }
  /* 注意：上面元素里有原本就用 translateX(-50%) 居中的，故加一个累加 translateX */

  /* 对不需要居中、只有 left:50% 的可单独覆盖（如果某元素不用 -50% 居中的话）：*/
  body.slide-right .footnote,
  body.slide-right #scrollBottom {
    transform: translateX(calc(var(--drawer-w)));
  }

  /* 3) 消除左侧“白条”——当侧栏显示时，把 body 的 padding-left 设为 0 */
  body.slide-right {
    padding-left: 0 !important;
  }
  /* chat 内 padding-left 同样处理，避免内容被挤 */
  body.slide-right #chat {
    padding-left: var(--side-gap);
  }

  /* 4) 侧栏默认隐藏，显示时用 .show 控制（你已有，这里只是确保优先级够） */
  aside#sidebar { transform: translateX(-100%); }
  aside#sidebar.show { transform: translateX(0); }

  /* 5) Overlay 保持不变即可，但注意 z-index 关系 */
  #sidebarOverlay { z-index: 1000; }
}

/* 让 footnote 不被遮挡，同时在桌面端保持原样 */
.footnote { transition: transform .25s ease; }
#scrollBottom { transition: transform .25s ease; }
#welcome { transition: transform .25s ease; }
#mask { transition: transform .25s ease; }
.composer { transition: transform .25s ease; }


  /* ====== PATCH: 移除手机端抽屉展开时的左侧空白 ====== */
@media (max-width: 767px) {

  :root { --drawer-w: 240px; }

  /* 主体右移仍保留，但左 padding 必须清零 */
  body.slide-right {
    padding-left: 0 !important;
    margin-left: 0 !important;
  }

  /* 聊天主面板及容器同步去掉左 padding/margin */
  body.slide-right #chat,
  body.slide-right main#chat,
  body.slide-right .chat-wrapper,
  body.slide-right #mask {
    padding-left: 0 !important;
    margin-left: 0 !important;
  }

  /* 任何使用 var(--side-gap) 的块在抽屉打开时清零（防止再挤出空白） */
  body.slide-right [style*="var(--side-gap)"] {
    padding-left: 0 !important;
    margin-left: 0 !important;
  }

  /* 机器人气泡那条 calc(-1 * var(--side-gap)) 也会把内容再往左拉，抽屉开时归零 */
  body.slide-right .msg.bot {
    margin-left: 0 !important;
    transform: none !important;
  }

  /* 如果你还有别的固定元素没有推过去，这里统一再右移一次（上轮已加，这里补充选择器） */
  body.slide-right .composer,
  body.slide-right .footnote,
  body.slide-right #welcome,
  body.slide-right #scrollBottom {
    transform: translateX(calc(var(--drawer-w))) translateX(-50%) !important;
    /* 对不采用 -50% 居中定位的元素单独写： */
  }
  /* 这两个不是居中，直接平移 */
  body.slide-right .footnote,
  body.slide-right #scrollBottom {
    transform: translateX(var(--drawer-w)) !important;
  }

  /* 防止横向滚动条出现 */
  html, body {
    overflow-x: hidden;
  }
}


 /* ====== FINAL PATCH: 彻底移除抽屉开启时的左侧空白 ====== */
@media (max-width: 767px) {
  :root { --drawer-w: 240px; }

  /* 1) 抽屉没开时仍保留你的 side-gap；只在 slide-right 时清零 */
  body.slide-right {
    padding-left: 0 !important;
    padding-right: 0 !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    /* 如果你要保持 transform 推动主屏，这里保留 */
    transform: translateX(var(--drawer-w));
    transition: transform .25s ease;
    overflow-x: hidden;
  }

  /* 2) 主聊天容器的 left padding 也一起清零 */
  body.slide-right #chat,
  body.slide-right main#chat {
    padding-left: 0 !important;
    margin-left: 0 !important;
  }

  /* 3) 任何依赖 --side-gap 的块全部打回 0（防御式覆盖）*/
  body.slide-right [style*="var(--side-gap)"],
  body.slide-right .use-side-gap {
    padding-left: 0 !important;
    margin-left: 0 !important;
  }

  /* 4) 机器人气泡在抽屉开时不要再负移出去 */
  body.slide-right .msg.bot {
    margin-left: 0 !important;
    transform: none !important;
  }

  /* 5) 固定元素整体平移（上一轮已做，这里只是补确保优先级） */
  body.slide-right .composer,
  body.slide-right .footnote,
  body.slide-right #welcome,
  body.slide-right #scrollBottom,
  body.slide-right #mask {
    /* 你的原版是用 translateX(-50%) 居中，所以用叠加计算 */
    transform: translateX(calc(var(--drawer-w))) translateX(-50%) !important;
    transition: transform .25s ease;
  }
  /* 非居中元素（只靠 left/right 定位）单独写 */
  body.slide-right .footnote,
  body.slide-right #scrollBottom {
    transform: translateX(var(--drawer-w)) !important;
  }

  /* 6) 侧栏自身逻辑保持不变（确保它盖住最左边） */
  aside#sidebar { transform: translateX(-100%); transition: transform .25s ease; }
  aside#sidebar.show { transform: translateX(0); }

  /* 7) 防止横向滚动条 */
  html, body { overflow-x: hidden; }
}
 
/* === 锁定状态下禁止侧栏交互 === */
#sidebar.locked,
#sidebar.locked * {
  pointer-events: none;
  opacity: .35;
}

/* ===== Drawer 最终补丁：不再平移 body，自然消除白条 ===== */
@media (max-width: 767px) {
  :root { --drawer-w: 240px; }

  /* 1. 侧栏逻辑保持原状 */
  aside#sidebar      { transform: translateX(-100%); transition: transform .25s ease; }
  aside#sidebar.show { transform: translateX(0); }

  /* 2. 不移动 body，本轮彻底移除 body 的 transform */
  body.slide-right {
    transform: none !important;
    overflow: hidden;               /* 锁滚动 */
    padding-left: 0 !important;     /* 清掉 190px padding-left 根源 */
    margin-left: 0 !important;
  }

  /* 3. 主界面所有需要右移的元素单独推过去 */
  body.slide-right #chat,
  body.slide-right main#chat,
  body.slide-right .composer,
  body.slide-right .footnote,
  body.slide-right #welcome,
  body.slide-right #scrollBottom,
  body.slide-right #mask,
  body.slide-right #authModal .box {
    transition: transform .25s ease;
    transform: translateX(var(--drawer-w)) !important;
  }

  /* 4. 机器人气泡用过负 margin，把它在抽屉打开时归零 */
  body.slide-right .msg.bot {
    margin-left: 0 !important;
    transform: none !important;
  }

  /* 5. chat 内部 padding-left 190 也要清零，否则还会挤空白 */
  body.slide-right #chat {
    padding-left: 0 !important;
  }

  /* 防止横向滚动条 */
  html, body { overflow-x: hidden; }
}


  
  /* ——— 搜索弹窗 ——— */
#searchModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 5000;
}
.search-box-panel {
  background: #fff;
  width: clamp(300px, 80%, 600px);
  max-height: 80vh;
  border-radius: 12px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.search-header {
  display: flex;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid #eee;
}
.search-header input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 1rem;
}
.search-header button {
  margin-left: 8px;
  border: none;
  background: none;
  font-size: 1.4rem;
  cursor: pointer;
}
.results {
  overflow-y: auto;
  padding: 8px 0;
}
.results .group-title {
  padding: 6px 16px;
  font-size: 0.85rem;
  color: #666;
  background: #f9f9f9;
}
.results .item {
  display: flex;
  align-items: center;
  padding: 10px 16px;
  cursor: pointer;
  transition: background .15s;
}
.results .item:hover { background: #f2f2f2; }
.results .item .icon {
  margin-right: 12px;
  font-size: 1.1rem;
  color: #888;
}
.results .item .title {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

</style>
</head>
<body>

<h1 id="welcome">今天有什么议程？</h1>

<main id="chat"></main>
<div id="mask"></div>
<button id="scrollBottom" aria-label="滚动到底部">↓</button>

<div class="composer">
  <div class="box">
    <div id="clarifyBanner"></div> <!-- === NEW Clarify Banner -->
    <div id="thumbs" class="thumbs"></div>
    <textarea id="prompt" rows="1" placeholder="询问任何问题"
              spellcheck="false" autocomplete="off"></textarea>
    <button id="plus" class="icon-btn plus">+</button>
    <button id="send" class="icon-btn send disabled">
      <svg viewBox="0 0 24 24"><path d="M3 20v-6l9-2-9-2V4l18 8z"/></svg>
    </button>
    <input id="file" type="file" accept="image/*" multiple hidden>
  </div>
</div>

<p class="footnote">Mini‑GPT 也可能会犯错。请核查重要信息。</p>

<div id="lightbox"><img alt=""></div>

<div id="authModal">
  <div class="box">
    <h2>请输入授权码</h2>
    <input id="authInput" type="password" placeholder="授权码"/>
    <button id="authBtn" disabled>确认</button>
    <div id="authErr"></div>
  </div>
</div>
<button id="hamburger">☰</button>

<aside id="sidebar">
  <button id="btnNewChat" class="btn">＋ 新建聊天</button>
  <div class="search-box">
    <input type="text" id="chatSearch" placeholder="搜索聊天">
  </div>
  <div id="chatList"></div>
</aside>
<!-- 全屏搜索弹窗 -->
<div id="searchModal">
  <div class="search-box-panel">
    <div class="search-header">
      <input id="modalSearchInput" type="text" placeholder="搜索聊天…" autocomplete="off" />
      <button id="modalCloseBtn" aria-label="关闭">×</button>
    </div>
    <div id="modalResults" class="results"></div>
  </div>
</div>

<div id="sidebarOverlay"></div>



<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>


<script>
/* ================== 版本标识 ================== */
if (window._MGPT && window._MGPT.__VERSION__) {
  console.warn('[INIT] 已存在 _MGPT 版本', window._MGPT.__VERSION__, '终止再次初始化。');
} else {

const FRONTEND_VERSION = 'fe-stream-20250720-merged-02+patch-set-01';

/* ================== Marked 配置 ================== */
marked.setOptions({
  gfm: true,
  breaks: false,
  sanitize: false,
  mangle: false,
  headerIds: false,
  allowDangerousHtml: true
});

document.addEventListener('DOMContentLoaded', () => {

  /* 占位对象 */
if (!window._MGPT) window._MGPT = {};
  /* ================== 基础配置 ================== */
  const BASE        = "https://streaming-tts.mefans.workers.dev";
  const API_URL     = BASE + "/admin-api/ws";
  const AUTH_URL    = BASE + "/admin-api/validate-code";
  const DEV_MODE    = false;
  const DEBUG       = true;
  // [PATCH-6] 认证头策略（避免 CORS）：'authorization' | 'custom' | 'none'
  const AUTH_HEADER_MODE = 'authorization';
  /**
   * USE_SSE:
   *  false => 强制 NDJSON
   *  true  => 强制 SSE
   *  'auto'=> 探测
   */
  let USE_SSE       = false;
  const MAX_CTX_USER_QUERIES = 8;

  /* ================== DOM 引用 ================== */
  const chat       = document.getElementById('chat');
  const txt        = document.getElementById('prompt');
  const sendBtn    = document.getElementById('send');
  const plusBtn    = document.getElementById('plus');
  const fileInput  = document.getElementById('file');
  const thumbs     = document.getElementById('thumbs');
  const arrow      = document.getElementById('scrollBottom');
  const composer   = document.querySelector('.composer');
  const welcome    = document.getElementById('welcome');
  const mask       = document.getElementById('mask');
  const lightbox   = document.getElementById('lightbox');
  const lightImg   = lightbox?.querySelector('img') || new Image();
  const clarifyBanner = document.getElementById('clarifyBanner');
  const authModal  = document.getElementById('authModal');
  const authInput  = document.getElementById('authInput');
  const authBtn    = document.getElementById('authBtn');
  const authErr    = document.getElementById('authErr');

  /* ================== 会话/状态 ================== */
  let sessionId = localStorage.getItem('session_id');
  if (!sessionId) {
    sessionId = crypto.randomUUID();
    localStorage.setItem('session_id', sessionId);
  }
  // ——— [PATCH‑MIGRATE] 旧单桶历史迁移 —————————————
  (function migrateOldHistory() {
    const OLD_KEY = 'chat_history';
    const NEW_KEY = `chat_history_${sessionId}`;
    try {
       const raw = localStorage.getItem(OLD_KEY);
      if (raw) {
        localStorage.setItem(NEW_KEY, raw);
        localStorage.removeItem(OLD_KEY);
         console.log('[HISTORY] migrated old history to', NEW_KEY);
 }
      } catch (e) {

      console.warn('[HISTORY‑MIGRATE] failed:', e);
       }
    })();
        
  /*-const HISTORY_KEY = `chat_history_${sessionId}`;-*/
  // ↓ 不再固定，而是一个函数
  const HISTORY_KEY_STATIC = `chat_history_${sessionId}`;   // 仅供首次无会话时使用
  // 简写：任何时候要用当前桶都走这个函数
  const histKey = id => `chat_history_${id ?? currentChatId}`;
  /*-const _histKey = id => `chat_history_${id || currentChatId}`;-*/
// ——— [PATCH] 读取时优先用动态桶，否则回退静态桶 —————————
  function getHistoryKey(id) {
    const dyn = `chat_history_${id}`;
     // 动态桶里有数据就用它
    if (localStorage.getItem(dyn)) return dyn;
     // 否则回退到最初的静态桶
     return HISTORY_KEY_STATIC;
    }
  let uploads          = [];
  let isAuthorized     = false;
  let isStreaming      = false;
  let clarifyMode      = false;
  let streamingNode    = null;
  let abortCtrl        = null;
  let deltaBuffer      = '';
  let flushScheduled   = false;
  let firstMessage     = true;
  let lastFullAnswer   = '';
  let rawAnswerBuffer  = '';
  let gotStart         = false;
  let gotDone          = false;
  let sseAvailable     = null;
  // [PATCH-3] 当前流 token
  let CURRENT_STREAM_TOKEN = '';

  window.SESSION_STATE = window.SESSION_STATE || {
    status: 'final_answer',
    lastClarifyQ: '',
    clarifyTimes: 0
  };
  window.USER_ROLES = window.USER_ROLES || [];
  window.SELECTED_INDUSTRY = window.SELECTED_INDUSTRY || '';
  window.SELECTED_SUB_INDUSTRY = window.SELECTED_SUB_INDUSTRY || '';
  let code = '';

  /* ================== 历史 ================== */
function loadHistory() {
try {
// 优先读动态桶，否则回退静态桶
 const key = getHistoryKey(currentChatId || sessionId);
const raw = localStorage.getItem(key);
if (!raw) return;
const arr = JSON.parse(raw);
 arr.forEach(replayMessage);
// 只有用户已授权且有历史，才移除欢迎
if (arr.length && isAuthorized) {
document.body.style.overflow = 'auto';
welcome && welcome.remove();
 }
} catch (e) {
console.warn('[loadHistory] 读取失败', e);
 }
 }
  function saveMessage(role, content, meta={}) {
    try {
      const raw = localStorage.getItem(histKey(currentChatId));
      const arr = raw ? JSON.parse(raw) : [];
      arr.push({ role, content, meta, ts: Date.now() });
      localStorage.setItem(histKey(currentChatId), JSON.stringify(arr));
    } catch(e){ console.warn('历史写入失败', e); }
  }
  function replayMessage(m) {
    appendMessage(m.role, m.content, { noSave: true, meta: m.meta });
  }

  /* ================== 工具函数 ================== */
  function chatAtBottom(pad=200){
    if (!chat) return true;
    return chat.scrollHeight - chat.scrollTop - chat.clientHeight < pad;
  }
  function scrollToBottom(force=false){
    if (!chat) return;
    if (force || chatAtBottom()) chat.scrollTop = chat.scrollHeight;
  }
  function autoResize() {
    if (!txt) return;
    txt.style.height = '24px';
    txt.style.height = Math.min(txt.scrollHeight, 180) + 'px';
  }
  function renderMarkdown(md) {
    if (!md) return '';
    try {
      return marked.parse(md);
    } catch(e){
      return md.replace(/[&<>]/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[s])).replace(/\n/g,'<br>');
    }
  }
  function safeText(t) {
    if (typeof t !== 'string') return '';
    return t;
  }
  function createMsgDiv(role, extraClass='') {
    const div = document.createElement('div');
    div.className = `msg ${role} ${extraClass}`.trim();
    chat && chat.appendChild(div);
    return div;
  }
  function appendMessage(role, text, {
    images = [],
    streaming = false,
    noSave = false,
    meta = null,
    clarify = false
  } = {}) {
    if (!chat) return;
    if (!text && !images.length && !streaming) return; // [HOTFIX-stream-placeholder]
    const extras = [];
    if (streaming) extras.push('streaming');
    if (clarify)  extras.push('clarify');
    const div = createMsgDiv(role, extras.join(' '));

    if (streaming && !text) {
      div.innerHTML = '<em style="opacity:.55">⌛ 流式生成中...</em>'; }
     if (images.length) {
      const pics = document.createElement('div');
      pics.className = 'pics';
      images.forEach(src=>{
        const im = new Image();
        im.src = src;
        im.loading = 'lazy';
        im.onclick = () => {
          if (!lightbox) return;
            lightImg.src = src;
            lightbox.style.display = 'flex';
        };
        pics.appendChild(im);
      });
      div.appendChild(pics);
    }
    if (text) div.innerHTML += renderMarkdown(safeText(text));

    if (role === 'bot' && !streaming && !clarify) {
      addCopyButton(div, stripMarkdown(text));
    }
    if (role === 'user') {
      const acts = document.createElement('div');
      acts.className = 'actions';
      const copyBtn = document.createElement('button');
      copyBtn.className='action-btn';
      copyBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
      copyBtn.onclick = ()=>{
        navigator.clipboard.writeText(text);
        showCopyTip(div);
      };
      const editBtn = document.createElement('button');
      editBtn.className='action-btn';
      editBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM21.41 6.34a1.25 1.25 0 0 0 0-1.77l-2.99-2.99a1.25 1.25 0 0 0-1.77 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/></svg>';
      editBtn.onclick = ()=>{
        if (!txt) return;
        txt.value = text;
        autoResize();
        txt.focus();
      };
      acts.append(copyBtn, editBtn);
      div.appendChild(acts);
    }
    if (!noSave && role !== 'stream-temp') {
      saveMessage(role, text, { images, meta, clarify });
    }
    scrollToBottom(true);
    return div;
  }
  function showCopyTip(parent){
    const tip = document.createElement('div');
    tip.className='copy-tip';
    tip.textContent='已复制';
    parent.appendChild(tip);
    setTimeout(()=>tip.remove(),1600);
  }
  function stripMarkdown(md=''){
    return md
      .replace(/```[\s\S]*?```/g,'')
      .replace(/`([^`]+)`/g,'$1')
      .replace(/\!\[[^\]]*\]\([^)]+\)/g,'')
      .replace(/\[[^\]]*\]\(([^)]+)\)/g,'$1')
      .replace(/[#>*_~`]/g,'')
      .trim();
  }

/* ======= 授权 ======= */
  function unlockUI(){
    txt && (txt.disabled = false);
    plusBtn && (plusBtn.disabled = false);
    sendBtn && (sendBtn.disabled = false);
    refreshSendState();
    mask && (mask.style.display='none');
  }
  function lockUI(){
    txt && (txt.disabled = true);
    plusBtn && (plusBtn.disabled = true);
    sendBtn && (sendBtn.disabled = true);
  }
  function initAuth(){
    if (DEV_MODE) {
      isAuthorized = true;
      code = 'dev-bypass';
      authModal && (authModal.style.display='none');
      unlockUI();
      return;
    }
    const saved = localStorage.getItem('auth_code');
    if (saved) {
      isAuthorized = true;
      code = saved;
      authModal && (authModal.style.display='none');
      unlockUI();
    } else {
      isAuthorized = false;
      lockUI();
      authModal && (authModal.style.display='flex');
    }
  }
  authInput?.addEventListener('input', ()=>{
    authBtn && (authBtn.disabled = !authInput.value.trim());
    authErr && (authErr.style.display='none');
  });
  authBtn?.addEventListener('click', async ()=>{
    authBtn.disabled = true;
    const val = authInput.value.trim();
    try {
      const r = await fetch(AUTH_URL, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ code: val })
      }).then(r=>r.json());
      if(!r.ok) throw new Error('授权失败');
      isAuthorized = true;
      code = val;
      localStorage.setItem('auth_code', val);
      authModal && (authModal.style.display='none');
      unlockUI();
    } catch(e){
      authErr && (authErr.textContent = e.message || '授权错误');
      authErr && (authErr.style.display = 'block');
    } finally {
      authBtn.disabled = false;
    }
  });
  function checkAuthOrWarn(){
    if (DEV_MODE || isAuthorized) return true;
    alert('请先输入授权码！');
    return false;
  }
  





  /* ================== 按钮状态 ================== */
  function anyUploading(){ return uploads.some(u=>u.uploading); }
  function refreshSendState() {
    if (!sendBtn) return;
    if (isStreaming && !clarifyMode) {
      sendBtn.className = 'icon-btn send loading';
      sendBtn.innerHTML = '<div class="spinner"></div>';
      return;
    }
    const t = (txt?.value||'').trim();
    const canSend = (t || uploads.length) && !anyUploading();
    let cls = 'icon-btn send';
    cls += canSend ? ' ready' : ' disabled';
    if (anyUploading()) cls += ' loading';
    sendBtn.className = cls;
    sendBtn.innerHTML = anyUploading()
      ? '<div class="spinner"></div>'
      : (isStreaming && !clarifyMode
          ? '<svg viewBox="0 0 24 24"><path d="M6 19L19 6M6 6l13 13"/></svg>'
          : '<svg viewBox="0 0 24 24"><path d="M3 20v-6l9-2-9-2V4l18 8z"/></svg>');
  }
  txt?.addEventListener('input', () => { autoResize(); refreshSendState(); });

  /* ================== 布局 & 滚动 ================== */
  function refreshOverlay(){
    if (!composer) return;
    const h = composer.offsetHeight;
    mask && (mask.style.height = h + 'px');
    arrow && (arrow.style.bottom = (h + 40) + 'px');
    welcome && (welcome.style.bottom = (h + 60) + 'px');
  }
  window.addEventListener('resize', refreshOverlay);
  function toggleArrow(){ arrow && arrow.classList.toggle('show', !chatAtBottom()); }
  chat?.addEventListener('scroll', toggleArrow);
  arrow?.addEventListener('click', ()=> chat.scrollTop = chat.scrollHeight);

  /* ================== Lightbox ================== */
  lightbox?.addEventListener('click', ()=> lightbox.style.display='none');
  window.addEventListener('keyup', e=>{ if (e.key === 'Escape') lightbox && (lightbox.style.display='none'); });

  /* ================== 上传（Mock） ================== */
  function mockUpload(file){
    return new Promise(res=>{
      setTimeout(()=> res(URL.createObjectURL(file)), 480 + Math.random()*420);
    });
  }
  function handleFiles(list) {
    [...list].forEach(f=>{
      if(!f.type.startsWith('image/')) return;
      const wrap = document.createElement('div');
      wrap.style.position='relative';
      wrap.innerHTML = `<img src="${URL.createObjectURL(f)}"><button class="close">✕</button>`;
      thumbs.appendChild(wrap);
      const obj = { file:f, url:'', uploading:true, node:wrap };
      uploads.push(obj);
      refreshSendState();
      wrap.querySelector('.close').onclick = ()=>{
        uploads = uploads.filter(u=>u!==obj);
        wrap.remove();
        refreshSendState();
      };
      mockUpload(f).then(u=>{
        obj.url = u; obj.uploading = false; refreshSendState();
      });
    });
  }
  plusBtn?.addEventListener('click', ()=> fileInput?.click());
  fileInput?.addEventListener('change', ()=> handleFiles(fileInput.files));
  document.addEventListener('paste', e=>{
    if (!e.clipboardData) return;
    for (const it of e.clipboardData.items) {
      if (it.type.startsWith('image/')) handleFiles([it.getAsFile() ]);
    }
  });
  ;['dragover','drop'].forEach(evt=>{
    txt?.addEventListener(evt, e=>{
      if (evt==='dragover') e.preventDefault();
      if (evt==='drop') { e.preventDefault(); handleFiles(e.dataTransfer.files); }
    });
  });

  /* ================== Clarify 控制 ================== */
  function enterClarify(question) {
    clarifyMode = true;
    window.SESSION_STATE.status = 'clarify';
    window.SESSION_STATE.lastClarifyQ = question;
    window.SESSION_STATE.clarifyTimes++;
    if (clarifyBanner) {
      clarifyBanner.style.display='block';
      clarifyBanner.innerHTML =
        `<strong>需要澄清：</strong>${escapeHtml(question)}<br><span style="font-size:12px;opacity:.8">请补充后再次发送。</span>`;
    }
    appendMessage('bot', question, { clarify:true });
    refreshSendState();
    updateSendButtonLabel(); // [PATCH-5]
  }
  function exitClarify() {
    clarifyMode = false;
    if (clarifyBanner) {
      clarifyBanner.style.display='none';
      clarifyBanner.textContent='';
    }
    window.SESSION_STATE.status = 'final_answer';
    refreshSendState();
    updateSendButtonLabel(); // [PATCH-5]
  }
  function escapeHtml(str=''){
    return str.replace(/[&<>"]/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[s]));
  }

  /* ================== Streaming 渲染 ================== */
  function safeRemoveStreamingClass(node){
    try { node?.classList?.remove?.('streaming'); } catch(e){
      DEBUG && console.warn('[safeRemoveStreamingClass]', e);
    }
  }
  function startStreaming() {
    if (isStreaming) return;
    DEBUG && console.log('[STREAM] startStreaming');
    isStreaming = true;
    deltaBuffer = '';
    rawAnswerBuffer = '';
    gotStart = false;
    gotDone = false;
    streamingNode = appendMessage('bot', '', { streaming:true });
    if (streamingNode) streamingNode.dataset.streamToken = CURRENT_STREAM_TOKEN; // [PATCH-3]
    refreshSendState();
  }
  function stopStreaming() {
    isStreaming = false;
    safeRemoveStreamingClass(streamingNode); // [PATCH-1]
    refreshSendState();
  }

  function scheduleFlush() {
    if (flushScheduled) return;
    flushScheduled = true;
    requestAnimationFrame(()=>{ flushScheduled = false; flushDelta(); });
  }
  function flushDelta() {
    if (!streamingNode) return;
     try {
       streamingNode.innerHTML = renderMarkdown(deltaBuffer);
       } catch(e){
       DEBUG && console.warn('[flushDelta:fail]', e);
       streamingNode.textContent = deltaBuffer;
       }
    scrollToBottom();
  }
  function appendDelta(text) {
    deltaBuffer += text;
    scheduleFlush();
  }

  /* ================== _MGPT 注册 ================== */
  window._MGPT = {
    __VERSION__: FRONTEND_VERSION,
    BASE, API_URL,
    sendBtn, txt,
    codeRef: ()=>code,
    sessionId,
    firstMessageRef: ()=>firstMessage,
    setFirstMessage: v=>firstMessage=v,
    lastFullAnswerRef: ()=>lastFullAnswer,
    setLastFullAnswer: v=>lastFullAnswer=v,
    uploads,
    getUploads: ()=>uploads,
    setUploads: v=>uploads=v,
    anyUploading,
    streamingNodeRef: ()=>streamingNode,
    setStreamingNode: n=>{ streamingNode=n; },
    isStreamingRef: ()=>isStreaming,
    clarifyModeRef: ()=>clarifyMode,
    setAbortCtrl: c=>abortCtrl=c,
    getAbortCtrl: ()=>abortCtrl,
    appendMessage,
    startStreaming,
    stopStreaming,
    appendDelta,
    flushDelta,
    scrollToBottom,
    refreshSendState,
    enterClarify,
    exitClarify,
    escapeHtml,
    autoResize,
    refreshOverlay,
    stripMarkdown,
    scheduleFlush,
    renderMarkdown,
    SESSION_STATE: window.SESSION_STATE,
    /*HISTORY_KEY,*/
    debug: DEBUG
  };
  DEBUG && console.log('[INIT] _MGPT keys:', Object.keys(_MGPT));

  /* ================== 上下文 & Payload ================== */
  function collectRecentUserQueries(latest) {
    try {
      const raw = localStorage.getItem(histKey(currentChatId));
      const arr = raw ? JSON.parse(raw) : [];
      const users = arr.filter(m=>m.role==='user').map(m=>m.content);
      if (latest) users.push(latest);
      return users.slice(-MAX_CTX_USER_QUERIES);
    } catch {
      return latest ? [latest] : [];
    }
  }
  function buildPayload(inputText) {
    const imgs = uploads.filter(u=>!u.uploading && u.url).map(u=>u.url);
    return {
      code,
      session_id: sessionId,
      lastUserQueries: collectRecentUserQueries(inputText),
      images: imgs,
      userRoles: window.USER_ROLES || [],
      industry: window.SELECTED_INDUSTRY || '',
      subIndustry: window.SELECTED_SUB_INDUSTRY || '',
      sessionState: {
        status: window.SESSION_STATE.status,
        lastClarifyQ: window.SESSION_STATE.lastClarifyQ,
        clarifyTimes: window.SESSION_STATE.clarifyTimes
      },
      debug: DEBUG
    };
  }

  /* ================== SSE 探测(可选) ================== */
  async function detectSSEOnce() {
    if (sseAvailable !== null) return sseAvailable;
    try {
      const r = await fetch(API_URL, {
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Accept':'text/event-stream' },
        body: JSON.stringify({ code:'__ping__', lastUserQueries:['ping'] })
      });
      if (/text\/event-stream/i.test(r.headers.get('Content-Type')||'')) sseAvailable='yes'; else sseAvailable='no';
    } catch { sseAvailable='no'; }
    return sseAvailable;
  }

  /* ================== 流请求 ================== */
  const MAX_BYTES_DISPLAY = 128000;

  // [PATCH-2] 安全 JSON 解析
  function safeJSON(str){
    if (!str) return null;
    try { return JSON.parse(str.replace(/^\uFEFF/,'')); }
    catch(e){ DEBUG && console.warn('[safeJSON:fail]', str.slice(0,160)); return null; }
  }

  function displayLargeUserInput(str, imgs){
    const enc = new TextEncoder();
    const bytes = enc.encode(str);
    if (bytes.length <= MAX_BYTES_DISPLAY) {
      appendMessage('user', str, { images: imgs });
      return;
    }
    let offset=0, part=0;
    while (offset < bytes.length) {
      const slice = bytes.slice(offset, offset+MAX_BYTES_DISPLAY);
      offset += MAX_BYTES_DISPLAY;
      const chunk = new TextDecoder().decode(slice);
      appendMessage('user', `[第 ${++part} 部分]\n${chunk}`);
    }
    if (imgs.length) appendMessage('user', '[图片]', { images: imgs });
  }

  async function streamRequest(payload) {
    if (USE_SSE === 'auto') {
      const ok = await detectSSEOnce();
      USE_SSE = (ok === 'yes');
      DEBUG && console.log('[SSE_DETECT]', ok);
    }
    const requestSSE = USE_SSE === true;

    const ctrl = new AbortController();
    abortCtrl = ctrl;
    let httpResp;

    let finalURL = API_URL + (DEBUG? '?debug=1':''); // [PATCH-6]
    if (code && AUTH_HEADER_MODE === 'none') {
      finalURL += (finalURL.includes('?')?'&':'?') + 'code=' + encodeURIComponent(code);
    }

    try {
      httpResp = await fetch(finalURL, {
        method:'POST',
        headers:(()=>{           // [PATCH-6]
          const h = { 'Content-Type':'application/json' };
          if (requestSSE) h['Accept']='text/event-stream';
          if (code) {
            if (AUTH_HEADER_MODE === 'authorization') h['Authorization']='Bearer '+code;
            else if (AUTH_HEADER_MODE === 'custom') h['x-auth-code']=code;
          }
          return h;
        })(),
        body: JSON.stringify(payload),
        signal: ctrl.signal
      });
      DEBUG && console.log('<< /admin-api/ws status', httpResp.status, [...httpResp.headers.entries()]);
    } catch(e) {
      appendMessage('bot', `⚠️ 网络错误：${e.message||e}`, {});
      stopStreaming();
      return;
    }
    if (!httpResp.ok || !httpResp.body) {
      appendMessage('bot', `⚠️ HTTP ${httpResp.status}`, {});
      stopStreaming();
      return;
    }

    const isSSE = /text\/event-stream/i.test(httpResp.headers.get('Content-Type')||'');
    DEBUG && console.log('[STREAM_MODE]', isSSE ? 'SSE':'NDJSON');

    startStreaming();

    const reader  = httpResp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream:true });
        DEBUG && console.log('[RAW_CHUNK_APPEND]', value.byteLength, 'accLen=', buffer.length);

        if (isSSE) {
          let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const block = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!block) continue;

              let eventName='message', dataStr='';
              block.split('\n').forEach(line=>{
                if (line.startsWith('event:')) eventName = line.replace(/^event:\s*/,'').trim();
                else if (line.startsWith('data:')) dataStr += line.replace(/^data:\s*/, '');
              });
              if (!dataStr) continue;
              let obj = safeJSON(dataStr);          // [PATCH-2]
              if(!obj) continue;
              DEBUG && console.log('[SSE_EVT]', eventName, obj);
              handleEvent(obj, eventName);
            }
        } else {
          let nl;
          while ((nl = buffer.indexOf('\n')) !== -1) {
            const rawLine = buffer.slice(0, nl);
            buffer = buffer.slice(nl+1);
            const line = rawLine.trim();
            if (!line) { DEBUG && console.log('[LINE_SKIP_EMPTY]'); continue; }
            DEBUG && console.log('[LINE_RAW]', rawLine);
            let obj = safeJSON(line);              // [PATCH-2]
            if(!obj) continue;
            DEBUG && console.log('[LINE_EVT]', obj.event, obj);
            handleEvent(obj, obj.event);
          }
        }
      }

      // 尾部兜底
      if (isStreaming && !gotDone) {
        const tail = buffer.trim();
        if (tail) {
          DEBUG && console.warn('[TAIL_LEFT]', tail.slice(0,160));
          try {
            let tailObj = null;
            if (isSSE) tailObj = safeJSON(tail);   // [PATCH-2]
            else tailObj = safeJSON(tail);
            if (tailObj && !tailObj.event) {
              if (tailObj.full) tailObj.event='done';
              else if (tailObj.text) tailObj.event='delta';
              else tailObj.event='error';
            }
            tailObj && handleEvent(tailObj, tailObj.event);
          } catch(e){
            DEBUG && console.warn('[TAIL_PARSE_FAIL]', e);
          }
        }
        if (!gotStart) {
          DEBUG && console.warn('[WARN] 未收到 start 事件');
        }
        flushDelta();
        finalizeAnswer(rawAnswerBuffer || deltaBuffer || '(无输出)');
      }

    } catch(e) {
      if (ctrl.signal.aborted) appendMessage('bot','⚠️ 已取消。');
      else appendMessage('bot','⚠️ 流中断：' + e.message);
    } finally {
      // [PATCH-4] 兜底 finalize
      if (isStreaming && !gotDone) {
        DEBUG && console.warn('[FALLBACK_FINALIZE]');
        flushDelta();
        finalizeAnswer(rawAnswerBuffer || deltaBuffer);
      }
      stopStreaming();
    }
  }

  /* ================== 事件处理 ================== */
  function handleEvent(evt, eventName){
    const type = eventName || evt.event;
    // [PATCH-3] 过期流丢弃
    if (streamingNode && streamingNode.dataset.streamToken !== CURRENT_STREAM_TOKEN) {
      DEBUG && console.log('[SKIP_OLD_STREAM_EVENT]', type);
      return;
    }
    DEBUG && console.debug('[EVT]', type, evt);

    switch (type) {
      case 'start':
        gotStart = true;
        if (!isStreaming) startStreaming();
        if (evt.model && streamingNode && !streamingNode.dataset.modelTag) {
          streamingNode.dataset.modelTag='1';
          streamingNode.insertAdjacentHTML('afterbegin',
            `<div class="model-tag">🧠 ${evt.model}</div>`);
        }
        break;
      case 'delta':
        if (!isStreaming) startStreaming();
        if (evt.text) {
          rawAnswerBuffer += evt.text;
          appendDelta(evt.text);
        }
        break;
      case 'done':
        gotDone = true;
        if (evt.full) rawAnswerBuffer = evt.full;
        flushDelta();
        finalizeAnswer(rawAnswerBuffer, evt.usage);
        break;
      case 'clarify':
        flushDelta(); stopStreaming();
        evt.text && enterClarify(evt.text);
        break;
      case 'error':
        flushDelta(); stopStreaming();
        appendMessage('bot', `⚠️ 出错：${evt.text || 'Unknown error'}`);
        break;
      case 'debug':
        logDebug(evt);
        break;
      default:
        DEBUG && console.debug('[EVT_UNKNOWN]', evt);
    }
  }

  function logDebug(evt){
    let panel = document.getElementById('debugPanel');
    if (!panel) {
      panel = document.createElement('pre');
      panel.id='debugPanel';
      panel.style.cssText='position:fixed;right:6px;bottom:6px;max-width:420px;max-height:220px;overflow:auto;background:#111;color:#0f0;padding:6px;font:11px/1.4 monospace;z-index:9999;opacity:.85;';
      panel.textContent='[DEBUG PANEL]\n';
      document.body.appendChild(panel);
    }
    panel.textContent += `[${evt.tag||'debug'}] ${evt.text||JSON.stringify(evt)}\n`;
  }

  function finalizeAnswer(full='', usage){
    // [PATCH-3] finalize 校验
    if (streamingNode && streamingNode.dataset.streamToken !== CURRENT_STREAM_TOKEN) {
      DEBUG && console.log('[FINALIZE_SKIP_OLD]');
      return;
    }
    DEBUG && console.log('[STREAM] finalizeAnswer fullLen=', full.length,'deltaLen=', deltaBuffer.length);
    stopStreaming();
   if (!streamingNode) {
      // 占位未成功创建时兜底
     streamingNode = document.createElement('div');
     streamingNode.className='msg bot';
     chat && chat.appendChild(streamingNode);
     }
    /**-}--*/
    const finalText = full || deltaBuffer || '(空回答)';
    safeRemoveStreamingClass(streamingNode); // [PATCH-1]
    try {
      streamingNode.innerHTML = marked.parse(finalText);
       } catch(e){
      DEBUG && console.warn('[finalize:innerHTML-fail]', e);
       streamingNode.textContent = finalText;
      }
    if (usage && (usage.prompt || usage.completion)) {
      const meta = document.createElement('div');
      meta.className='usage';
      const total=(usage.prompt||0)+(usage.completion||0);
      meta.textContent=`🔢 Tokens P:${usage.prompt||0} C:${usage.completion||0} T:${total}`;
      streamingNode.appendChild(meta);
    }
    addCopyButton(streamingNode, stripMarkdown(finalText)); // [PATCH-7]
    lastFullAnswer = finalText;
    exitClarify();
  }

  function addCopyButton(node, rawText) {
    // [PATCH-7] finalize 时调用；已存在则不重复
    if (node.querySelector('.copy-btn')) return;
    const btn = document.createElement('button');
    btn.className='copy-btn'; btn.textContent='⧉'; btn.title='复制';
    btn.onclick = ()=>{
      navigator.clipboard.writeText(rawText);
      btn.textContent='✔'; setTimeout(()=>btn.textContent='⧉',1200);
    };
    node.appendChild(btn);
  }

  function abortStreaming(){
    if (abortCtrl) {
      abortCtrl.abort();
      // [PATCH-8] 若已有部分文本，直接 finalize 而非追加一条“停止”消息
      if (isStreaming) {
        flushDelta();
        finalizeAnswer(rawAnswerBuffer || deltaBuffer || '(已停止，无内容)');
      } else {
        appendMessage('bot','⏹ 已手动停止。');
      }
      stopStreaming();
    }
  }

  /* ================== 发送 ================== */
  function uploadsReadyURLs(){ return uploads.filter(u=>!u.uploading && u.url).map(u=>u.url); }
  function clearUploads(){
    uploads.forEach(u=>u.node && u.node.remove());
    uploads = [];
  }

  async function trySend(){
    if (!checkAuthOrWarn()) return;
    if (anyUploading()) return;
    if (!txt) return;
    const inputText = txt.value.trim();
    const images = uploadsReadyURLs();
    if (!inputText && !images.length) return;

    // [PATCH-5] Clarify 模式下允许补充；若仍为空则返回
    if (clarifyMode) {
      if (!inputText && !images.length) return;
      exitClarify();
    }

    // [PATCH-3] 新流 token
    CURRENT_STREAM_TOKEN = 'st_' + Date.now() + '_' + Math.random().toString(16).slice(2);

    if (firstMessage) {
      firstMessage = false;
      document.body.style.overflow = 'auto';
      welcome && welcome.remove();
    }

    
    displayLargeUserInput(inputText, images);
/* 以下保持原来的自动命名逻辑（你的旧代码已有） */
     if (chats.find(c => c.id === currentChatId)?.title === '新聊天') {
       const pretty = stripMarkdown(inputText).slice(0, 20) || '未命名会话';
        chats = chats.map(c =>
           c.id === currentChatId ? { ...c, title: pretty } : c
           );
        saveChats();
renderChats(searchInput.value);
        }
    txt.value=''; autoResize(); clearUploads();
    refreshSendState();

    const payload = buildPayload(inputText);
    DEBUG && console.log('>> /admin-api/ws payload', payload);
    streamRequest(payload);
  }

  /* ================== 事件绑定 ================== */
  sendBtn?.addEventListener('click', ()=>{
    if (isStreaming && !clarifyMode) abortStreaming();
    else trySend();
  });
  txt?.addEventListener('keydown', e=>{
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      trySend();
    }
  });
  function updateSendButtonLabel() {
    if (!sendBtn) return;
    if (isStreaming && !clarifyMode) sendBtn.title='终止本次回答';
    else if (clarifyMode) sendBtn.title='发送澄清补充';
    else sendBtn.title='发送';
  }
  setInterval(updateSendButtonLabel, 500);
  window.addEventListener('beforeunload', e=>{
    if (isStreaming) { e.preventDefault(); e.returnValue=''; }
  });
  window.demoAsk = q=>{
    if (!txt) return;
    txt.value=q; autoResize(); refreshSendState(); trySend();
  };

  /* ================== 诊断工具 ================== */
  window.MGPT_TEST_DIAG = async () => {
    try {
      const r = await fetch(BASE + '/diag').then(r=>r.json());
      appendMessage('bot', '诊断结果:\n```json\n'+JSON.stringify(r,null,2)+'\n```');
    } catch(e){
      appendMessage('bot', '诊断失败: '+e.message);
    }
  };

  /* ================== 初始化顺序 ================== */
  autoResize();
  refreshOverlay();
  refreshSendState();
  toggleArrow();
  initAuth();
 

// —— Sidebar 数据 & 渲染逻辑 —— 
const STORAGE_KEY = 'mini_gpt_chats';               // [{id,title,sessionId}]
let chats          = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
  // —— 迁移老版只有一个历史桶到新目录 —— 
  const oldRaw = localStorage.getItem(HISTORY_KEY_STATIC);
  if (!chats.length && oldRaw) {
    chats = [{ id: sessionId, title: '历史会话', sessionId }];
    localStorage.setItem(STORAGE_KEY, JSON.stringify(chats));
     }
let currentChatId  = chats[0]?.id            || null;       // 当前激活
 sessionId          = chats[0]?.sessionId     // ← 这里 **不再用 let**，而是复用上面同名变量
       || crypto.randomUUID();      // （开头已声明过）
// —— 目录和 currentChatId 都准备好了，真正加载历史 —— 
loadHistory();
  
/* 保存左栏目录 */
function saveChats() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(chats));
}

/* ---------- 渲染 / 切换 ---------- */
const chatListEl  = document.getElementById('chatList');
const searchInput = document.getElementById('chatSearch');
const btnNewChat  = document.getElementById('btnNewChat');

function renderChats(filter = '') {
  chatListEl.innerHTML = '';
  chats
    .filter(c => c.title.includes(filter))
    .forEach(c => {
      const html = `
        <div class="chat-item${c.id === currentChatId ? ' active' : ''}" data-id="${c.id}">
          <span class="title">${c.title}</span>
          <button class="menu dots">⋮</button>
          <div class="pop">
            <button class="rename">重命名</button>
            <button class="del del-btn">删除</button>
          </div>
        </div>`;
      chatListEl.insertAdjacentHTML('beforeend', html);
    });
}


/* 把聊天区消息渲染出来 */
function loadHistoryToPane(id) {
  chat.innerHTML = '';                            // 清空右侧
  const raw = localStorage.getItem(histKey(id));
  if (!raw) return;

  try {
    JSON.parse(raw).forEach(m =>
      appendMessage(m.role, m.content, { noSave:true, meta:m.meta })
    );
  } catch { /* ignore */ }
  scrollToBottom(true);
}
// === 工具：面板是否已有消息 ===
/* === 工具：面板是否已有消息 === */
function paneHasContent () {
  return !!chat.querySelector('.msg');
}

/* === 把当前面板写入 localStorage，并自动命名 === */
function persistCurrentPane () {
  if (!currentChatId) return;
  if (!paneHasContent()) return;                // 空面板不保存

  const holder = [];
  chat.querySelectorAll('.msg').forEach(node => {
    // 1) 克隆一份 DOM，用来剥离按钮
    const clone = node.cloneNode(true);
    clone.querySelectorAll('.copy-btn, .actions').forEach(el => el.remove());
    // 2) 读取纯文本，不含按钮符号
    const text = clone.innerText.trim();

    const role = node.classList.contains('user') ? 'user' : 'bot';
    holder.push({ role, content: text, ts: Date.now() });
  });
  localStorage.setItem(histKey(currentChatId), JSON.stringify(holder));

  // —— 原来的自动命名逻辑保持不变 —— 
  const chatObj = chats.find(c => c.id === currentChatId);
  if (chatObj && chatObj.title === '新聊天') {
    const firstUser = holder.find(m => m.role === 'user');
    chatObj.title = firstUser
      ? stripMarkdown(firstUser.content).slice(0, 20) || '未命名会话'
      : '未命名会话';
    saveChats();
    renderChats(searchInput.value);
  }
}


/* === 把聊天区消息渲染出来 === */
function loadHistoryToPane (id) {
  chat.innerHTML = '';
  const raw = localStorage.getItem(histKey(id));
  if (!raw) return;
  try {
    JSON.parse(raw).forEach(m =>
      appendMessage(m.role, m.content, { noSave: true, meta: m.meta })
    );
  } catch { /* ignore */ }
  scrollToBottom(true);
}




/* === 进入某条聊天 === */
function activateChat (id) {
  if (currentChatId) persistCurrentPane();        // 先保存上一个

  currentChatId = id;
  const chatObj = chats.find(c => c.id === id);
  if (chatObj) sessionId = chatObj.sessionId;     // 提供给后端
  renderChats(searchInput.value);
  loadHistoryToPane(id);
  // 只有用户已授权且面板有内容，才移除欢迎
 if (paneHasContent() && isAuthorized) welcome?.remove();
  }

/* 新建聊天（核心） */
// —— 新建聊天按钮逻辑 —— 
// —— 新建聊天 —— 
btnNewChat.addEventListener('click', () => {
// —— 如果目录里已有一个“新聊天”且从没写过内容，复用它 —— 
 const empty = chats.find(c =>
 c.title === '新聊天' &&
!localStorage.getItem(histKey(c.id))
);
 if (empty) {
activateChat(empty.id);
 return;
 }

// 目录里没有可复用的“空白”时，再走原逻辑：
 if (paneHasContent()) {
 const id  = crypto.randomUUID();
const sid = crypto.randomUUID();
chats.unshift({ id, title: '新聊天', sessionId: sid });
saveChats();
activateChat(id);
} else {
const id  = crypto.randomUUID();
 const sid = crypto.randomUUID();
currentChatId = id;
sessionId     = sid;
renderChats(searchInput.value);
chat.innerHTML = '';
firstMessage = true;
/*welcome?.remove()*/
autoResize();
refreshSendState();
}
  searchInput.value = '';
});


// —— 侧边栏点击 —— 
chatListEl.addEventListener('click', e => {
  if (!isAuthorized) return;
  const item = e.target.closest('.chat-item');
  if (!item) return;

  // 1) 三点菜单
  if (e.target.classList.contains('menu')) {
    const pop = item.querySelector('.pop');
    document.querySelectorAll('.pop.show')
      .forEach(p => p !== pop && p.classList.remove('show'));
    pop.classList.toggle('show');
    return;
  }

  // 2) 重命名
  if (e.target.classList.contains('rename')) {
    const id = item.dataset.id;
    const oldTitle = chats.find(c => c.id === id).title;
    const newTitle = prompt('重命名聊天', oldTitle);
    if (newTitle !== null) {
      chats = chats.map(c =>
        c.id === id
          ? { ...c, title: newTitle.trim() || '未命名会话' }
          : c
      );
      saveChats();
      renderChats(searchInput.value);
    }
    return;
  }

  // 3) 删除
  if (e.target.classList.contains('del-btn')) {
    const id = item.dataset.id;
    if (confirm('确认删除？')) {
      chats = chats.filter(c => c.id !== id);
      localStorage.removeItem(histKey(id));
      saveChats();
      renderChats(searchInput.value);
      // 如果删的是当前会话，自动切到第一条或新建
      if (id === currentChatId) {
        chats[0] ? activateChat(chats[0].id) : btnNewChat.click();
      }
    }
    return;
  }

  // 4) 普通点击：切换会话
  activateChat(item.dataset.id);
});


/* =========== 把 trySend / saveMessage 改成用当前 chatId =========== */
// 只需把它们内部对 `HISTORY_KEY` 的引用换成 histKey(currentChatId)
// 例：localStorage.getItem(HISTORY_KEY)  →  localStorage.getItem(histKey(currentChatId))
//     localStorage.setItem(HISTORY_KEY, …) → localStorage.setItem(histKey(currentChatId), …)

/* 首次加载 */
if (!currentChatId) btnNewChat.click();          // 首进页面自动起一条
else               activateChat(currentChatId);

// —— 响应式汉堡 & 遮罩 —— 
// —— 响应式汉堡 & 遮罩 —— 
const hamburger = document.getElementById('hamburger');
const sidebar   = document.getElementById('sidebar');
const overlay   = document.getElementById('sidebarOverlay');

hamburger.addEventListener('click', () => {
  // 给 body 打上/去掉 slide‑right  
  document.body.classList.toggle('slide-right');
  // 同时展开/收起侧栏和遮罩
  sidebar.classList.toggle('show');
  overlay.classList.toggle('show');
});

overlay.addEventListener('click', () => {
  // 关闭时，去掉 slide‑right，并隐藏侧栏和遮罩
  document.body.classList.remove('slide-right');
  sidebar.classList.remove('show');
  overlay.classList.remove('show');
});


// —— 搜索模态相关 DOM 引用 —— 
const searchModal     = document.getElementById('searchModal');
const modalInput      = document.getElementById('modalSearchInput');
const modalCloseBtn   = document.getElementById('modalCloseBtn');
const modalResults    = document.getElementById('modalResults');
const sideSearchInput = document.getElementById('chatSearch');

// 打开搜索面板
function openSearchModal() {
  // 清空、聚焦
  modalInput.value = '';
  renderModalResults(chats);
  searchModal.style.display = 'flex';
  modalInput.focus();
}

// 关闭搜索面板
function closeSearchModal() {
  searchModal.style.display = 'none';
  sideSearchInput.blur();
}

// 根据 filter 渲染结果列表
function renderModalResults(list) {
  // 按“今天/昨天/更早”简单分组
  const today      = new Date().toDateString();
  const yesterday  = new Date(Date.now() - 864e5).toDateString();
  const groups     = { today: [], yesterday: [], older: [] };
  list.forEach(c => {
    // 这里假设我们有 chats 的 title 和 sessionId，渲染标题即可
    // 若要显示最后消息时间，可在 chats 对象中另外存 timestamp
    const created = new Date(localStorage.getItem(`chat_created_${c.id}`) || 0).toDateString();
    if (created === today)      groups.today.push(c);
    else if (created === yesterday) groups.yesterday.push(c);
    else                         groups.older.push(c);
  });

  modalResults.innerHTML = '';
  Object.entries(groups).forEach(([key, arr]) => {
    if (!arr.length) return;
    const titleMap = { today: '今天', yesterday: '昨天', older: '更早' };
    const h = document.createElement('div');
    h.className = 'group-title';
    h.textContent = titleMap[key];
    modalResults.appendChild(h);
    arr.forEach(c => {
      const it = document.createElement('div');
      it.className = 'item';
      it.dataset.id = c.id;
      it.innerHTML = `
        <span class="icon">💬</span>
        <span class="title">${c.title}</span>
      `;
      it.addEventListener('click', ()=> {
        activateChat(c.id);
        closeSearchModal();
      });
      modalResults.appendChild(it);
    });
  });
}

// 侧栏搜索框点击/聚焦时打开模态
sideSearchInput.addEventListener('focus', openSearchModal);
sideSearchInput.addEventListener('click', openSearchModal);

// 模态内实时过滤
modalInput.addEventListener('input', e => {
  const kw = e.target.value.trim().toLowerCase();
  const filtered = chats.filter(c => c.title.toLowerCase().includes(kw));
  renderModalResults(filtered);
});

// 关闭按钮 & 点击遮罩以外区域关闭
modalCloseBtn.addEventListener('click', closeSearchModal);
searchModal.addEventListener('click', e => {
  if (e.target === searchModal) closeSearchModal();
});

// 首次渲染
renderChats();

}); // DOMContentLoaded

} // 版本保护 end

</script>








</body>
</html>
