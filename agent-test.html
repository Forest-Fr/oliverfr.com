<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Agent Worker 测试面板</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  connect-src 'self' https://agent.mefans.workers.dev https://*.run.app;
  img-src 'self' data:;
  style-src 'self' 'unsafe-inline';
  script-src 'self' 'unsafe-inline';
  font-src 'self' data:;
  base-uri 'self';
  form-action 'self';
">

  
<style>
  :root {
    --bg-page: #edf2ff;
    --bg-card: #ffffff;
    --bg-card-soft: #f5f7ff;
    --border-subtle: #e2e8ff;
    --border-strong: #c7d2fe;
    --text-main: #111827;
    --text-sub: #6b7280;
    --text-mute: #9ca3af;
    --accent: #4f46e5;
    --accent-soft: rgba(79, 70, 229, 0.1);
    --accent-strong: #3730a3;
    --danger: #ef4444;
    --radius-lg: 18px;
    --radius-md: 10px;
    --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.14);
    --shadow-subtle: 0 8px 20px rgba(15, 23, 42, 0.12);
    --sidebar-width: 280px;
    --insight-width: 320px;
  }

  * {
    box-sizing: border-box;
  }

  html,
  body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "Segoe UI", sans-serif;
    background: radial-gradient(circle at top, #e0e7ff 0, #eef2ff 55%, #e5e7eb 100%);
    color: var(--text-main);
  }

  body {
    display: flex;
    justify-content: center;
    align-items: stretch; /* 保持整体壳子撑满高度，不再出现“中间一个窄柱子” */
    padding: 20px;
  }

  .app-shell {
    display: flex;
    flex-direction: row;
    width: min(1320px, 100%);
    height: 100%;
    max-height: 880px;
    background: linear-gradient(145deg, #f9fafb, #eef2ff);
    border-radius: 26px;
    box-shadow: var(--shadow-soft);
    overflow: hidden;
    border: 1px solid rgba(148, 163, 184, 0.45);
    position: relative;
  }

  /* 左侧：会话列表 */

  .sidebar {
    width: var(--sidebar-width);
    background: radial-gradient(circle at top left, #1e293b 0, #020617 60%);
    color: #e5e7eb;
    padding: 18px 18px 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    border-right: 1px solid rgba(148, 163, 184, 0.3);
    position: relative;
    z-index: 1;
  }

  .sidebar-header {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .sidebar-title-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-title {
    font-weight: 700;
    font-size: 18px;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-dot {
    width: 9px;
    height: 9px;
    border-radius: 999px;
    background: #22c55e;
    box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.35);
  }

  .sidebar-subtitle {
    font-size: 12px;
    color: #9ca3af;
  }

  .sidebar-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
  }

  .tag-chip {
    font-size: 11px;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.65);
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: radial-gradient(circle at top, rgba(148, 163, 184, 0.26), transparent);
  }

  .tag-chip strong {
    font-weight: 600;
  }

  .sidebar-divider {
    height: 1px;
    background: linear-gradient(to right, rgba(148, 163, 184, 0.5), transparent);
    margin-top: 6px;
  }

  .sidebar-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 4px;
  }

  .btn-new-session {
    border: none;
    border-radius: 999px;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: #f9fafb;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, background 0.1s ease-out;
  }

  .btn-new-session:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 24px rgba(79, 70, 229, 0.6);
    background: linear-gradient(135deg, #4338ca, #4f46e5);
  }

  .btn-new-session:active {
    transform: translateY(0);
    box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6);
  }

  .btn-icon {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.4);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }

  .sidebar-env {
    font-size: 11px;
    color: #9ca3af;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px dashed rgba(148, 163, 184, 0.8);
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: rgba(15, 23, 42, 0.45);
  }

  .sidebar-env-dot {
    width: 5px;
    height: 5px;
    border-radius: 999px;
    background: #22c55e;
  }

  .session-list {
    flex: 1;
    margin-top: 4px;
    padding-top: 4px;
    overflow: hidden auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .session-item {
    position: relative;
    border-radius: 12px;
    padding: 8px 9px;
    cursor: pointer;
    border: 1px solid transparent;
    background: rgba(15, 23, 42, 0.45);
    display: flex;
    flex-direction: column;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .session-item:hover {
    background: rgba(15, 23, 42, 0.7);
    border-color: rgba(148, 163, 184, 0.7);
  }

  .session-item.active {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.6), rgba(37, 99, 235, 0.6));
    border-color: #c7d2fe;
    transform: translateX(2px);
  }

  .session-header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 4px;
  }

  .session-header-left {
    display: flex;
    align-items: center;
    gap: 4px;
    flex: 1;
    min-width: 0;
  }

  .session-title {
    font-size: 13px;
    font-weight: 500;
    color: #e5e7eb;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    max-width: 160px;
  }

  .btn-rename-session {
    border: none;
    background: transparent;
    color: #9ca3af;
    font-size: 11px;
    padding: 0;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.08s ease-out, color 0.08s ease-out;
  }

  .session-item:hover .btn-rename-session {
    opacity: 1;
  }

  .btn-rename-session:hover {
    color: #e5e7eb;
  }

  .session-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
  }

  .session-tokens {
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.8);
    border: 1px solid rgba(148, 163, 184, 0.7);
    font-size: 10px;
  }

  .btn-delete-session {
    border: none;
    background: transparent;
    color: #9ca3af;
    font-size: 13px;
    padding: 0 0 0 4px;
    cursor: pointer;
    opacity: 0.0;
    transition: opacity 0.08s ease-out, color 0.08s ease-out;
  }

  .session-item:hover .btn-delete-session {
    opacity: 1;
  }

  .btn-delete-session:hover {
    color: #fecaca;
  }

  .sidebar-footer {
    margin-top: 6px;
    font-size: 11px;
    color: #6b7280;
  }

  /* 中间：聊天面板 */

  .main-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px 18px 14px;
    gap: 10px;
    position: relative;
    z-index: 0;
    align-items: stretch;        /* 关键：中间列所有子元素撑满宽度 */
    justify-content: flex-start; /* 关键：从顶部开始排布，不再“居中悬空” */
  }

  .main-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .main-header-left {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .breadcrumbs {
    font-size: 11px;
    color: var(--text-mute);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .breadcrumbs span {
    display: inline-flex;
    align-items: center;
  }

  .agent-title-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .agent-name {
    font-size: 18px;
    font-weight: 700;
  }

  .pill {
    font-size: 11px;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border-strong);
    background: var(--bg-card-soft);
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .main-header-right {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
    flex-wrap: wrap; /* 宽度不够就换行 */
  }

  .env-pill {
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px dashed #d4d4ff;
    background: rgba(219, 234, 254, 0.6);
    color: #1d4ed8;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-weight: 500;
  }

  .env-pill-dot {
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: #22c55e;
  }

  /* ===== PATCH INSERT · Agent / Env 选择器（Step 4.1） ===== */

  /* 环境 pill 保持紧凑，不被挤压 */
  .main-header-right .env-pill {
    flex-shrink: 0;
  }

  /* 下拉控件容器：一行排 label + select，本身可折行 */
  .agent-env-controls {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
    flex-wrap: wrap; /* label/select 自己也可以换行 */
  }

  .agent-env-controls label {
    opacity: 0.8;
    white-space: nowrap; /* 避免 “Call:” 被打断 */
  }

  .agent-env-select {
    border-radius: 999px;
    border: 1px solid var(--border-subtle);
    background: var(--bg-card-soft);
    padding: 2px 8px;
    font-size: 11px;
    color: var(--text-main);
    outline: none;
    flex-shrink: 0; /* 不要被挤得太窄 */
    max-width: 120px; /* 防止撑爆右边空间 */
  }

  .agent-env-select:disabled {
    opacity: 0.55;
    cursor: default;
  }

  .agent-env-select option {
    font-size: 11px;
  }

  /* Trace 折叠块：占满一行，放在 header 下方，不影响主布局 */
  .agent-trace-summary {
    margin-top: 4px;
    padding: 6px 8px;
    border-radius: 10px;
    background: rgba(37, 99, 235, 0.04);
    border: 1px dashed rgba(129, 140, 248, 0.6);
    font-size: 11px;
    color: var(--text-sub);
    cursor: pointer;
  }

  .agent-trace-summary strong {
    color: var(--accent-strong);
  }

  .agent-trace-detail {
    margin-top: 4px;
    padding: 6px 8px;
    border-radius: 8px;
    background: rgba(15, 23, 42, 0.03);
    border: 1px solid rgba(148, 163, 184, 0.4);
    font-size: 11px;
    color: var(--text-sub);
    display: none;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .agent-trace-detail.open {
    display: block;
  }

  /* 手机端：右上这一块占满一行，不挤压标题 */
  @media (max-width: 900px) {
    .main-header-right {
      width: 100%;
      justify-content: flex-start;
      align-items: flex-start;
      gap: 4px;
    }

    .agent-env-controls {
      width: 100%;
    }

    .agent-env-select {
      max-width: 100px;
    }
  }

  .chat-surface {
    flex: 1;
    border-radius: 18px;
    background: radial-gradient(circle at top left, #eef2ff 0, #f9fafb 55%);
    border: 1px solid var(--border-subtle);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.08);
    width: 100%;          /* 关键：填满中间列宽度 */
    align-self: stretch;   /* 关键：不再缩成右侧一根“细条” */
  }

  .chat-messages {
    flex: 1;
    padding: 16px 18px 12px;
    overflow: auto;
    scroll-behavior: smooth;
  }

  .chat-empty {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    color: var(--text-mute);
    text-align: center;
    font-size: 13px;
  }

  .chat-message {
    max-width: 80%;
    padding: 10px 12px;
    border-radius: 14px;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .chat-message.user {
    margin-left: auto;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    border-bottom-right-radius: 4px;
    box-shadow: 0 10px 22px rgba(79, 70, 229, 0.35);
  }

  .chat-message.assistant {
    margin-right: auto;
    background: rgba(255, 255, 255, 0.95);
    border-bottom-left-radius: 4px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
  }

  .chat-input-bar {
    border-top: 1px solid var(--border-subtle);
    padding: 10px 12px;
    background: linear-gradient(to top, rgba(249, 250, 251, 0.94), rgba(249, 250, 251, 0.9));
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;          /* 关键：输入区也铺满宽度 */
    align-self: stretch;
  }

  .chat-input-row {
    display: flex;
    gap: 8px;
    align-items: flex-end;
  }

  .chat-input {
    flex: 1;
    border-radius: 12px;
    border: 1px solid var(--border-subtle);
    padding: 8px 10px;
    resize: none;
    min-height: 42px;
    max-height: 96px;
    font-size: 14px;
    line-height: 1.4;
    outline: none;
    background: rgba(255, 255, 255, 0.96);
  }

  .chat-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.3);
  }

  .send-button {
    border: none;
    border-radius: 999px;
    padding: 9px 18px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    box-shadow: 0 10px 24px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s ease-out;
  }

  .send-button:hover:not([disabled]) {
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(79, 70, 229, 0.6);
  }

  .send-button:active:not([disabled]) {
    transform: translateY(0);
    box-shadow: 0 6px 14px rgba(31, 41, 55, 0.55);
  }

  .send-button[disabled] {
    opacity: 0.65;
    cursor: default;
    box-shadow: 0 4px 10px rgba(148, 163, 184, 0.6);
  }

  .send-button-icon {
    font-size: 14px;
    background: rgba(15, 23, 42, 0.3);
    border-radius: 999px;
    padding: 4px;
    display: inline-flex;
  }

  .input-hint-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-mute);
  }

  .input-hint-row strong {
    color: var(--text-sub);
  }

  /* 右侧：调用概览 & 原始 JSON */

  .insight-panel {
    width: var(--insight-width);
    padding: 14px 14px 12px;
    border-left: 1px solid rgba(148, 163, 184, 0.4);
    background: linear-gradient(160deg, rgba(15, 23, 42, 0.98), #020617);
    color: #e5e7eb;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .insight-card {
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    padding: 10px 11px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.8);
  }

  .insight-card h3 {
    margin: 0 0 6px;
    font-size: 13px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .insight-tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(37, 99, 235, 0.25);
    border: 1px solid rgba(129, 140, 248, 0.7);
  }

  .call-overview-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    margin-bottom: 2px;
    color: #9ca3af;
  }

  .call-overview-row span:last-child {
    color: #e5e7eb;
  }

  .call-overview-row strong {
    color: #e5e7eb;
  }

  .call-status-pill {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid rgba(52, 211, 153, 0.8);
    background: rgba(5, 150, 105, 0.2);
    color: #bbf7d0;
  }

  .call-status-pill.error {
    border-color: rgba(248, 113, 113, 0.9);
    background: rgba(127, 29, 29, 0.85);
    color: #fecaca;
  }

  .call-status-dot {
    width: 6px;
    height: 6px;
    border-radius: 999px;
    background: #22c55e;
  }

  .call-status-pill.error .call-status-dot {
    background: #f97373;
  }

  .raw-json-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
    margin-bottom: 6px;
  }

  .json-buttons {
    display: flex;
    gap: 6px;
  }

  .btn-ghost {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.7);
    font-size: 11px;
    padding: 3px 8px;
    color: #e5e7eb;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .btn-ghost:hover {
    background: rgba(15, 23, 42, 0.95);
    border-color: rgba(251, 191, 36, 0.85);
    transform: translateY(-0.5px);
  }

  .btn-ghost:active {
    transform: translateY(0);
  }

  .raw-json-body {
    position: relative;
    border-radius: 10px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    background: radial-gradient(circle at top left, rgba(17, 24, 39, 0.9), #020617);
    padding: 8px 9px;
    max-height: 160px;
    overflow: hidden;
    transition: max-height 0.18s ease-out;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
      "Courier New", monospace;
    font-size: 11px;
    color: #e5e7eb;
  }

  .raw-json-body.open {
    max-height: 260px;
    overflow: auto;
  }

  .raw-json-placeholder {
    color: #6b7280;
    font-size: 11px;
  }

  .raw-json-pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .agent-desc-list {
    list-style: none;
    padding-left: 0;
    margin: 6px 0 0;
    font-size: 11px;
    color: #9ca3af;
  }

  .agent-desc-list li {
    margin-bottom: 4px;
    display: flex;
    gap: 4px;
  }

  .agent-desc-list li span {
    color: #e5e7eb;
  }

  /* toast */

  .toast {
    position: absolute;
    right: 24px;
    bottom: 22px;
    z-index: 40;
    padding: 8px 11px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.92);
    color: #f9fafb;
    font-size: 12px;
    display: none;
    align-items: center;
    gap: 8px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(248, 250, 252, 0.22);
  }

  .toast.visible {
    display: inline-flex;
  }

  .toast-icon {
    font-size: 14px;
  }

  /* 顶部移动端按钮 & 遮罩，桌面端默认隐藏 */

  .mobile-top-bar {
    display: none;
  }

  .mobile-overlay {
    display: none;
  }

  @media (max-width: 1120px) {
    /* 中屏默认隐藏右侧面板（移动端另外覆盖） */
    .insight-panel {
      display: none;
    }
  }

  /* === 手机端布局 === */
  @media (max-width: 900px) {
    body {
      padding: 0;
    }

    .app-shell {
      border-radius: 0;
      box-shadow: none;
      max-height: none;
      height: 100%;
      overflow: hidden; /* 防止左右推时露出太大的空白 */
    }

    /* 主聊天面板：手机端左右平移 */
    .main-panel {
      padding-top: 46px; /* 给顶部两横线留空间 */
      transition: transform 0.2s ease-out;
    }

    /* 左边抽屉打开时，主面板向右推 */
    .main-panel.move-right,
    .app-shell.push-right .main-panel {
      transform: translateX(min(80%, 320px));
    }

    /* 右边抽屉打开时，主面板向左推 */
    .main-panel.move-left,
    .app-shell.push-left .main-panel {
      transform: translateX(-min(80%, 340px));
    }

    /* 顶部左右“二横线”按钮条 */
    .mobile-top-bar {
      position: fixed;
      top: 10px;
      left: 0;
      right: 0;
      padding: 0 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 40;
      pointer-events: none;
      transition: transform 0.2s ease-out;
    }

    /* 顶部两横线跟随整体移动 */
    .app-shell.push-right .mobile-top-bar {
      transform: translateX(min(80%, 320px));
    }

    .app-shell.push-left .mobile-top-bar {
      transform: translateX(-min(80%, 340px));
    }

    .mobile-toggle-btn {
      width: 34px;
      height: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      border: none;
      background: transparent;
      padding: 0;
      margin: 0;
    }

    .mobile-toggle-icon {
      position: relative;
      width: 18px;
      height: 14px;
    }

    .mobile-toggle-icon span {
      position: absolute;
      height: 2px;
      border-radius: 999px;
      background: #111827;
    }

    /* 左侧图标：两条线偏左 */
    .mobile-toggle-btn-left .mobile-toggle-icon span:nth-child(1) {
      top: 2px;
      left: 0;
      right: 8px;
    }

    .mobile-toggle-btn-left .mobile-toggle-icon span:nth-child(2) {
      bottom: 2px;
      left: 0;
      right: 3px;
    }

    /* 右侧图标：两条线偏右（镜像） */
    .mobile-toggle-btn-right .mobile-toggle-icon span:nth-child(1) {
      top: 2px;
      left: 8px;
      right: 0;
    }

    .mobile-toggle-btn-right .mobile-toggle-icon span:nth-child(2) {
      bottom: 2px;
      left: 3px;
      right: 0;
    }

    /* 遮罩层：在主界面和抽屉之间 */
    .mobile-overlay {
      display: block;
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      z-index: 25;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease-out;
    }

    .mobile-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* 左侧 sidebar 抽屉（固定在视口左边，不随主界面一起移动） */
    .sidebar {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: min(80%, 320px);
      max-width: 320px;
      transform: translateX(-100%);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      z-index: 30;
    }

    .sidebar.sidebar-open {
      transform: translateX(0);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.88);
    }

    /* 右侧 insight 抽屉（固定在视口右边） */
    .insight-panel {
      display: flex;
      position: fixed;
      top: 0;
      bottom: 0;
      right: 0;
      width: min(80%, 340px);
      max-width: 340px;
      transform: translateX(100%);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      z-index: 30;
    }

    .insight-panel.insight-open {
      transform: translateX(0);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.88);
    }
  }
</style>


  <style>
  /* ===== PATCH: 中间主区域固定在 TOP，聊天区填满剩余高度 ===== */

  /* 1）主面板：占满中间区域高度，并强制从顶部开始排布 */
  .main-panel {
    height: 100% !important;
    min-height: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: flex-start !important;  /* 标题永远贴着中间区域 top */
    align-items: stretch !important;
  }

  /* 2）聊天卡片：紧跟标题，从上往下填满剩余空间 */
  .chat-surface {
    flex: 1 1 auto !important;               /* 占满 main-panel 余下高度 */
    min-height: 0 !important;
    margin-top: 8px !important;              /* 和标题留一点间距 */
    display: flex !important;
    flex-direction: column !important;
  }

  /* 3）消息区域：在卡片内部撑开，确保下面输入区始终可见 */
  .chat-messages {
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: auto !important;
  }

  /* 4）空状态：不再额外拉长整个中间区域，只在消息区域里居中 */
  .chat-empty {
    height: auto !important;
    flex: 1 1 auto !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }
  /* ===== PATCH END ===== */
</style>

  
<!-- =================
     无损补丁：追加覆盖（Option B） — 保留原始样式不变，仅通过覆盖规则确保 token 徽章不被裁切
     ================= -->
<style>
  /* ===== PATCH BEGIN: session-title / token badge safe spacing (无损覆盖) ===== */

  /* 1) session-item：保留原始 padding（8px 9px），但在补丁中用更精确的 padding & overflow 覆盖以避免徽章溢出 */
  .session-item {
    /* 原始（仅作记录，未删除）： padding: 8px 9px; */
    padding: 8px 8px 8px 9px !important;
    overflow: hidden !important; /* 防止子元素（徽章）在视觉上溢出容器边界 */
    box-sizing: border-box !important;
  }

  /* 2) session-title：不改 DOM，动态限制标题宽度，给时间/徽章留出空间 */
  .session-title {
    /* 原始（仅作记录，未删除）： max-width: 160px; */
    max-width: calc(var(--sidebar-width) - 120px) !important;
    white-space: nowrap !important;
    text-overflow: ellipsis !important;
    overflow: hidden !important;
  }

  /* 3) session-meta：保证徽章区域右对齐且不被压缩 */
  .session-meta {
    /* 原始（仅作记录，未删除）： display:flex; justify-content: space-between; ... */
    min-width: 0 !important;
    display: flex !important;
    gap: 6px !important;
    align-items: center !important;
    justify-content: flex-end !important;
  }

  /* 4) session-list：微小右侧缓冲，避免紧贴侧栏边缘导致裁切 */
  .session-list {
    /* 原始（仅作记录，未删除）： padding-top: 4px; */
    padding-right: 6px !important;
  }

  /* 5) 手机端抽屉兼容：在手机抽屉场景下提供合适的 max-width */
  @media (max-width: 900px) {
    .session-title {
      max-width: calc(min(80vw, 320px) - 120px) !important;
    }
  }

  /*
  .app-shell {
    overflow: visible !important; 仅用于调试：请谨慎启用
  }
  */

  /* ===== PATCH END ===== */
</style>

</head>
<body>
  <div class="app-shell">
    <!-- 手机端顶部左右菜单按钮 -->
    <div class="mobile-top-bar">
      <button class="mobile-toggle-btn mobile-toggle-btn-left" id="btnMobileSidebar" aria-label="展开会话列表">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
      <button class="mobile-toggle-btn mobile-toggle-btn-right" id="btnMobileInsight" aria-label="展开调用概览">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
    </div>

    <!-- 左侧：会话列表 -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title-row">
          <div class="sidebar-title">
            <span class="status-dot"></span>
            Agent Worker 控制台
          </div>
        </div>
        <div class="sidebar-subtitle">本地对接 · Cloudflare &AI 智能体</div>
        <div class="sidebar-tags">
          <div class="tag-chip"><strong>Agent</strong> worker-agent</div>
          <div class="tag-chip"><strong>Model</strong> gpt-5-mini</div>
          <div class="tag-chip"><strong>Route</strong> Worker → OpenAI Chat</div>
        </div>
        <div class="sidebar-divider"></div>
      </div>

      <div class="sidebar-actions">
        <button class="btn-new-session" id="btnNewSession">
          <span class="btn-icon">＋</span>
          新建会话
        </button>
        <div class="sidebar-env">
          <span class="sidebar-env-dot"></span>
          环境：Dev
        </div>
      </div>

      <div class="session-list" id="sessionList">
        <!-- JS 渲染会话 -->
      </div>

      <div class="sidebar-footer">
        本页面仅作 <strong>AI 智能体链路测试</strong>，不保存服务端日志。
      </div>
    </aside>

    <!-- 中间：主聊天区域 -->
    <main class="main-panel">
      <div class="main-header">
        <div class="main-header-left">
          <div class="breadcrumbs">
            <span>Agent Worker 测试面板</span>
            <span>·</span>
            <span>前端 → Cloudflare  → OpenAI Chat Completions</span>
          </div>
          <div class="agent-title-row">
            <div class="agent-name">Agent Worker 测试面板</div>
            <div class="pill">
              <span>Agent:</span>
              <strong id="currentAgentLabel">worker-agent</strong>
            </div>
            <div class="pill">
              <span>模型:</span>
              <strong id="currentModelLabel">gpt-5-mini</strong>
            </div>
          </div>
        </div>
            <!--
        <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span>Worker: AI Agent</span>
          </div>
        </div>
        -->
               <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span id="routeLabel">模式：直连 Worker</span>
          </div>

          <!-- ===== PATCH BEGIN: Agent / Env 选择控件（Step 4.1） ===== -->
          <div class="agent-env-controls">
            <label for="modeSelect">Call:</label>
            <select id="modeSelect" class="agent-env-select">
              <option value="direct">直连 Worker</option>
              <option value="agent-devops">Agent · devops</option>
            </select>

            <label for="agentSelect">Agent:</label>
            <select id="agentSelect" class="agent-env-select">
              <option value="devops">devops</option>
            </select>

            <label for="envSelect">Env:</label>
            <select id="envSelect" class="agent-env-select">
              <option value="dev">Dev</option>
              <option value="prod" disabled>Prod（预留）</option>
            </select>
          </div>
          <!-- ===== PATCH END ===== -->
       </div>
      </div>

      <section class="chat-surface">
        <div class="chat-messages" id="chatMessages">
          <div class="chat-empty" id="chatEmpty">
            <div>这里会显示你和 Worker 智能体的对话记录。</div>
            <div>试试输入：<strong>「帮我把下面的报错信息按原因拆解一下」</strong>。</div>
          </div>
        </div>

        <div class="chat-input-bar">
          <div class="chat-input-row">
            <textarea
              id="chatInput"
              class="chat-input"
              placeholder="在这里输入：比如『帮我总结一下今天要做的三件事』，然后按 Ctrl+Enter 或点击发送。"
            ></textarea>
            <button id="btnSend" class="send-button">
              <span class="send-button-icon">↗</span>
              <span id="btnSendLabel">发送</span>
            </button>
          </div>
          <div class="input-hint-row">
            <span>支持多行输入。<strong>Ctrl+Enter</strong> 发送。</span>
            <span id="requestMetaHint">就绪：调用 Cloudflare   &AI智能体。</span>
          </div>
        </div>
      </section>

      <div class="toast" id="toast">
        <span class="toast-icon">⚠️</span>
        <span id="toastText">错误信息</span>
      </div>
    </main>

    <!-- 右侧：调用概览 -->
    <aside class="insight-panel">
      <div class="insight-card">
        <h3>
          调用概览
          <span class="insight-tag">最近一次</span>
        </h3>
        <div class="call-overview-row">
          <span>耗时</span>
          <span id="ovDuration">-</span>
        </div>
        <div class="call-overview-row">
          <span>状态</span>
          <span id="ovStatus">
            <span class="call-status-pill">
              <span class="call-status-dot"></span>
              尚未调用
            </span>
          </span>
        </div>
        <div class="call-overview-row">
          <span>模型</span>
          <span id="ovModel">gpt-5-mini</span>
        </div>
        <div class="call-overview-row">
          <span>Prompt tokens</span>
          <span id="ovPromptTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Completion tokens</span>
          <span id="ovCompletionTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Total tokens</span>
          <span id="ovTotalTokens">-</span>
        </div>
      </div>

      <div class="insight-card">
        <div class="raw-json-header">
          <span>原始返回</span>
          <div class="json-buttons">
            <button class="btn-ghost" id="btnToggleJson">展开 JSON</button>
            <button class="btn-ghost" id="btnCopyJson">复制</button>
          </div>
        </div>
        <div class="raw-json-body" id="rawJsonBody">
          <div class="raw-json-placeholder" id="rawJsonPlaceholder">
            尚未调用。调用后这里会显示 Worker 与 OpenAI 返回的完整 JSON。
          </div>
          <pre class="raw-json-pre" id="rawJsonPre" style="display:none;"></pre>
        </div>
      </div>

      <div class="insight-card">
        <h3>
          智能体说明
          <span class="insight-tag">worker-agent · Dev</span>
        </h3>
        <ul class="agent-desc-list">
          <li>· <span>职责：</span>验证 Cloudflare  → OpenAI gpt-5-mini 聊天链路。</li>
          <li>· <span>能力：</span>回答自然语言问题，展示模型与 tokens 信息。</li>
          <li>· <span>限制：</span>不访问业务数据库、不执行写操作工具调用。</li>
          <li>· <span>适用场景：</span>本地联调、链路健康检查、最小可用智能体测试。</li>
        </ul>
      </div>
    </aside>

    <!-- 移动端遮罩 -->
    <div class="mobile-overlay" id="mobileOverlay"></div>
  </div>

  <script>

      // === Config ===
    // 与 CF Route: oliverfr.com/agent.mefans.workers.dev/* 对齐
//const WORKER_ENDPOINT = "/agent.mefans.workers.dev/"; // ← 错
//const AGENT_ENDPOINT  = "/agent.mefans.workers.dev/api/agent"; // ← 错
const WORKER_ENDPOINT = "https://agent.mefans.workers.dev/";
 // const WORKER_ENDPOINT = "/agent/";              // 直连 Worker
//11.25新增在“端点常量”下面新增一个端点守护函数
    // ===== PATCH BEGIN: Agent 模式后端端点常量 / Step 4.1 =====
 //  const AGENT_ENDPOINT = "https://agent.mefans.workers.dev/api/agent";
const AGENT_ENDPOINT  = "/agent/api/agent";     // Agent Runtime 路由
// ✅ 同源路由（与你的 CF Route: oliverfr.com/agent/* 对齐）
//const WORKER_ENDPOINT = "https://oliverfr.com/agent/";
//const AGENT_ENDPOINT  = WORKER_ENDPOINT + "api/agent";
// 或者在 agent-test.html 里用：const AGENT_ENDPOINT = "/agent/api/agent";

    // ===== PATCH ADD · 端点守护（避免误连 Cloud Run）=====
// 端点解析：始终返回一个“可安全直连”的绝对 URL。
// 规则：
// 1) 若 AGENT_ENDPOINT 指向 *.run.app，则强制走 Worker 代理 /api/agent（规避 CSP/connect-src: 'self' 限制）。
// 2) 支持三种写法：绝对地址(https://...)、站内绝对路径(/api/agent)、相对路径(agent/api/agent)。
// 3) 任何解析异常一律回退 Worker 代理。
// 依赖：已定义的 WORKER_ENDPOINT 与 AGENT_ENDPOINT。
function resolveAgentEndpoint() {
  try {
    // 规范化 Worker 基址（支持 'https://agent.mefans.workers.dev/' 或 '/agent/'）
    const workerBase = new URL(
      WORKER_ENDPOINT,
      // 若 WORKER_ENDPOINT 是相对路径，使用当前站点作为基准
      window.location.origin
    );
    const workerApi = new URL('/api/agent', workerBase).toString();

    // 若未配置 AGENT_ENDPOINT，直接走 Worker 代理
    if (!AGENT_ENDPOINT) return workerApi;

    // 规范化目标端点：支持绝对/相对/站内绝对路径
    let target;
    if (/^https?:\/\//i.test(AGENT_ENDPOINT)) {
      target = new URL(AGENT_ENDPOINT);
    } else if (AGENT_ENDPOINT.startsWith('/')) {
      target = new URL(AGENT_ENDPOINT, window.location.origin);
    } else {
      // 相对路径（如 'agent/api/agent'）默认相对当前站点
      target = new URL(AGENT_ENDPOINT, window.location.origin);
    }

    const host = (target.hostname || '').toLowerCase();

    // 若指向 Cloud Run，则改走 Worker 代理（前端仅允许同源，避免 CSP: connect-src 'self'）
    if (host.endsWith('.run.app')) {
      console.warn('[Agent] AGENT_ENDPOINT 指向 Cloud Run，被改为走 Worker 代理。', {
        host,
        fallback: workerApi
      });
      return workerApi;
    }

    // 返回规范化后的绝对 URL
    return target.toString();
  } catch (e) {
    // 任何解析异常，回退 Worker 代理，并在控制台给出提示
    console.warn('[Agent] 端点解析异常，回退 Worker 代理。', e);
    try {
      return new URL('/api/agent', new URL(WORKER_ENDPOINT, window.location.origin)).toString();
    } catch {
      // 最终兜底（当 WORKER_ENDPOINT 也无法被 URL 解析时）
      return '/agent/api/agent';
    }
  }
}


// （可选）在页面初始化时给出一次温和提示，便于你排查 CSP
function warnIfLikelyCspBlock() {
  try {
    const agentOrigin = new URL(resolveAgentEndpoint()).origin;
    if (agentOrigin !== window.location.origin) {
      console.info(
        "[CSP 提示] 当前页面可能是 connect-src 'self'，跨域连接会被拦截。" +
        "如遇到报错，请在站点 CSP 的 connect-src 中加入：", agentOrigin
      );
    }
  } catch {}
}
document.addEventListener('DOMContentLoaded', warnIfLikelyCspBlock);


    const MODE_DIRECT = "direct";
    const MODE_AGENT_DEVOPS = "agent-devops";

    const AGENT_PROFILES = [
      { id: "devops", label: "devops · DevOps Agent" },
      // 后续可以扩展 cs / analytics 等
    ];

    const ENV_PROFILES = [
      { id: "dev", label: "Dev" },
      { id: "prod", label: "Prod", disabled: true }, // 预留
    ];
    // ===== PATCH END =====
    //只是在前端把结构“写死”出来，方便后面取值
  // ===== [ADD · Step 4.2.1 · Agent Runtime response shape] =====
/**
 * @typedef {Object} AgentCost
 * @property {number} tokens_prompt
 * @property {number} tokens_completion
 * @property {number} total_tokens
 * @property {number} usd_estimate
 *
 * @typedef {Object} AgentStateSnapshot
 * @property {string} task_type
 * @property {string[]} guard_flags
 * @property {string[]} degrade_flags
 * @property {Object<string, any>} [extra]
 *
 * @typedef {Object} AgentResponse
 * @property {string} reply
 * @property {string} trace_id
 * @property {string} agent
 * @property {string} env
 * @property {string[]} nodes_executed
 * @property {any[]} tools_used
 * @property {AgentCost} cost
 * @property {AgentStateSnapshot} state_snapshot
 * @property {Object<string, any>} [debug]
 */

    
    const DB_NAME = "agentWorkerDB";
    const DB_VERSION = 1;
    const SESSION_STORE = "sessions"; // 静态桶：会话 + 右侧 overview
    const MESSAGE_STORE = "messages"; // 动态桶：消息流水
    const MAX_SESSIONS = 50;

    const LS_SESSIONS_KEY = "agentWorker:sessions";
    const LS_MESSAGES_KEY = "agentWorker:messages";

    // === State ===
    let dbPromise = null;
    let useIndexedDB = true;
    let sessions = [];
    let currentSessionId = null;
    let isSending = false;
    let lastRawResponse = "";
// ===== PATCH BEGIN: Agent 模式前端状态 / Step 4.1 =====
    // 当前调用模式：直连 Worker / Agent Runtime
    let currentMode = MODE_DIRECT;
    // 当前 Agent profile（截图中的 devops / cs / analytics 之一，这里先只实现 devops）
    let currentAgentId = "devops";
    // 当前环境：Dev / Prod
    let currentEnvId = "dev";
    // 用于 /api/agent 的 user_id（延迟初始化，写入 localStorage）
    let currentUserId = null;
    // ===== PATCH END =====
        // 移动端抽屉状态（左右）
    let isSidebarOpenMobile = false;
    let isInsightOpenMobile = false;

    let lastOverview = null;
    let currentMobilePanel = null;

    const el = {};

    document.addEventListener("DOMContentLoaded", () => {
      cacheDom();
      bindGlobalEvents();
      initApp();
    });

    async function initApp() {
      try {
        await initIndexedDB();
        await initSessions();
          // ===== PATCH BEGIN: 初始化 Agent 模式 UI 状态 / Step 4.1 =====
        currentUserId = getOrInitUserId();
        applyModeUiState();
        // ===== PATCH END =====
      } catch (err) {
        showFatalError(err);
      }
    }

    function cacheDom() {
      el.appShell = document.querySelector(".app-shell");
       el.mainPanel = document.querySelector(".main-panel");   // ★ 新增：主聊天面板引用
      
      el.sessionList = document.getElementById("sessionList");
      el.btnNewSession = document.getElementById("btnNewSession");
      el.chatMessages = document.getElementById("chatMessages");
      el.chatEmpty = document.getElementById("chatEmpty");
      el.chatInput = document.getElementById("chatInput");
      el.btnSend = document.getElementById("btnSend");
      el.btnSendLabel = document.getElementById("btnSendLabel");
      el.requestMetaHint = document.getElementById("requestMetaHint");
//11.23新增step4.1
            el.currentAgentLabel = document.getElementById("currentAgentLabel");
      el.currentModelLabel = document.getElementById("currentModelLabel");
      el.routeLabel = document.getElementById("routeLabel");
      el.modeSelect = document.getElementById("modeSelect");
      el.agentSelect = document.getElementById("agentSelect");
      el.envSelect = document.getElementById("envSelect");

      el.ovDuration = document.getElementById("ovDuration");
      el.ovStatus = document.getElementById("ovStatus");
      el.ovModel = document.getElementById("ovModel");
      el.ovPromptTokens = document.getElementById("ovPromptTokens");
      el.ovCompletionTokens = document.getElementById("ovCompletionTokens");
      el.ovTotalTokens = document.getElementById("ovTotalTokens");

      el.rawJsonBody = document.getElementById("rawJsonBody");
      el.rawJsonPlaceholder = document.getElementById("rawJsonPlaceholder");
      el.rawJsonPre = document.getElementById("rawJsonPre");
      el.btnToggleJson = document.getElementById("btnToggleJson");
      el.btnCopyJson = document.getElementById("btnCopyJson");

      el.toast = document.getElementById("toast");
      el.toastText = document.getElementById("toastText");

            // 移动端抽屉相关（顶栏 + 遮罩 + 左右抽屉 + 整体容器）
      el.appShell = document.querySelector(".app-shell");
      el.mobileTopBar = document.querySelector(".mobile-top-bar");
      el.mobileOverlay = document.getElementById("mobileOverlay");
      el.btnToggleSidebar = document.getElementById("btnToggleSidebar");
      el.btnToggleInsight = document.getElementById("btnToggleInsight");
      el.sidebar = document.querySelector(".sidebar");
      el.insightPanel = document.querySelector(".insight-panel");

      el.btnMobileSidebar = document.getElementById("btnMobileSidebar");
      el.btnMobileInsight = document.getElementById("btnMobileInsight");
      el.mobileOverlay = document.getElementById("mobileOverlay");
    }

    function bindGlobalEvents() {
//11.23新增step4.1
       // ===== PATCH BEGIN: Agent / Env 控件事件绑定 =====
      if (el.modeSelect) {
        el.modeSelect.addEventListener("change", () => {
          const value = el.modeSelect.value === MODE_AGENT_DEVOPS ? MODE_AGENT_DEVOPS : MODE_DIRECT;
          currentMode = value;
          applyModeUiState();
        });
      }

      if (el.agentSelect) {
        el.agentSelect.addEventListener("change", () => {
          currentAgentId = el.agentSelect.value || "devops";
          applyModeUiState();
        });
      }

      if (el.envSelect) {
        el.envSelect.addEventListener("change", () => {
          currentEnvId = el.envSelect.value || "dev";
          applyModeUiState();
        });
      }
      // ===== PATCH END =====
      // ===== 移动端左右抽屉：两条横线菜单 =====
      if (el.btnToggleSidebar) {
        el.btnToggleSidebar.addEventListener("click", () => {
          const willOpen = !isSidebarOpenMobile;
          isSidebarOpenMobile = willOpen;

          if (el.sidebar) {
            el.sidebar.classList.toggle("sidebar-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-right", willOpen);
            // 打开左侧时，确保右侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-left");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-right", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-left");
            }
          }
          if (willOpen && isInsightOpenMobile) {
            // 左侧打开时，顺便关掉右侧抽屉
            isInsightOpenMobile = false;
            if (el.insightPanel) {
              el.insightPanel.classList.remove("insight-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.btnToggleInsight) {
        el.btnToggleInsight.addEventListener("click", () => {
          const willOpen = !isInsightOpenMobile;
          isInsightOpenMobile = willOpen;

          if (el.insightPanel) {
            el.insightPanel.classList.toggle("insight-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-left", willOpen);
            // 打开右侧时，确保左侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-right");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-left", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-right");
            }
          }
          if (willOpen && isSidebarOpenMobile) {
            isSidebarOpenMobile = false;
            if (el.sidebar) {
              el.sidebar.classList.remove("sidebar-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          // 点击遮罩：统一关闭左右抽屉 & 复位整体 transform
          isSidebarOpenMobile = false;
          isInsightOpenMobile = false;

          if (el.sidebar) {
            el.sidebar.classList.remove("sidebar-open");
          }
          if (el.insightPanel) {
            el.insightPanel.classList.remove("insight-open");
          }
          if (el.appShell) {
            el.appShell.classList.remove("push-right", "push-left");
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.remove("push-right", "push-left");
          }
          updateMobileOverlay();
        });
      }

      el.btnNewSession.addEventListener("click", () => {
        handleNewSession();
      });

      el.sessionList.addEventListener("click", (event) => {
        const target = event.target;
        const item = target.closest("[data-session-id]");
        if (!item) return;

        const id = item.getAttribute("data-session-id");
        const deleteBtn = target.closest("[data-action='delete-session']");
        const renameBtn = target.closest("[data-action='rename-session']");

        if (deleteBtn) {
          event.stopPropagation();
          handleDeleteSession(id);
          return;
        }

        if (renameBtn) {
          event.stopPropagation();
          handleRenameSession(id);
          return;
        }

        selectSession(id);
      });

      el.btnSend.addEventListener("click", () => {
        triggerSend();
      });

      el.chatInput.addEventListener("keydown", (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          triggerSend();
        }
      });

      el.btnToggleJson.addEventListener("click", () => {
        const isOpen = el.rawJsonBody.classList.toggle("open");
        el.btnToggleJson.textContent = isOpen ? "收起 JSON" : "展开 JSON";
      });

      el.btnCopyJson.addEventListener("click", async () => {
        if (!lastRawResponse) {
          showToast("当前没有可复制的 JSON");
          return;
        }
        try {
          await navigator.clipboard.writeText(lastRawResponse);
          showToast("已复制 JSON 到剪贴板");
        } catch (err) {
          console.error(err);
          showToast("复制失败，请检查浏览器权限");
        }
      });

      if (el.btnMobileSidebar) {
        el.btnMobileSidebar.addEventListener("click", () => {
          toggleMobilePanel("left");
        });
      }

      if (el.btnMobileInsight) {
        el.btnMobileInsight.addEventListener("click", () => {
          toggleMobilePanel("right");
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          closeMobilePanels();
        });
      }

      window.addEventListener("resize", () => {
        if (!isMobileViewport()) {
          closeMobilePanels();
        }
      });
    }
    //在 bindGlobalEvents 下面加一个小 helper
    // 控制遮罩显示：只要有任一抽屉打开就显示
    function updateMobileOverlay() {
      if (!el.mobileOverlay) return;
      const visible = isSidebarOpenMobile || isInsightOpenMobile;
      if (visible) {
        el.mobileOverlay.classList.add("visible");
      } else {
        el.mobileOverlay.classList.remove("visible");
      }
    }

    function isMobileViewport() {
      return window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
    }

     function toggleMobilePanel(target) {
      if (!isMobileViewport()) return;
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (!sidebar || !insight || !el.appShell || !el.mainPanel) return;

      const isSame = currentMobilePanel === target;
      if (isSame) {
        closeMobilePanels();
        return;
      }

      // 打开任意一侧前，先清理主面板的内联 transform，避免残留
      el.mainPanel.style.transform = "";

      if (target === "left") {
        // 左侧：保持现有行为不变
        sidebar.classList.add("sidebar-open");
        insight.classList.remove("insight-open");

        el.appShell.classList.add("push-right");
        el.appShell.classList.remove("push-left");

        el.mainPanel.classList.add("move-right");
        el.mainPanel.classList.remove("move-left");

        currentMobilePanel = "left";
      } else if (target === "right") {
        // 右侧：抽屉滑出 + 主面板整体向左推
        insight.classList.add("insight-open");
        sidebar.classList.remove("sidebar-open");

        el.appShell.classList.add("push-left");
        el.appShell.classList.remove("push-right");

        // ★ 关键：用右侧抽屉的实际宽度来平移主面板，避免“纯覆盖”
        const drawerWidth = insight.offsetWidth || 0;
        if (drawerWidth > 0) {
          el.mainPanel.style.transform = `translateX(-${drawerWidth}px)`;
        } else {
          // 兜底：偶尔拿不到宽度时，还可以退回 CSS class 方案
          el.mainPanel.classList.add("move-left");
        }
        el.mainPanel.classList.remove("move-right");

        currentMobilePanel = "right";
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.classList.add("visible");
      }
    }



    function closeMobilePanels() {
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (sidebar) sidebar.classList.remove("sidebar-open");
      if (insight) insight.classList.remove("insight-open");

      if (el.appShell) {
        el.appShell.classList.remove("push-right", "push-left");
      }

      if (el.mainPanel) {
        el.mainPanel.classList.remove("move-right", "move-left");
        el.mainPanel.style.transform = ""; // ★ 清掉右侧打开时设置的内联位移
      }

      currentMobilePanel = null;
      if (el.mobileOverlay) {
        el.mobileOverlay.classList.remove("visible");
      }
    }


    // === IndexedDB + localStorage 封装 ===

    async function initIndexedDB() {
      if (!("indexedDB" in window)) {
        useIndexedDB = false;
        console.warn("[IndexedDB] 不支持，自动使用 localStorage。");
        return;
      }

      try {
        dbPromise = new Promise((resolve, reject) => {
          let request;
          try {
            request = indexedDB.open(DB_NAME, DB_VERSION);
          } catch (err) {
            reject(err);
            return;
          }

          request.onerror = () => {
            reject(request.error || new Error("indexedDB open error"));
          };

          request.onsuccess = () => {
            resolve(request.result);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(SESSION_STORE)) {
              const sessionStore = db.createObjectStore(SESSION_STORE, { keyPath: "id" });
              sessionStore.createIndex("updatedAt", "updatedAt", { unique: false });
            }
            if (!db.objectStoreNames.contains(MESSAGE_STORE)) {
              const messageStore = db.createObjectStore(MESSAGE_STORE, { keyPath: "id" });
              messageStore.createIndex("sessionId", "sessionId", { unique: false });
            }
          };
        });

        await dbPromise;
      } catch (err) {
        console.warn("[IndexedDB] 初始化失败，自动切换 localStorage。", err);
        dbPromise = null;
        useIndexedDB = false;
      }
    }

    function dbReadAll(storeName, indexName, query, direction = "prev") {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readonly");
              let store = tx.objectStore(storeName);
              if (indexName) {
                store = store.index(indexName);
              }
              const items = [];
              const req = store.openCursor(query, direction);
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  items.push(cursor.value);
                  cursor.continue();
                } else {
                  resolve(items);
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbPut(storeName, value) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.put(value);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDelete(storeName, key) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.delete(key);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDeleteWhereMessages(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readwrite");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.openCursor(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  cursor.delete();
                  cursor.continue();
                } else {
                  resolve();
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbReadMessagesBySession(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readonly");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.getAll(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve(req.result || []);
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    async function loadSessionsFromStorage() {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadAll(SESSION_STORE, "updatedAt");
        } catch (err) {
          console.warn("[IndexedDB] 读取 sessions 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_SESSIONS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        console.warn("[localStorage] 读取 sessions 失败。", err);
        return [];
      }
    }

    async function loadMessagesFromStorage(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadMessagesBySession(sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 读取 messages 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.filter((m) => m.sessionId === sessionId);
      } catch (err) {
        console.warn("[localStorage] 读取 messages 失败。", err);
        return [];
      }
    }

    async function saveSession(session) {
      // 先确保内存 sessions 更新
      const idx = sessions.findIndex((s) => s.id === session.id);
      if (idx === -1) sessions.push(session);
      else sessions[idx] = session;

      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(SESSION_STORE, session);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 session 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
      } catch (err) {
        console.warn("[localStorage] 写入 sessions 失败。", err);
      }
    }

    async function saveMessage(message) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(MESSAGE_STORE, message);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 message 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        const arr = raw ? (JSON.parse(raw) || []) : [];
        arr.push(message);
        localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arr));
      } catch (err) {
        console.warn("[localStorage] 写入 messages 失败。", err);
      }
    }

    async function deleteSessionAndMessages(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbDeleteWhereMessages(sessionId);
          await dbDelete(SESSION_STORE, sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 删除会话失败，尝试 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          const rawS = localStorage.getItem(LS_SESSIONS_KEY);
          let arrS = rawS ? JSON.parse(rawS) : [];
          if (Array.isArray(arrS)) {
            arrS = arrS.filter((s) => s.id !== sessionId);
            localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(arrS));
          }
          const rawM = localStorage.getItem(LS_MESSAGES_KEY);
          let arrM = rawM ? JSON.parse(rawM) : [];
          if (Array.isArray(arrM)) {
            arrM = arrM.filter((m) => m.sessionId !== sessionId);
            localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arrM));
          }
        } catch (err) {
          console.warn("[localStorage] 删除会话失败。", err);
        }
      }
    }

    // === Session / message model ===

    function createSessionObject() {
      const id = crypto.randomUUID ? crypto.randomUUID() : "s_" + Date.now();
      const ts = Date.now();
      return {
        id,
        title: "新会话",
        createdAt: ts,
        updatedAt: ts,
        totalTokens: 0,
        isEmpty: true,
        lastCallOverview: null,
        lastRawJson: "",
      };
    }

    /*function createMessage(sessionId, role, content) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
      };
    }*/
        function createMessage(sessionId, role, content, meta) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
        meta: meta || null,
      };
    }


    async function initSessions() {
      let stored = await loadSessionsFromStorage();
      if (!stored || stored.length === 0) {
        const session = createSessionObject();
        sessions = [session];
        currentSessionId = session.id;
        await saveSession(session);
      } else {
        sessions = stored;
        currentSessionId = sessions[0].id;
      }
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    function formatShortTime(timestamp) {
      if (!timestamp) return "-";
      const d = new Date(timestamp);
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }

    function renderSessionList() {
      el.sessionList.innerHTML = "";
      sessions.forEach((session) => {
        const item = document.createElement("div");
        item.className = "session-item" + (session.id === currentSessionId ? " active" : "");
        item.setAttribute("data-session-id", session.id);

        const headerRow = document.createElement("div");
        headerRow.className = "session-header-row";

        const headerLeft = document.createElement("div");
        headerLeft.className = "session-header-left";

        const titleSpan = document.createElement("div");
        titleSpan.className = "session-title";
        titleSpan.textContent = session.title || "未命名会话";

        const renameBtn = document.createElement("button");
        renameBtn.className = "btn-rename-session";
        renameBtn.setAttribute("data-action", "rename-session");
        renameBtn.textContent = "✎";

        headerLeft.appendChild(titleSpan);
        headerLeft.appendChild(renameBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-delete-session";
        deleteBtn.setAttribute("data-action", "delete-session");
        deleteBtn.textContent = "×";

        headerRow.appendChild(headerLeft);
        headerRow.appendChild(deleteBtn);

        const metaRow = document.createElement("div");
        metaRow.className = "session-meta";

        const timeSpan = document.createElement("span");
        timeSpan.textContent = formatShortTime(session.updatedAt);

        const tokenSpan = document.createElement("span");
        tokenSpan.className = "session-tokens";
        tokenSpan.textContent = `${session.totalTokens || 0} tokens`;

        metaRow.appendChild(timeSpan);
        metaRow.appendChild(tokenSpan);

        item.appendChild(headerRow);
        item.appendChild(metaRow);

        el.sessionList.appendChild(item);
      });
    }

    async function selectSession(sessionId) {
      if (!sessionId) return;
      if (sessionId === currentSessionId) {
        if (isMobileViewport()) closeMobilePanels();
        return;
      }
      currentSessionId = sessionId;
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
      if (isMobileViewport()) closeMobilePanels();
    }

    async function renderCurrentSessionMessages() {
      if (!currentSessionId) return;
      const messages = await loadMessagesFromStorage(currentSessionId);
      if (!messages || messages.length === 0) {
        el.chatMessages.innerHTML = "";
        el.chatMessages.appendChild(el.chatEmpty);
        el.chatEmpty.style.display = "flex";
        return;
      }
      el.chatMessages.innerHTML = "";
    /*  messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false);
        });*/

            messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false, msg.meta || null);
        });

      scrollToBottom();
    }

    async function handleNewSession() {
      const existingEmpty = sessions.find((s) => s.isEmpty);
      if (existingEmpty) {
        currentSessionId = existingEmpty.id;
        renderSessionList();
        await renderCurrentSessionMessages();
        hydrateCurrentSessionInsights();
        if (isMobileViewport()) closeMobilePanels();
        return;
      }

      const session = createSessionObject();
      sessions.unshift(session);
      currentSessionId = session.id;
      await saveSession(session);
      await cleanupOldSessionsIfNecessary();

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleDeleteSession(sessionId) {
      if (!sessionId) return;

      await deleteSessionAndMessages(sessionId);

      sessions = sessions.filter((s) => s.id !== sessionId);

      if (sessions.length === 0) {
        const newSession = createSessionObject();
        sessions = [newSession];
        currentSessionId = newSession.id;
        await saveSession(newSession);
      } else if (currentSessionId === sessionId) {
        currentSessionId = sessions[0].id;
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 同步 sessions 失败。", e);
        }
      }

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleRenameSession(sessionId) {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) return;
      const newTitle = window.prompt("请输入会话标题：", session.title || "");
      if (newTitle === null) return;
      const trimmed = newTitle.trim();
      session.title = trimmed || "未命名会话";
      session.updatedAt = Date.now();
      await saveSession(session);
      renderSessionList();
    }

    async function cleanupOldSessionsIfNecessary() {
      if (sessions.length <= MAX_SESSIONS) return;
      const sorted = [...sessions].sort((a, b) => b.updatedAt - a.updatedAt);
      const keep = sorted.slice(0, MAX_SESSIONS);
      const remove = sorted.slice(MAX_SESSIONS);

      sessions = keep;

      for (const s of remove) {
        await deleteSessionAndMessages(s.id);
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 清理 sessions 时同步失败。", e);
        }
      }
    }
//11.23新增step4.1相关的4段函数
        // ===== PATCH BEGIN: Agent 模式辅助函数 / userId =====
    function getOrInitUserId() {
      const key = "agentWorker:userId";
      try {
        const existing = localStorage.getItem(key);
        if (existing) return existing;

        const id =
          (crypto.randomUUID && crypto.randomUUID()) ||
          "u_" + Date.now() + "_" + Math.random().toString(16).slice(2);
        localStorage.setItem(key, id);
        return id;
      } catch (e) {
        return "anonymous";
      }
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent 模式 UI 状态同步 =====
    function applyModeUiState() {
      if (el.modeSelect) {
        el.modeSelect.value = currentMode;
      }
      if (el.agentSelect) {
        el.agentSelect.value = currentAgentId;
        // 只有 Agent 模式才允许切换 Agent
        el.agentSelect.disabled = currentMode !== MODE_AGENT_DEVOPS;
      }
      if (el.envSelect) {
        el.envSelect.value = currentEnvId;
      }

      if (el.currentAgentLabel) {
        el.currentAgentLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? `agent:${currentAgentId}`
            : "worker-direct";
      }

      if (el.routeLabel) {
        el.routeLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "模式：Agent Runtime /api/agent"
            : "模式：直连 Worker";
      }

      // 仅在非发送中时更新提示文案
      if (el.requestMetaHint && !isSending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent payload 组装 & runtime 摘要提取 =====
    function buildAgentPayload(inputText) {
      return {
        tenant_id: "oliverfr",
        agent: currentAgentId,
        env: currentEnvId,
        session_id: currentSessionId,
        user_id: currentUserId || "anonymous",
        input: inputText,
        meta: {
          source: "agent-worker-ui",
          mode: currentMode,
          ua: navigator.userAgent || "",
        },
      };
    }

function extractRuntimeMetaFromAgentResponse(data) {
      if (!data || typeof data !== "object") return null;

      // 1）runtime 主体：优先 runtime / agent_runtime
      const rt =
        (data.runtime && typeof data.runtime === "object" && data.runtime) ||
        (data.agent_runtime && typeof data.agent_runtime === "object" && data.agent_runtime) ||
        null;

      // 如果连 runtime 容器都没有，尽量从顶层抽一点基础信息，避免返回 null
      if (!rt) {
        return {
          graphVersion: data.graph_version || data.graphVersion || null,
          taskType: data.task_type || data.taskType || null,
          traceId: data.trace_id || data.traceId || data._gateway_trace_id || null,
          nodeCount: 0,
          toolCount: 0,
          ragHits: 0,
          rawNodes: [],
          rawTools: [],
          rawRag: null,
        };
      }

      // 2）节点/步骤：nodes / nodes_executed / steps / flow
      const nodesRaw =
        rt.nodes_executed ||
        rt.nodes ||
        rt.steps ||
        rt.flow ||
        null;
      const nodes = Array.isArray(nodesRaw) ? nodesRaw : [];

      // 3）工具调用：tools / tools_used / tool_calls
      const toolsRaw =
        rt.tools ||
        rt.tools_used ||
        rt.tool_calls ||
        null;
      const tools = Array.isArray(toolsRaw) ? toolsRaw : [];

      // 4）RAG 统计：rag / rag_stats / rag_status
      const rag =
        (rt.rag && typeof rt.rag === "object" && rt.rag) ||
        (rt.rag_stats && typeof rt.rag_stats === "object" && rt.rag_stats) ||
        (rt.rag_status && typeof rt.rag_status === "object" && rt.rag_status) ||
        null;

      let ragHits = 0;
      if (rag) {
        // 常见几种命名：hits_count / hits / top_k / docs[]
        if (typeof rag.hits_count === "number") {
          ragHits = rag.hits_count;
        } else if (typeof rag.hits === "number") {
          ragHits = rag.hits;
        } else if (typeof rag.top_k === "number") {
          ragHits = rag.top_k;
        } else if (Array.isArray(rag.docs)) {
          ragHits = rag.docs.length;
        }
      }

      // 5）graphVersion：runtime.graph_version / runtime.graphVersion / 顶层同名
      const graphVersion =
        rt.graph_version ||
        rt.graphVersion ||
        data.graph_version ||
        data.graphVersion ||
        null;

      // 6）taskType：runtime.task_type / runtime.taskType / 顶层同名
      const taskType =
        rt.task_type ||
        rt.taskType ||
        data.task_type ||
        data.taskType ||
        null;

      // 7）traceId：runtime.trace_id / runtime.traceId / 顶层 trace_id / _gateway_trace_id
      const traceId =
        rt.trace_id ||
        rt.traceId ||
        data.trace_id ||
        data.traceId ||
        data._gateway_trace_id ||
        null;

      // 返回结构保持与原函数完全一致，调用方无需改动
      return {
        graphVersion,
        taskType,
        traceId,
        nodeCount: Array.isArray(nodes) ? nodes.length : 0,
        toolCount: Array.isArray(tools) ? tools.length : 0,
        ragHits,
        rawNodes: nodes,
        rawTools: tools,
        rawRag: rag,
      };
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: 统一调用后端（直连 Worker / Agent Runtime） =====
// ===== [PATCH REPLACE · Step 4.2.2 · 统一后端调用（附带 agentRaw）] =====
async function callBackendWithMode(userText) {
  const start = performance.now();
  let durationMs = 0;
  let rawResponse = "";
  let replyText = "";
  let modelName = "gpt-5-mini";
  let usage = null;
  let runtimeMeta = null;
  let agentRaw = null;   // ★ 新增：返回解析后的 Agent 原始对象
  let status = 0;
  let ok = false;

  try {
    if (currentMode === MODE_AGENT_DEVOPS) {
      const payload = buildAgentPayload(userText);
     // const res = await fetch(AGENT_ENDPOINT, {
      //11.25统一后端调用里替换一行 fetch 目标
      const res = await fetch(resolveAgentEndpoint(), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      durationMs = performance.now() - start;
      status = res.status;
      const text = await res.text();
      rawResponse = text;

      if (!res.ok) {
        return { ok: false, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
      }

      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }

      if (data) {
        agentRaw = data; // ★ 关键：把完整 JSON 保留，给右侧面板和消息 meta 用
        replyText = data.reply || data.output || "";
        modelName = data.model || (data.runtime && data.runtime.model_profile) || modelName;
        usage = data.usage || (data.cost && data.cost.usage) || null;
        runtimeMeta = extractRuntimeMetaFromAgentResponse(data);
      }

      ok = true;
      return { ok, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
    } else {
      // 直连 Worker：保持原逻辑
      const res = await fetch(WORKER_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ input: userText }),
      });
      durationMs = performance.now() - start;
      status = res.status;
      const text = await res.text();
      rawResponse = text;

      if (!res.ok) {
        return { ok: false, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
      }

      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }

      if (data) {
        replyText = data.output || "";
        modelName = data.model || modelName;
        usage = data.usage || null;
      }

      ok = true;
      return { ok, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
    }
  } catch (err) {
    durationMs = performance.now() - start;
    rawResponse = String(err || "Unknown error");
    return {
      ok: false,
      status: "network_error",
      durationMs,
      rawResponse,
      replyText: "",
      modelName,
      usage: null,
      runtimeMeta: null,
      agentRaw: null,
    };
  }
}

    // ===== PATCH END =====
  
    // === Worker 调用 ===

    /*async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMsg = createMessage(currentSessionId, "user", raw);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true);
      el.chatInput.value = "";

      const start = performance.now();
      let ok = false;
      let modelName = "gpt-5-mini";
      let usage = null;
      let outputText = "";
      lastRawResponse = "";
      lastOverview = null;

      try {
        const res = await fetch(WORKER_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: raw }),
        });

        const durationMs = performance.now() - start;

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          lastRawResponse = text || "";
          updateCallOverviewError(res.status, durationMs, null);
          updateRawJson(text || "");
          lastOverview = {
            ok: false,
            status: res.status,
            durationMs,
            modelName,
            usage: null,
          };
          showToast("Worker 调用失败，请检查 Worker 日志。");
        } else {
          const data = await res.json();
          ok = true;
          outputText = data.output || "";
          modelName = data.model || modelName;
          usage = data.usage || null;
          lastRawResponse = JSON.stringify(data, null, 2);
          updateCallOverviewSuccess(durationMs, modelName, usage);
          updateRawJson(lastRawResponse);
          lastOverview = {
            ok: true,
            status: res.status || 200,
            durationMs,
            modelName,
            usage: usage || null,
          };
        }
      } catch (err) {
        console.error(err);
        const durationMs = performance.now() - start;
        updateCallOverviewError("网络错误", durationMs, null);
        lastRawResponse = String(err || "Unknown error");
        updateRawJson(lastRawResponse);
        lastOverview = {
          ok: false,
          status: "network_error",
          durationMs,
          modelName,
          usage: null,
        };
        showToast("网络异常，无法访问 Worker。");
      } finally {
        isSending = false;
        setSendingState(false);
      }

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          outputText || "（Worker 未返回内容）"
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", outputText || "（Worker 未返回内容）", true);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();
    }*/
    // === Worker 调用 ===

    async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMeta = {
        mode: currentMode,
      };

      const userMsg = createMessage(currentSessionId, "user", raw, userMeta);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true, userMeta);
      el.chatInput.value = "";

      // ===== PATCH BEGIN: 按模式调用后端（直连 / Agent） =====
      const result = await callBackendWithMode(raw);
      const {
        ok,
        status,
        durationMs,
        rawResponse,
        replyText,
        modelName,
        usage,
        runtimeMeta,
         agentRaw, // ★ 新增
      } = result;

      lastRawResponse = rawResponse || "";
      lastOverview = {
        ok,
        status,
        durationMs,
        modelName,
        usage: usage || null,
        mode: currentMode,
        runtimeMeta: runtimeMeta || null,
      };

      if (ok) {
        updateCallOverviewSuccess(
          typeof durationMs === "number" ? durationMs : 0,
          modelName,
          usage || null
        );
      } else {
        updateCallOverviewError(
          status || "-",
          typeof durationMs === "number" ? durationMs : null,
          usage || null
        );
      }
      updateRawJson(rawResponse || "");

      if (!ok) {
        if (status === "network_error") {
          showToast("网络异常，无法访问后端。");
        } else if (currentMode === MODE_AGENT_DEVOPS) {
          showToast(`Agent 调用失败（${status}），请检查 Agent Worker 日志。`);
        } else {
          showToast(`Worker 调用失败（${status}），请检查 Worker 日志。`);
        }
      }
      // ===== PATCH END =====

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const safeReply = replyText || "（后端未返回内容）";
        const assistantMeta = {
          mode: currentMode,
          runtimeMeta: runtimeMeta || null,
          rawAgent: agentRaw || null, // ★ 新增
        };
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          safeReply,
          assistantMeta
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", safeReply, true, assistantMeta);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();

      isSending = false;
      setSendingState(false);
    }

    function deriveTitleFromText(text) {
      const trimmed = text.replace(/\s+/g, " ").trim();
      if (!trimmed) return "新会话";
      return trimmed.length > 22 ? trimmed.slice(0, 22) + "…" : trimmed;
    }

    /*function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";
      el.requestMetaHint.textContent = sending
        ? "正在调用 Cloudflare  &AI智能体…"
        : "就绪：调用 Cloudflare Worker 智能体。";
    }*/
        function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";

      if (!el.requestMetaHint) return;

      if (sending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "正在调用 Agent Runtime 智能体…"
            : "正在调用 Cloudflare Worker 智能体…";
      } else {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }
    }


function appendMessageBubble(role, content, hideEmptyHint, meta) {
  if (hideEmptyHint && el.chatEmpty.parentNode === el.chatMessages) {
    el.chatEmpty.style.display = "none";
    el.chatMessages.innerHTML = "";
  }

  const bubble = document.createElement("div");
  bubble.className = "chat-message " + role;
  bubble.textContent = content;
  el.chatMessages.appendChild(bubble);

  // ===== PATCH BEGIN: Agent Trace 可视化（仅 Agent 模式的 assistant 消息） =====
  if (
    role === "assistant" &&
    meta &&
    meta.mode === MODE_AGENT_DEVOPS &&
    meta.runtimeMeta
  ) {
    const rm = meta.runtimeMeta;

    const nodeCount =
      typeof rm.nodeCount === "number" ? rm.nodeCount : 0;
    const toolCount =
      typeof rm.toolCount === "number" ? rm.toolCount : 0;
    const ragHits =
      typeof rm.ragHits === "number" ? rm.ragHits : 0;
    const task = rm.taskType || "-";
    const traceId = rm.traceId || "-";

    const summary = document.createElement("div");
    summary.className = "agent-trace-summary";
    summary.innerHTML =
      `<strong>Agent trace</strong> · task=${task} · nodes=${nodeCount}` +
      ` · tools=${toolCount} · RAG hits=${ragHits} · trace=${traceId}（点击展开详情）`;

    const detail = document.createElement("div");
    detail.className = "agent-trace-detail";
    const lines = [];

    if (Array.isArray(rm.rawNodes) && rm.rawNodes.length) {
      lines.push("Nodes:");
      rm.rawNodes.forEach((n, idx) => {
        const label = n.name || n.id || `node_${idx + 1}`;
        const status = n.status || n.state || "done";
        lines.push(`  - ${label} [${status}]`);
      });
    }

    if (Array.isArray(rm.rawTools) && rm.rawTools.length) {
      lines.push("");
      lines.push("Tools:");
      rm.rawTools.forEach((t, idx) => {
        const name = t.name || t.tool || `tool_${idx + 1}`;
        const status = t.status || t.state || "ok";
        lines.push(`  - ${name} [${status}]`);
      });
    }

    if (rm.rawRag) {
      lines.push("");
      lines.push("RAG:");
      lines.push(`  - hits ≈ ${ragHits}`);
    }

    if (!lines.length) {
      lines.push("（Agent runtime 未返回详细 trace，仅有汇总信息。）");
    }

    detail.textContent = lines.join("\n");

    summary.addEventListener("click", () => {
      detail.classList.toggle("open");
    });

    el.chatMessages.appendChild(summary);
    el.chatMessages.appendChild(detail);
  }
  // ===== PATCH END =====
}


    function scrollToBottom() {
      requestAnimationFrame(() => {
        el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
      });
    }

    // === 调用概览 / JSON ===

    /*function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }*/
    function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      if (el.currentModelLabel) {
        el.currentModelLabel.textContent = "gpt-5-mini";
      }
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }

    /*function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }*/
    function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        applyModeUiState();
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.mode) {
        currentMode = overview.mode;
      }
      applyModeUiState();

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }

    /*function updateCallOverviewSuccess(durationMs, modelName, usage) {
      el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 成功';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      el.ovModel.textContent = modelName || "gpt-5-mini";
      const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
      el.ovPromptTokens.textContent = pt;
      el.ovCompletionTokens.textContent = ct;
      el.ovTotalTokens.textContent = tt;
    }*/
    function updateCallOverviewSuccess(durationMs, modelName, usage) {
      el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 成功';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      const modelText = modelName || "gpt-5-mini";
      el.ovModel.textContent = modelText;
      if (el.currentModelLabel) {
        el.currentModelLabel.textContent = modelText;
      }

      const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
      el.ovPromptTokens.textContent = pt;
      el.ovCompletionTokens.textContent = ct;
      el.ovTotalTokens.textContent = tt;

      applyModeUiState();
    }

    function updateCallOverviewError(status, durationMs, usage) {
      el.ovDuration.textContent =
        typeof durationMs === "number" ? `${durationMs.toFixed(0)} ms` : "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill error";
      pill.innerHTML = `<span class="call-status-dot"></span> 失败（${status}）`;
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      if (!usage) {
        el.ovPromptTokens.textContent = "-";
        el.ovCompletionTokens.textContent = "-";
        el.ovTotalTokens.textContent = "-";
      }
    }
// ===== [ADD · Step 4.2.3 · 右侧智能体信息渲染 · 复用 rawJson 面板容器] =====
function ensureAgentInfoMount() {
  // 复用你现有的右侧 JSON 容器
  if (!el.rawJsonBody) return null;
  let box = document.getElementById("agentInfoBox");
  if (!box) {
    box = document.createElement("div");
    box.id = "agentInfoBox";
    box.style.cssText = "margin-bottom:8px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;background:#f9fafb;";
    el.rawJsonBody.insertBefore(box, el.rawJsonBody.firstChild); // 放在最上面
  }
  return box;
}

function clearAgentInfo() {
  const box = document.getElementById("agentInfoBox");
  if (box && box.parentNode) box.parentNode.removeChild(box);
}

function renderAgentInfo(agentObj) {
  // 判定是否像 Agent 响应：有 reply 且有 trace/agent/env 或 state_snapshot 等字段
  const looksLikeAgent =
    agentObj && typeof agentObj === "object" &&
    (typeof agentObj.reply === "string" || agentObj.state_snapshot || agentObj.trace_id || agentObj.agent);

  if (!looksLikeAgent) {
    clearAgentInfo();
    return;
  }
  const box = ensureAgentInfoMount();
  if (!box) return;

  const traceId = agentObj.trace_id || "-";
  const agent = agentObj.agent || "-";
  const env = agentObj.env || "-";
  const taskType = agentObj?.state_snapshot?.task_type || "-";

  const nodes = Array.isArray(agentObj.nodes_executed) ? agentObj.nodes_executed : [];
  const tools = Array.isArray(agentObj.tools_used) ? agentObj.tools_used : [];
  const cost = agentObj.cost || {};

  const costLine = [
    "prompt=" + (cost.tokens_prompt ?? "-"),
    "completion=" + (cost.tokens_completion ?? "-"),
    "total=" + (cost.total_tokens ?? "-"),
    "usd≈" + (typeof cost.usd_estimate === "number" ? cost.usd_estimate.toFixed(6) : "-")
  ].join("，");

  box.innerHTML = `
    <div style="font-weight:600;margin-bottom:6px;">智能体执行摘要（Agent Mode）</div>
    <div><strong>trace_id：</strong>${traceId}</div>
    <div><strong>agent：</strong>${agent}</div>
    <div><strong>env：</strong>${env}</div>
    <div><strong>task_type：</strong>${taskType}</div>
    <div style="margin-top:6px;"><strong>执行节点：</strong>${nodes.length ? nodes.join(" → ") : "-"}</div>
    <div style="margin-top:2px;"><strong>工具调用：</strong>${tools.length ? tools.map(t => (t?.name || t?.type || "tool")).join("，") : "-"}</div>
    <div style="margin-top:2px;"><strong>Token & 成本：</strong>${costLine}</div>
  `;
}

// ===== [PATCH REPLACE · Step 4.2.3 · updateRawJson：联动智能体信息面板] =====
function updateRawJson(text) {
  if (!text) {
    lastRawResponse = "";
    el.rawJsonPlaceholder.style.display = "block";
    el.rawJsonPre.style.display = "none";
    el.rawJsonPre.textContent = "";
    clearAgentInfo(); // ★ 同时清理上方智能体信息块
    return;
  }

  // 同步 lastRawResponse，保证“复制 JSON”一致
  if (typeof text === "string") {
    lastRawResponse = text;
  } else {
    try { lastRawResponse = JSON.stringify(text, null, 2); }
    catch { lastRawResponse = String(text); }
  }

  el.rawJsonPlaceholder.style.display = "none";
  el.rawJsonPre.style.display = "block";

  let parsed = null;
  try {
    parsed = typeof text === "string" ? JSON.parse(text) : text;
    el.rawJsonPre.textContent = JSON.stringify(parsed, null, 2);
  } catch {
    el.rawJsonPre.textContent = lastRawResponse;
  }

  // ★ 尝试渲染智能体信息（仅当能解析为对象时）
  if (parsed && typeof parsed === "object") {
    renderAgentInfo(parsed);
  } else {
    clearAgentInfo();
  }
}



       // === Toast ===

    let toastTimer = null;

    function showToast(message) {
      el.toastText.textContent = message;
      el.toast.classList.add("visible");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.toast.classList.remove("visible");
      }, 2800);
    }

    function showFatalError(err) {
      console.error(err);
      showToast("初始化失败，请检查浏览器控制台。");
    }

    // === Mobile drawer logic · 仅手机端使用 ===
    (function () {
      const mainPanel  = document.querySelector(".main-panel");
      const sidebarEl  = document.querySelector(".sidebar");
      const insightEl  = document.querySelector(".insight-panel");
      const overlayEl  = document.getElementById("mobileOverlay");
      const btnSidebar = document.getElementById("btnMobileSidebarToggle");
      const btnInsight = document.getElementById("btnMobileInsightToggle");

      // 桌面端或元素缺失时，直接退出，不影响其它逻辑
      if (!mainPanel || !sidebarEl || !overlayEl || !btnSidebar || !btnInsight) return;

      let sidebarOpen = false;
      let insightOpen = false;

      function syncOverlay() {
        if (sidebarOpen || insightOpen) {
          overlayEl.classList.add("visible");
        } else {
          overlayEl.classList.remove("visible");
        }
      }

      // 左侧会话栏按钮：打开时主面板向右推
      btnSidebar.addEventListener("click", () => {
        sidebarOpen = !sidebarOpen;
        sidebarEl.classList.toggle("sidebar-open", sidebarOpen);
        mainPanel.classList.toggle("push-right", sidebarOpen);

        if (sidebarOpen) {
          // 只允许一侧打开
          insightOpen = false;
          if (insightEl) insightEl.classList.remove("insight-open");
          mainPanel.classList.remove("push-left");
        }

        syncOverlay();
      });

      // 右侧调用概览按钮：打开时主面板向左推
      btnInsight.addEventListener("click", () => {
        insightOpen = !insightOpen;
        if (insightEl) {
          insightEl.classList.toggle("insight-open", insightOpen);
        }
        mainPanel.classList.toggle("push-left", insightOpen);

        if (insightOpen) {
          sidebarOpen = false;
          sidebarEl.classList.remove("sidebar-open");
          mainPanel.classList.remove("push-right");
        }

        syncOverlay();
      });

      // 点击遮罩：关闭两边抽屉 & 还原主界面
      overlayEl.addEventListener("click", () => {
        sidebarOpen = false;
        insightOpen = false;
        sidebarEl.classList.remove("sidebar-open");
        if (insightEl) insightEl.classList.remove("insight-open");
        mainPanel.classList.remove("push-right");
        mainPanel.classList.remove("push-left");
        syncOverlay();
      });
    })();
  </script>
</body>
</html>














