<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Agent Worker 测试面板</title>
    <link rel="icon" href="AI-Agent.png" type="image/x-icon"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 锚点：紧跟在现有的 <meta name="viewport" ...> 之后、</head> 之前 -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  connect-src 'self';
  img-src 'self' data:;
  style-src 'self' 'unsafe-inline';
  script-src 'self' https://static.cloudflareinsights.com 'unsafe-inline';
  font-src 'self' data:;
  base-uri 'self';
  form-action 'self';
">
  <!-- 如需临时允许 Cloud Run 做健康检查，把上面 connect-src 改为这行（去掉注释）：
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  connect-src 'self' https://*.run.app https://agent.mefans.workers.dev;

  img-src 'self' data:;
  style-src 'self' 'unsafe-inline';
  script-src 'self' https://static.cloudflareinsights.com 'unsafe-inline';
  font-src 'self' data:;
  base-uri 'self';
  form-action 'self';
">
-->
  
<style>
  :root {
    --bg-page: #edf2ff;
    --bg-card: #ffffff;
    --bg-card-soft: #f5f7ff;
    --border-subtle: #e2e8ff;
    --border-strong: #c7d2fe;
    --text-main: #111827;
    --text-sub: #6b7280;
    --text-mute: #9ca3af;
    --accent: #4f46e5;
    --accent-soft: rgba(79, 70, 229, 0.1);
    --accent-strong: #3730a3;
    --danger: #ef4444;
    --radius-lg: 18px;
    --radius-md: 10px;
    --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.14);
    --shadow-subtle: 0 8px 20px rgba(15, 23, 42, 0.12);
    --sidebar-width: 280px;
    --insight-width: 320px;
  }
   /* ===== PATCH: 修复原始 JSON 区域背景 ===== */
    #rawJsonBody {
      background-color: transparent; /* 让它直接透出右侧卡片的底色 */
    }

  * {
    box-sizing: border-box;
  }

  html,
  body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "Segoe UI", sans-serif;
    background: radial-gradient(circle at top, #e0e7ff 0, #eef2ff 55%, #e5e7eb 100%);
    color: var(--text-main);
  }

  body {
    display: flex;
    justify-content: center;
    align-items: stretch; /* 保持整体壳子撑满高度，不再出现“中间一个窄柱子” */
    padding: 20px;
  }

  .app-shell {
    display: flex;
    flex-direction: row;
    width: min(1320px, 100%);
    height: 100%;
    max-height: 880px;
    background: linear-gradient(145deg, #f9fafb, #eef2ff);
    border-radius: 26px;
    box-shadow: var(--shadow-soft);
    overflow: hidden;
    border: 1px solid rgba(148, 163, 184, 0.45);
    position: relative;
  }

  /* 左侧：会话列表 */

  .sidebar {
    width: var(--sidebar-width);
    background: radial-gradient(circle at top left, #1e293b 0, #020617 60%);
    color: #e5e7eb;
    padding: 18px 18px 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    border-right: 1px solid rgba(148, 163, 184, 0.3);
    position: relative;
    z-index: 1;
  }

  .sidebar-header {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .sidebar-title-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-title {
    font-weight: 700;
    font-size: 18px;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-dot {
    width: 9px;
    height: 9px;
    border-radius: 999px;
    background: #22c55e;
    box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.35);
  }

  .sidebar-subtitle {
    font-size: 12px;
    color: #9ca3af;
  }

  .sidebar-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
  }

  .tag-chip {
    font-size: 11px;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.65);
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: radial-gradient(circle at top, rgba(148, 163, 184, 0.26), transparent);
  }

  .tag-chip strong {
    font-weight: 600;
  }

  .sidebar-divider {
    height: 1px;
    background: linear-gradient(to right, rgba(148, 163, 184, 0.5), transparent);
    margin-top: 6px;
  }

  .sidebar-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 4px;
  }

  .btn-new-session {
    border: none;
    border-radius: 999px;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: #f9fafb;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, background 0.1s ease-out;
  }

  .btn-new-session:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 24px rgba(79, 70, 229, 0.6);
    background: linear-gradient(135deg, #4338ca, #4f46e5);
  }

  .btn-new-session:active {
    transform: translateY(0);
    box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6);
  }

  .btn-icon {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.4);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }

  .sidebar-env {
    font-size: 11px;
    color: #9ca3af;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px dashed rgba(148, 163, 184, 0.8);
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: rgba(15, 23, 42, 0.45);
  }

  .sidebar-env-dot {
    width: 5px;
    height: 5px;
    border-radius: 999px;
    background: #22c55e;
  }

  .session-list {
    flex: 1;
    margin-top: 4px;
    padding-top: 4px;
    overflow: hidden auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .session-item {
    position: relative;
    border-radius: 12px;
    padding: 8px 9px;
    cursor: pointer;
    border: 1px solid transparent;
    background: rgba(15, 23, 42, 0.45);
    display: flex;
    flex-direction: column;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .session-item:hover {
    background: rgba(15, 23, 42, 0.7);
    border-color: rgba(148, 163, 184, 0.7);
  }

  .session-item.active {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.6), rgba(37, 99, 235, 0.6));
    border-color: #c7d2fe;
    transform: translateX(2px);
  }

  .session-header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 4px;
  }

  .session-header-left {
    display: flex;
    align-items: center;
    gap: 4px;
    flex: 1;
    min-width: 0;
  }

  .session-title {
    font-size: 13px;
    font-weight: 500;
    color: #e5e7eb;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    max-width: 160px;
  }

  .btn-rename-session {
    border: none;
    background: transparent;
    color: #9ca3af;
    font-size: 11px;
    padding: 0;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.08s ease-out, color 0.08s ease-out;
  }

  .session-item:hover .btn-rename-session {
    opacity: 1;
  }

  .btn-rename-session:hover {
    color: #e5e7eb;
  }

  .session-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
  }

  .session-tokens {
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.8);
    border: 1px solid rgba(148, 163, 184, 0.7);
    font-size: 10px;
  }

  .btn-delete-session {
    border: none;
    background: transparent;
    color: #9ca3af;
    font-size: 13px;
    padding: 0 0 0 4px;
    cursor: pointer;
    opacity: 0.0;
    transition: opacity 0.08s ease-out, color 0.08s ease-out;
  }

  .session-item:hover .btn-delete-session {
    opacity: 1;
  }

  .btn-delete-session:hover {
    color: #fecaca;
  }

  .sidebar-footer {
    margin-top: 6px;
    font-size: 11px;
    color: #6b7280;
  }

  /* 中间：聊天面板 */

  .main-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px 18px 14px;
    gap: 10px;
    position: relative;
    z-index: 0;
    align-items: stretch;        /* 关键：中间列所有子元素撑满宽度 */
    justify-content: flex-start; /* 关键：从顶部开始排布，不再“居中悬空” */
  }

  .main-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .main-header-left {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .breadcrumbs {
    font-size: 11px;
    color: var(--text-mute);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .breadcrumbs span {
    display: inline-flex;
    align-items: center;
  }

  .agent-title-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .agent-name {
    font-size: 18px;
    font-weight: 700;
  }

  .pill {
    font-size: 11px;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border-strong);
    background: var(--bg-card-soft);
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .main-header-right {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
    flex-wrap: wrap; /* 宽度不够就换行 */
  }

  .env-pill {
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px dashed #d4d4ff;
    background: rgba(219, 234, 254, 0.6);
    color: #1d4ed8;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-weight: 500;
  }

  .env-pill-dot {
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: #22c55e;
  }

  /* ===== PATCH INSERT · Agent / Env 选择器（Step 4.1） ===== */

  /* 环境 pill 保持紧凑，不被挤压 */
  .main-header-right .env-pill {
    flex-shrink: 0;
  }

  /* 下拉控件容器：一行排 label + select，本身可折行 */
  .agent-env-controls {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
    flex-wrap: wrap; /* label/select 自己也可以换行 */
  }

  .agent-env-controls label {
    opacity: 0.8;
    white-space: nowrap; /* 避免 “Call:” 被打断 */
  }

  .agent-env-select {
    border-radius: 999px;
    border: 1px solid var(--border-subtle);
    background: var(--bg-card-soft);
    padding: 2px 8px;
    font-size: 11px;
    color: var(--text-main);
    outline: none;
    flex-shrink: 0; /* 不要被挤得太窄 */
    max-width: 120px; /* 防止撑爆右边空间 */
  }

  .agent-env-select:disabled {
    opacity: 0.55;
    cursor: default;
  }

  .agent-env-select option {
    font-size: 11px;
  }

  /* Trace 折叠块：占满一行，放在 header 下方，不影响主布局 */
  .agent-trace-summary {
    margin-top: 4px;
    padding: 6px 8px;
    border-radius: 10px;
    background: rgba(37, 99, 235, 0.04);
    border: 1px dashed rgba(129, 140, 248, 0.6);
    font-size: 11px;
    color: var(--text-sub);
    cursor: pointer;
  }

  .agent-trace-summary strong {
    color: var(--accent-strong);
  }

  .agent-trace-detail {
    margin-top: 4px;
    padding: 6px 8px;
    border-radius: 8px;
    background: rgba(15, 23, 42, 0.03);
    border: 1px solid rgba(148, 163, 184, 0.4);
    font-size: 11px;
    color: var(--text-sub);
    display: none;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .agent-trace-detail.open {
    display: block;
  }

  /* 手机端：右上这一块占满一行，不挤压标题 */
  @media (max-width: 900px) {
    .main-header-right {
      width: 100%;
      justify-content: flex-start;
      align-items: flex-start;
      gap: 4px;
    }

    .agent-env-controls {
      width: 100%;
    }

    .agent-env-select {
      max-width: 100px;
    }
  }

  .chat-surface {
    flex: 1;
    border-radius: 18px;
    background: radial-gradient(circle at top left, #eef2ff 0, #f9fafb 55%);
    border: 1px solid var(--border-subtle);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.08);
    width: 100%;          /* 关键：填满中间列宽度 */
    align-self: stretch;   /* 关键：不再缩成右侧一根“细条” */
  }

  .chat-messages {
    flex: 1;
    padding: 16px 18px 12px;
    overflow: auto;
    scroll-behavior: smooth;
  }

  .chat-empty {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    color: var(--text-mute);
    text-align: center;
    font-size: 13px;
  }

  .chat-message {
    max-width: 80%;
    padding: 10px 12px;
    border-radius: 14px;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .chat-message.user {
    margin-left: auto;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    border-bottom-right-radius: 4px;
    box-shadow: 0 10px 22px rgba(79, 70, 229, 0.35);
  }

  .chat-message.assistant {
    margin-right: auto;
    background: rgba(255, 255, 255, 0.95);
    border-bottom-left-radius: 4px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
  }

  .chat-input-bar {
    border-top: 1px solid var(--border-subtle);
    padding: 10px 12px;
    background: linear-gradient(to top, rgba(249, 250, 251, 0.94), rgba(249, 250, 251, 0.9));
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;          /* 关键：输入区也铺满宽度 */
    align-self: stretch;
  }

  .chat-input-row {
    display: flex;
    gap: 8px;
    align-items: flex-end;
  }

  .chat-input {
    flex: 1;
    border-radius: 12px;
    border: 1px solid var(--border-subtle);
    padding: 8px 10px;
    resize: none;
    min-height: 42px;
    max-height: 96px;
    font-size: 14px;
    line-height: 1.4;
    outline: none;
    background: rgba(255, 255, 255, 0.96);
  }

  .chat-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.3);
  }

  .send-button {
    border: none;
    border-radius: 999px;
    padding: 9px 18px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    box-shadow: 0 10px 24px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s ease-out;
  }

  .send-button:hover:not([disabled]) {
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(79, 70, 229, 0.6);
  }

  .send-button:active:not([disabled]) {
    transform: translateY(0);
    box-shadow: 0 6px 14px rgba(31, 41, 55, 0.55);
  }

  .send-button[disabled] {
    opacity: 0.65;
    cursor: default;
    box-shadow: 0 4px 10px rgba(148, 163, 184, 0.6);
  }

  .send-button-icon {
    font-size: 14px;
    background: rgba(15, 23, 42, 0.3);
    border-radius: 999px;
    padding: 4px;
    display: inline-flex;
  }

  .input-hint-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-mute);
  }

  .input-hint-row strong {
    color: var(--text-sub);
  }

  /* 右侧：调用概览 & 原始 JSON */

  .insight-panel {
    width: var(--insight-width);
    padding: 14px 14px 12px;
    border-left: 1px solid rgba(148, 163, 184, 0.4);
    background: linear-gradient(160deg, rgba(15, 23, 42, 0.98), #020617);
    color: #e5e7eb;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .insight-card {
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    padding: 10px 11px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.8);
  }

  .insight-card h3 {
    margin: 0 0 6px;
    font-size: 13px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .insight-tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(37, 99, 235, 0.25);
    border: 1px solid rgba(129, 140, 248, 0.7);
  }

  .call-overview-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    margin-bottom: 2px;
    color: #9ca3af;
  }

  .call-overview-row span:last-child {
    color: #e5e7eb;
  }

  .call-overview-row strong {
    color: #e5e7eb;
  }

  .call-status-pill {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid rgba(52, 211, 153, 0.8);
    background: rgba(5, 150, 105, 0.2);
    color: #bbf7d0;
  }

  .call-status-pill.error {
    border-color: rgba(248, 113, 113, 0.9);
    background: rgba(127, 29, 29, 0.85);
    color: #fecaca;
  }

  .call-status-dot {
    width: 6px;
    height: 6px;
    border-radius: 999px;
    background: #22c55e;
  }

  .call-status-pill.error .call-status-dot {
    background: #f97373;
  }

  .raw-json-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
    margin-bottom: 6px;
  }

  .json-buttons {
    display: flex;
    gap: 6px;
  }

  .btn-ghost {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.7);
    font-size: 11px;
    padding: 3px 8px;
    color: #e5e7eb;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .btn-ghost:hover {
    background: rgba(15, 23, 42, 0.95);
    border-color: rgba(251, 191, 36, 0.85);
    transform: translateY(-0.5px);
  }

  .btn-ghost:active {
    transform: translateY(0);
  }

  .raw-json-body {
    position: relative;
    border-radius: 10px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    background: radial-gradient(circle at top left, rgba(17, 24, 39, 0.9), #020617);
    padding: 8px 9px;
    max-height: 160px;
    overflow: hidden;
    transition: max-height 0.18s ease-out;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
      "Courier New", monospace;
    font-size: 11px;
    color: #e5e7eb;
  }

  .raw-json-body.open {
    max-height: 260px;
    overflow: auto;
  }

  .raw-json-placeholder {
    color: #6b7280;
    font-size: 11px;
  }

  .raw-json-pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .agent-desc-list {
    list-style: none;
    padding-left: 0;
    margin: 6px 0 0;
    font-size: 11px;
    color: #9ca3af;
  }

  .agent-desc-list li {
    margin-bottom: 4px;
    display: flex;
    gap: 4px;
  }

  .agent-desc-list li span {
    color: #e5e7eb;
  }

  /* toast */

  .toast {
    position: absolute;
    right: 24px;
    bottom: 22px;
    z-index: 40;
    padding: 8px 11px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.92);
    color: #f9fafb;
    font-size: 12px;
    display: none;
    align-items: center;
    gap: 8px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(248, 250, 252, 0.22);
  }

  .toast.visible {
    display: inline-flex;
  }

  .toast-icon {
    font-size: 14px;
  }

  /* 顶部移动端按钮 & 遮罩，桌面端默认隐藏 */

  .mobile-top-bar {
    display: none;
  }

  .mobile-overlay {
    display: none;
  }

  @media (max-width: 1120px) {
    /* 中屏默认隐藏右侧面板（移动端另外覆盖） */
    .insight-panel {
      display: none;
    }
  }

  /* === 手机端布局 === */
  @media (max-width: 900px) {
    body {
      padding: 0;
    }

    .app-shell {
      border-radius: 0;
      box-shadow: none;
      max-height: none;
      height: 100%;
      overflow: hidden; /* 防止左右推时露出太大的空白 */
    }

    /* 主聊天面板：手机端左右平移 */
    .main-panel {
      padding-top: 46px; /* 给顶部两横线留空间 */
      transition: transform 0.2s ease-out;
    }

    /* 左边抽屉打开时，主面板向右推 */
    .main-panel.move-right,
    .app-shell.push-right .main-panel {
      transform: translateX(min(80%, 320px));
    }

    /* 右边抽屉打开时，主面板向左推 */
    .main-panel.move-left,
    .app-shell.push-left .main-panel {
      transform: translateX(-min(80%, 340px));
    }

    /* 顶部左右“二横线”按钮条 */
    .mobile-top-bar {
      position: fixed;
      top: 10px;
      left: 0;
      right: 0;
      padding: 0 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 40;
      pointer-events: none;
      transition: transform 0.2s ease-out;
    }

    /* 顶部两横线跟随整体移动 */
    .app-shell.push-right .mobile-top-bar {
      transform: translateX(min(80%, 320px));
    }

    .app-shell.push-left .mobile-top-bar {
      transform: translateX(-min(80%, 340px));
    }

    .mobile-toggle-btn {
      width: 34px;
      height: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      border: none;
      background: transparent;
      padding: 0;
      margin: 0;
    }

    .mobile-toggle-icon {
      position: relative;
      width: 18px;
      height: 14px;
    }

    .mobile-toggle-icon span {
      position: absolute;
      height: 2px;
      border-radius: 999px;
      background: #111827;
    }

    /* 左侧图标：两条线偏左 */
    .mobile-toggle-btn-left .mobile-toggle-icon span:nth-child(1) {
      top: 2px;
      left: 0;
      right: 8px;
    }

    .mobile-toggle-btn-left .mobile-toggle-icon span:nth-child(2) {
      bottom: 2px;
      left: 0;
      right: 3px;
    }

    /* 右侧图标：两条线偏右（镜像） */
    .mobile-toggle-btn-right .mobile-toggle-icon span:nth-child(1) {
      top: 2px;
      left: 8px;
      right: 0;
    }

    .mobile-toggle-btn-right .mobile-toggle-icon span:nth-child(2) {
      bottom: 2px;
      left: 3px;
      right: 0;
    }

    /* 遮罩层：在主界面和抽屉之间 */
    .mobile-overlay {
      display: block;
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      z-index: 25;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease-out;
    }

    .mobile-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* 左侧 sidebar 抽屉（固定在视口左边，不随主界面一起移动） */
    .sidebar {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: min(80%, 320px);
      max-width: 320px;
      transform: translateX(-100%);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      z-index: 30;
    }

    .sidebar.sidebar-open {
      transform: translateX(0);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.88);
    }

    /* 右侧 insight 抽屉（固定在视口右边） */
    .insight-panel {
      display: flex;
      position: fixed;
      top: 0;
      bottom: 0;
      right: 0;
      width: min(80%, 340px);
      max-width: 340px;
      transform: translateX(100%);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      z-index: 30;
    }

    .insight-panel.insight-open {
      transform: translateX(0);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.88);
    }
  }
</style>


  <style>
  /* ===== PATCH: 中间主区域固定在 TOP，聊天区填满剩余高度 ===== */

  /* 1）主面板：占满中间区域高度，并强制从顶部开始排布 */
  .main-panel {
    height: 100% !important;
    min-height: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: flex-start !important;  /* 标题永远贴着中间区域 top */
    align-items: stretch !important;
  }

  /* 2）聊天卡片：紧跟标题，从上往下填满剩余空间 */
  .chat-surface {
    flex: 1 1 auto !important;               /* 占满 main-panel 余下高度 */
    min-height: 0 !important;
    margin-top: 8px !important;              /* 和标题留一点间距 */
    display: flex !important;
    flex-direction: column !important;
  }

  /* 3）消息区域：在卡片内部撑开，确保下面输入区始终可见 */
  .chat-messages {
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow: auto !important;
  }

  /* 4）空状态：不再额外拉长整个中间区域，只在消息区域里居中 */
  .chat-empty {
    height: auto !important;
    flex: 1 1 auto !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }
  /* ===== PATCH END ===== */

    /* === PATCH: 让原始 JSON 区域背景与右侧卡片一致 === */
.insight-card .raw-json-body,
.insight-card .raw-json-pre,
.insight-card .raw-json-placeholder {
  background: inherit;
  color: inherit;
}

/* 细节优化：去掉白底、保留 padding/圆角/滚动 */
.insight-card .raw-json-pre {
  margin: 0;
  padding: 12px;
  border-radius: 8px;
  overflow: auto;
  white-space: pre;         /* 如果希望自动换行可改为 pre-wrap */
  line-height: 1.6;
  /* 可选：给 JSON 增加一层轻微边界感（跟你的卡片风格相近即可） */
  /* border: 1px solid var(--border-subtle); */
}

    
    /* ===== [ANCHOR ADD · Agent trace 展示样式] ===== */
.agent-trace-summary{
  margin:8px 0 4px; padding:8px; border:1px solid #e5e7eb; border-radius:8px;
  background:#f9fafb; font-size:12px; color:#4b5563; cursor:pointer;
}
.agent-trace-detail{
  display:none; white-space:pre-wrap; font:12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  background:#fff; border:1px dashed #e5e7eb; border-radius:8px; padding:8px; color:#374151;
}
.agent-trace-detail.open{ display:block; }


      /* ===== PATCH 11.26: 统一原始 JSON 区背景（避免白色块） ===== */
  .raw-json-panel textarea,
  #rawJson {
    background-color: transparent; /* 不再是白底 */
    color: var(--text-main);       /* 文本颜色跟右侧卡片保持一致 */
  }

  /* ===== PATCH 11.26-b: 统一“智能体执行摘要 / 运行健康”卡片背景 ===== */
  .raw-json-panel div[style*="background:#f8fafc"],
  .raw-json-panel div[style*="background: #f8fafc"] {
    background-color: transparent !important; /* 覆盖 inline 白底 */
  }

/* ===== PATCH: 原始返回 / 智能体摘要 / 运行健康 背景统一 ===== */
/* 1）原始 JSON 内容区域（包括「智能体执行摘要 (Agent Mode)」） */
[data-insight-raw-body],
[data-insight-raw-body] * {
  /* 强制去掉所有子节点自己的白色 / 浅灰背景，统一透到底层深色卡片 */
  background-color: transparent !important;
}

/* 2）健康信息盒子（运行健康 + 可能的其他小块） */
#healthInfoBox,
#healthInfoBox * {
  background-color: transparent !important;
}

    /* ===== PATCH: 智能体执行摘要背景统一（去掉白底） ===== */
#agentInfoBox,
#agentInfoBox * {
  background-color: transparent !important;  /* 透出 insight-card 的深色渐变 */
  color: #e5e7eb !important;                /* 字体颜色跟右侧面板保持一致 */
  border-color: rgba(148, 163, 184, 0.7) !important; /* 边框稍微深一点，避免看不见 */
}

    
/* ===== [ANCHOR ADD · 手机端主面板兜底位移（JS 拿不到宽度时）] ===== */
@media (max-width: 900px){
  .main-panel.move-left  { transform: translateX(-320px); transition: transform .25s ease; }
  .main-panel.move-right { transform: translateX( 280px); transition: transform .25s ease; }
}

</style>

  
<!-- =================
     无损补丁：追加覆盖（Option B） — 保留原始样式不变，仅通过覆盖规则确保 token 徽章不被裁切
     ================= -->
<style>
  /* ===== PATCH BEGIN: session-title / token badge safe spacing (无损覆盖) ===== */

  /* 1) session-item：保留原始 padding（8px 9px），但在补丁中用更精确的 padding & overflow 覆盖以避免徽章溢出 */
  .session-item {
    /* 原始（仅作记录，未删除）： padding: 8px 9px; */
    padding: 8px 8px 8px 9px !important;
    overflow: hidden !important; /* 防止子元素（徽章）在视觉上溢出容器边界 */
    box-sizing: border-box !important;
  }

  /* 2) session-title：不改 DOM，动态限制标题宽度，给时间/徽章留出空间 */
  .session-title {
    /* 原始（仅作记录，未删除）： max-width: 160px; */
    max-width: calc(var(--sidebar-width) - 120px) !important;
    white-space: nowrap !important;
    text-overflow: ellipsis !important;
    overflow: hidden !important;
  }

  /* 3) session-meta：保证徽章区域右对齐且不被压缩 */
  .session-meta {
    /* 原始（仅作记录，未删除）： display:flex; justify-content: space-between; ... */
    min-width: 0 !important;
    display: flex !important;
    gap: 6px !important;
    align-items: center !important;
    justify-content: flex-end !important;
  }

  /* 4) session-list：微小右侧缓冲，避免紧贴侧栏边缘导致裁切 */
  .session-list {
    /* 原始（仅作记录，未删除）： padding-top: 4px; */
    padding-right: 6px !important;
  }

  /* 5) 手机端抽屉兼容：在手机抽屉场景下提供合适的 max-width */
  @media (max-width: 900px) {
    .session-title {
      max-width: calc(min(80vw, 320px) - 120px) !important;
    }
  }

  /*
  .app-shell {
    overflow: visible !important; 仅用于调试：请谨慎启用
  }
  */

  /* ===== PATCH END ===== */
/* ===== PATCH: Agent 控制台左侧面板 · 会话列表固定高度 + 内部滚动 ===== */

/* 整个应用的左右布局 */
.agent-app-shell {
  display: flex;
  align-items: stretch;
  min-height: 100vh;              /* 左右两侧都铺满视口高度 */
}

/* 左侧控制面板容器（请对应你现在的左栏容器类名） */
.agent-sidebar {
  display: flex;
  flex-direction: column;
  flex: 0 0 280px;                /* 固定宽度，按你现在的侧栏宽度调 */
  max-width: 320px;
  min-height: 100vh;              /* 保持整块高度固定，不被内部内容挤压 */
}

/* 顶部标题 + 新建会话等区域：高度自适应但不参与滚动 */
.agent-sidebar-header,
.agent-sidebar-footer {
  flex: 0 0 auto;
}

/* 中间聊天记录列表的「容器」：负责占满剩余空间 */
.agent-sidebar-body {
  flex: 1 1 auto;
  min-height: 0;                  /* ★ 关键：允许内部 overflow，不把父元素撑高 */
  margin-top: 12px;
  display: flex;
  flex-direction: column;
}

/* 真正放一条条会话的列表元素 */
.agent-session-list {
  flex: 1 1 auto;
  min-height: 0;                  /* ★ 同样为了滚动正常工作 */
  overflow-y: auto;               /* 只在这里滚动 */
  padding-right: 4px;             /* 给滚动条留一点空隙 */
}

/* 单条会话的高度与间距微调一下，避免看起来太「挤」 */
.agent-session-item {
  flex: 0 0 auto;
  margin-bottom: 4px;
  max-width: 100%;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}

  /* ===== [PATCH] 左侧控制面板：会话列表高度 & 滚动修复 ===== */

/* 左侧整个深色面板：竖向排列，内部可以正确分配高度 */
.agent-left-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0; /* 防止子元素撑爆，便于 scroll 容器正确计算 */
}

/* 包裹会话列表的那个区域：占满剩余空间，多了就内部滚动 */
.agent-left-panel .agent-session-list {
  flex: 1 1 auto;   /* 占用左栏剩余高度 */
  min-height: 0;    /* 搭配 flex 修复高度塌陷 */
  margin-top: 16px; /* 和上面的“新建会话 / 环境”略微留白 */
  overflow-y: auto; /* 会话多的时候滚动，而不是压缩外框 */
}

/* 单条会话卡片：按内容高度渲染，不参与拉伸压缩父容器 */
.agent-left-panel .agent-session-item {
  flex: 0 0 auto;
}

  /* ===== [PATCH] 会话列表固定高度 + 内部滚动，防止被挤压 ===== */

/* 按你之前的结构，这个容器一般是 #sessionList，如果你是别的 id，就对应替换一下 */
#sessionList {
  /* 保持原有布局属性的前提下，补上下面几个关键属性 */
  max-height: calc(100vh - 220px); /* 这里的 220 你可以微调，保证底部留出输入区空间 */
  overflow-y: auto;                /* 会话变多时滚动，而不是压扁 item */
}

/* 会话条目本身禁止被 flex 挤压，始终用自身高度 */
#sessionList > * {
  flex: 0 0 auto;
}

  /* ===== PATCH · 侧栏会话列表防压缩（统一放大到列表滚动） ===== */
.sidebar {
  /* 保证左侧整块高度固定，由内部 scroll，而不是被子元素向下撑破 */
  min-height: 0;
}

.session-list {
  /* 会话区域占满 sidebar 剩余高度，多出来的内容内部滚动 */
  flex: 1 1 auto !important;
  min-height: 0 !important;
  overflow-y: auto !important;
}

/* 每条会话卡片按照自身高度渲染，禁止被 flex 折叠压扁 */
.session-list > .session-item {
  flex: 0 0 auto !important;
}

  
</style>

</head>
<body>
  <div class="app-shell">
    <!-- 手机端顶部左右菜单按钮 -->
    <div class="mobile-top-bar">
      <button class="mobile-toggle-btn mobile-toggle-btn-left" id="btnMobileSidebar" aria-label="展开会话列表">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
      <button class="mobile-toggle-btn mobile-toggle-btn-right" id="btnMobileInsight" aria-label="展开调用概览">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
    </div>

    <!-- 左侧：会话列表 -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title-row">
          <div class="sidebar-title">
            <span class="status-dot"></span>
            Agent Worker 控制台
          </div>
        </div>
        <div class="sidebar-subtitle">本地对接 · Cloudflare &AI 智能体</div>
        <div class="sidebar-tags">
          <div class="tag-chip"><strong>Agent</strong> worker-agent</div>
          <div class="tag-chip"><strong>Model</strong> gpt-5-mini</div>
          <div class="tag-chip"><strong>Route</strong> Worker → OpenAI Chat</div>
        </div>
        <div class="sidebar-divider"></div>
      </div>

      <div class="sidebar-actions">
        <button class="btn-new-session" id="btnNewSession">
          <span class="btn-icon">＋</span>
          新建会话
        </button>
        <div class="sidebar-env">
          <span class="sidebar-env-dot"></span>
          环境：Dev
        </div>
      </div>

      <div class="session-list" id="sessionList">
        <!-- JS 渲染会话 -->
      </div>

      <div class="sidebar-footer">
        本页面仅作 <strong>AI 智能体链路测试</strong>，不保存服务端日志。
      </div>
    </aside>

    <!-- 中间：主聊天区域 -->
    <main class="main-panel">
      <div class="main-header">
        <div class="main-header-left">
          <div class="breadcrumbs">
            <span>Agent Worker 测试面板</span>
            <span>·</span>
            <span>前端 → Cloudflare  → OpenAI Chat Completions</span>
          </div>
          <div class="agent-title-row">
            <div class="agent-name">Agent Worker 测试面板</div>
            <div class="pill">
              <span>Agent:</span>
              <strong id="currentAgentLabel">worker-agent</strong>
            </div>
            <div class="pill">
              <span>模型:</span>
              <strong id="currentModelLabel">gpt-5-mini</strong>
            </div>
          </div>
        </div>
            <!--
        <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span>Worker: AI Agent</span>
          </div>
        </div>
        -->
               <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span id="routeLabel">模式：直连 Worker</span>
          </div>

          <!-- ===== PATCH BEGIN: Agent / Env 选择控件（Step 4.1） ===== -->
          <div class="agent-env-controls">
            <label for="modeSelect">Call:</label>
            <select id="modeSelect" class="agent-env-select">
              <option value="direct">直连 Worker</option>
              <option value="agent-devops">Agent · devops</option>
            </select>

            <label for="agentSelect">Agent:</label>
            <select id="agentSelect" class="agent-env-select">
              <option value="devops">devops</option>
            </select>

            <label for="envSelect">Env:</label>
            <select id="envSelect" class="agent-env-select">
              <option value="dev">Dev</option>
              <option value="prod" disabled>Prod（预留）</option>
            </select>
          </div>
          <!-- ===== PATCH END ===== -->
       </div>
      </div>

      <section class="chat-surface">
        <div class="chat-messages" id="chatMessages">
          <div class="chat-empty" id="chatEmpty">
            <div>这里会显示你和 Worker 智能体的对话记录。</div>
            <div>试试输入：<strong>「帮我把下面的报错信息按原因拆解一下」</strong>。</div>
          </div>
        </div>

        <div class="chat-input-bar">
          <div class="chat-input-row">
            <textarea
              id="chatInput"
              class="chat-input"
              placeholder="在这里输入：比如『帮我总结一下今天要做的三件事』，然后按 Ctrl+Enter 或点击发送。"
            ></textarea>
            <button id="btnSend" class="send-button">
              <span class="send-button-icon">↗</span>
              <span id="btnSendLabel">发送</span>
            </button>
          </div>
          <div class="input-hint-row">
            <span>支持多行输入。<strong>Ctrl+Enter</strong> 发送。</span>
            <span id="requestMetaHint">就绪：调用 Cloudflare   &AI智能体。</span>
          </div>
        </div>
      </section>

      <div class="toast" id="toast">
        <span class="toast-icon">⚠️</span>
        <span id="toastText">错误信息</span>
      </div>
    </main>

    <!-- 右侧：调用概览 -->
    <aside class="insight-panel">
      <div class="insight-card">
        <h3>
          调用概览
          <span class="insight-tag">最近一次</span>
        </h3>
        <div class="call-overview-row">
          <span>耗时</span>
          <span id="ovDuration">-</span>
        </div>
        <div class="call-overview-row">
          <span>状态</span>
          <span id="ovStatus">
            <span class="call-status-pill">
              <span class="call-status-dot"></span>
              尚未调用
            </span>
          </span>
        </div>
        <div class="call-overview-row">
          <span>模型</span>
          <span id="ovModel">gpt-5-mini</span>
        </div>
        <div class="call-overview-row">
          <span>Prompt tokens</span>
          <span id="ovPromptTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Completion tokens</span>
          <span id="ovCompletionTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Total tokens</span>
          <span id="ovTotalTokens">-</span>
        </div>
      </div>

      <div class="insight-card">
        <div class="raw-json-header">
          <span>原始返回</span>
          <div class="json-buttons">
            <button class="btn-ghost" id="btnToggleJson">展开 JSON</button>
            <button class="btn-ghost" id="btnCopyJson">复制</button>
          </div>
        </div>
        <div class="raw-json-body" id="rawJsonBody">
          <div class="raw-json-placeholder" id="rawJsonPlaceholder">
            尚未调用。调用后这里会显示 Worker 与 OpenAI 返回的完整 JSON。
          </div>
          <pre class="raw-json-pre" id="rawJsonPre" style="display:none;"></pre>
        </div>
      </div>

      <div class="insight-card">
        <h3>
          智能体说明
          <span class="insight-tag">worker-agent · Dev</span>
        </h3>
        <ul class="agent-desc-list">
          <li>· <span>职责：</span>验证 Cloudflare  → OpenAI gpt-5-mini 聊天链路。</li>
          <li>· <span>能力：</span>回答自然语言问题，展示模型与 tokens 信息。</li>
          <li>· <span>限制：</span>不访问业务数据库、不执行写操作工具调用。</li>
          <li>· <span>适用场景：</span>本地联调、链路健康检查、最小可用智能体测试。</li>
        </ul>
      </div>
    </aside>

    <!-- 移动端遮罩 -->
    <div class="mobile-overlay" id="mobileOverlay"></div>
  </div>

  <script>

      // === Config ===
    // 与 CF Route: oliverfr.com/agent.mefans.workers.dev/* 对齐
//const WORKER_ENDPOINT = "/agent.mefans.workers.dev/"; // ← 错
//const AGENT_ENDPOINT  = "/agent.mefans.workers.dev/api/agent"; // ← 错
//const WORKER_ENDPOINT = "https://agent.mefans.workers.dev/";// Worker 子域
const WORKER_ENDPOINT = "/agent/";              // 直连 Worker 绑定到 oliverfr.com/agent/*
//11.25新增在“端点常量”下面新增一个端点守护函数
    //const AGENT_ENDPOINT  = "/api/agent";    
    // ===== PATCH BEGIN: Agent 模式后端端点常量 / Step 4.1 =====
 //  const AGENT_ENDPOINT = "https://agent.mefans.workers.dev/api/agent";
const AGENT_ENDPOINT  = "/agent/api/agent";     // Agent Runtime 路由 默认同源相对路径
// ✅ 同源路由（与你的 CF Route: oliverfr.com/agent/* 对齐）
//const WORKER_ENDPOINT = "https://oliverfr.com/agent/";
//const AGENT_ENDPOINT  = WORKER_ENDPOINT + "api/agent";
// 或者在 agent-test.html 里用：const AGENT_ENDPOINT = "/agent/api/agent";

    // 若以后有人误填 Cloud Run 域名，统一拦截到 Worker 代理
//const BLOCKLIST_HOST_RE = /\.run\.app$/i;
    // ===== PATCH ADD · 端点守护（避免误连 Cloud Run）=====
// 端点解析：始终返回一个“可安全直连”的绝对 URL。
// 规则：
// 1) 若 AGENT_ENDPOINT 指向 *.run.app，则强制走 Worker 代理 /api/agent（规避 CSP/connect-src: 'self' 限制）。
// 2) 支持三种写法：绝对地址(https://...)、站内绝对路径(/api/agent)、相对路径(agent/api/agent)。
// 3) 任何解析异常一律回退 Worker 代理。
// 依赖：已定义的 WORKER_ENDPOINT 与 AGENT_ENDPOINT。
// 解析并“强制同源”的端点解析器
/*function resolveAgentEndpoint() {
  try {
    // 统一把相对路径转换为绝对 URL（基于当前页面）
    const currentOrigin = window.location.origin;
    const parsedAgent = new URL(AGENT_ENDPOINT, currentOrigin);

    // 1) 命中 *.run.app -> 强制走 Worker 代理
    if (BLOCKLIST_HOST_RE.test(parsedAgent.hostname)) {
      console.warn("[Agent] AGENT_ENDPOINT 指向 Cloud Run，已切回同源 Worker 代理。");
      const workerBase = new URL(WORKER_ENDPOINT, currentOrigin);
      return new URL("api/agent", workerBase).toString();
    }  

    // 2) 非同源（任何跨域） -> 也强制走 Worker 代理，避免 CSP/CORS
    if (parsedAgent.origin !== currentOrigin) {
      console.warn("[Agent] 检测到跨域端点，已切回同源 Worker 代理以满足 CSP。");
      const workerBase = new URL(WORKER_ENDPOINT, currentOrigin);
      return new URL("api/agent", workerBase).toString();
    }

    // 3) 已是同源 -> 直接使用
    return parsedAgent.toString();
  } catch (e) {
    // 兜底：解析异常也走 Worker 代理
    const workerBase = new URL(WORKER_ENDPOINT, window.location.origin);
    return new URL("api/agent", workerBase).toString();
  }
}*/

    // ===== 端点守护：一律经由 Worker 代理 =====
function resolveAgentEndpoint() {
  // 永远返回同源的 /agent/api/agent，避免误连 Cloud Run、避开 CSP/CORS
  try {
    const u = new URL(AGENT_ENDPOINT, window.location.origin);
    const host = u.hostname;
    // 防呆：哪怕有人误把 AGENT_ENDPOINT 改成了完整 run.app，也强制回退到同源代理
    if (host.endsWith('.run.app')) {
      console.warn('[Agent] 发现指向 Cloud Run，已改为同源 Worker 代理。');
      return new URL('/agent/api/agent', window.location.origin).toString();
    }
    return u.toString();
  } catch {
    return new URL('/agent/api/agent', window.location.origin).toString();
  }
}

// （可选）在页面初始化时给出一次温和提示，便于你排查 CSP
function warnIfLikelyCspBlock() {
  try {
    const agentOrigin = new URL(resolveAgentEndpoint()).origin;
    if (agentOrigin !== window.location.origin) {
      console.info(
        "[CSP 提示] 当前页面可能是 connect-src 'self'，跨域连接会被拦截。" +
        "如遇到报错，请在站点 CSP 的 connect-src 中加入：", agentOrigin
      );
    }
  } catch {}
}
document.addEventListener('DOMContentLoaded', warnIfLikelyCspBlock);


    const MODE_DIRECT = "direct";
    const MODE_AGENT_DEVOPS = "agent-devops";

    const AGENT_PROFILES = [
      { id: "devops", label: "devops · DevOps Agent" },
      // 后续可以扩展 cs / analytics 等
    ];

    const ENV_PROFILES = [
      { id: "dev", label: "Dev" },
      { id: "prod", label: "Prod", disabled: true }, // 预留
    ];
    // ===== PATCH END =====
    //只是在前端把结构“写死”出来，方便后面取值
  // ===== [ADD · Step 4.2.1 · Agent Runtime response shape] =====
/**
 * @typedef {Object} AgentCost
 * @property {number} tokens_prompt
 * @property {number} tokens_completion
 * @property {number} total_tokens
 * @property {number} usd_estimate
 *
 * @typedef {Object} AgentStateSnapshot
 * @property {string} task_type
 * @property {string[]} guard_flags
 * @property {string[]} degrade_flags
 * @property {Object<string, any>} [extra]
 *
 * @typedef {Object} AgentResponse
 * @property {string} reply
 * @property {string} trace_id
 * @property {string} agent
 * @property {string} env
 * @property {string[]} nodes_executed
 * @property {any[]} tools_used
 * @property {AgentCost} cost
 * @property {AgentStateSnapshot} state_snapshot
 * @property {Object<string, any>} [debug]
 */

    
    const DB_NAME = "agentWorkerDB";
    const DB_VERSION = 1;
    const SESSION_STORE = "sessions"; // 静态桶：会话 + 右侧 overview
    const MESSAGE_STORE = "messages"; // 动态桶：消息流水
    const MAX_SESSIONS = 50;

    const LS_SESSIONS_KEY = "agentWorker:sessions";
    const LS_MESSAGES_KEY = "agentWorker:messages";

    // === State ===
    let dbPromise = null;
    let useIndexedDB = true;
    let sessions = [];
    let currentSessionId = null;
    let isSending = false;
    let lastRawResponse = "";
// ===== PATCH BEGIN: Agent 模式前端状态 / Step 4.1 =====
    // 当前调用模式：直连 Worker / Agent Runtime
    let currentMode = MODE_DIRECT;
    // 当前 Agent profile（截图中的 devops / cs / analytics 之一，这里先只实现 devops）
    let currentAgentId = "devops";
    // 当前环境：Dev / Prod
    let currentEnvId = "dev";
    // 用于 /api/agent 的 user_id（延迟初始化，写入 localStorage）
    let currentUserId = null;
    // ===== PATCH END =====
        // 移动端抽屉状态（左右）
    let isSidebarOpenMobile = false;
    let isInsightOpenMobile = false;

    let lastOverview = null;
    let currentMobilePanel = null;

    const el = {};

    document.addEventListener("DOMContentLoaded", () => {
      cacheDom();
      bindGlobalEvents();
      initApp();
    });

    async function initApp() {
      try {
        await initIndexedDB();
        await initSessions();
          // ===== PATCH BEGIN: 初始化 Agent 模式 UI 状态 / Step 4.1 =====
        currentUserId = getOrInitUserId();
        applyModeUiState();
        // [INSERT after applyModeUiState();]
//await refreshHealthPanel();

        // ===== PATCH END =====
      } catch (err) {
        showFatalError(err);
      }
    }

    function cacheDom() {
      el.appShell = document.querySelector(".app-shell");
       el.mainPanel = document.querySelector(".main-panel");   // ★ 新增：主聊天面板引用
      
      el.sessionList = document.getElementById("sessionList");
      el.btnNewSession = document.getElementById("btnNewSession");
      el.chatMessages = document.getElementById("chatMessages");
      el.chatEmpty = document.getElementById("chatEmpty");
      el.chatInput = document.getElementById("chatInput");
      el.btnSend = document.getElementById("btnSend");
      el.btnSendLabel = document.getElementById("btnSendLabel");
      el.requestMetaHint = document.getElementById("requestMetaHint");
//11.23新增step4.1
            el.currentAgentLabel = document.getElementById("currentAgentLabel");
      el.currentModelLabel = document.getElementById("currentModelLabel");
      el.routeLabel = document.getElementById("routeLabel");
      el.modeSelect = document.getElementById("modeSelect");
      el.agentSelect = document.getElementById("agentSelect");
      el.envSelect = document.getElementById("envSelect");

      el.ovDuration = document.getElementById("ovDuration");
      el.ovStatus = document.getElementById("ovStatus");
      el.ovModel = document.getElementById("ovModel");
      el.ovPromptTokens = document.getElementById("ovPromptTokens");
      el.ovCompletionTokens = document.getElementById("ovCompletionTokens");
      el.ovTotalTokens = document.getElementById("ovTotalTokens");

      el.rawJsonBody = document.getElementById("rawJsonBody");
      el.rawJsonPlaceholder = document.getElementById("rawJsonPlaceholder");
      el.rawJsonPre = document.getElementById("rawJsonPre");
      el.btnToggleJson = document.getElementById("btnToggleJson");
      el.btnCopyJson = document.getElementById("btnCopyJson");

      el.toast = document.getElementById("toast");
      el.toastText = document.getElementById("toastText");

            // 移动端抽屉相关（顶栏 + 遮罩 + 左右抽屉 + 整体容器）
      el.appShell = document.querySelector(".app-shell");
      el.mobileTopBar = document.querySelector(".mobile-top-bar");
      el.mobileOverlay = document.getElementById("mobileOverlay");
      el.btnToggleSidebar = document.getElementById("btnToggleSidebar");
      el.btnToggleInsight = document.getElementById("btnToggleInsight");
      el.sidebar = document.querySelector(".sidebar");
      el.insightPanel = document.querySelector(".insight-panel");

      el.btnMobileSidebar = document.getElementById("btnMobileSidebar");
      el.btnMobileInsight = document.getElementById("btnMobileInsight");
      el.mobileOverlay = document.getElementById("mobileOverlay");
    }

    function bindGlobalEvents() {
//11.23新增step4.1
       // ===== PATCH BEGIN: Agent / Env 控件事件绑定 =====
      if (el.modeSelect) {
        el.modeSelect.addEventListener("change", () => {
          const value = el.modeSelect.value === MODE_AGENT_DEVOPS ? MODE_AGENT_DEVOPS : MODE_DIRECT;
          currentMode = value;
          applyModeUiState();
        });
      }

      if (el.agentSelect) {
        el.agentSelect.addEventListener("change", () => {
          currentAgentId = el.agentSelect.value || "devops";
          applyModeUiState();
        });
      }

      if (el.envSelect) {
        el.envSelect.addEventListener("change", () => {
          currentEnvId = el.envSelect.value || "dev";
          applyModeUiState();
        });
      }
      // ===== PATCH END =====
      // ===== 移动端左右抽屉：两条横线菜单 =====
      if (el.btnToggleSidebar) {
        el.btnToggleSidebar.addEventListener("click", () => {
          const willOpen = !isSidebarOpenMobile;
          isSidebarOpenMobile = willOpen;

          if (el.sidebar) {
            el.sidebar.classList.toggle("sidebar-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-right", willOpen);
            // 打开左侧时，确保右侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-left");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-right", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-left");
            }
          }
          if (willOpen && isInsightOpenMobile) {
            // 左侧打开时，顺便关掉右侧抽屉
            isInsightOpenMobile = false;
            if (el.insightPanel) {
              el.insightPanel.classList.remove("insight-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.btnToggleInsight) {
        el.btnToggleInsight.addEventListener("click", () => {
          const willOpen = !isInsightOpenMobile;
          isInsightOpenMobile = willOpen;

          if (el.insightPanel) {
            el.insightPanel.classList.toggle("insight-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-left", willOpen);
            // 打开右侧时，确保左侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-right");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-left", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-right");
            }
          }
          if (willOpen && isSidebarOpenMobile) {
            isSidebarOpenMobile = false;
            if (el.sidebar) {
              el.sidebar.classList.remove("sidebar-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          // 点击遮罩：统一关闭左右抽屉 & 复位整体 transform
          isSidebarOpenMobile = false;
          isInsightOpenMobile = false;

          if (el.sidebar) {
            el.sidebar.classList.remove("sidebar-open");
          }
          if (el.insightPanel) {
            el.insightPanel.classList.remove("insight-open");
          }
          if (el.appShell) {
            el.appShell.classList.remove("push-right", "push-left");
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.remove("push-right", "push-left");
          }
          updateMobileOverlay();
        });
      }

      el.btnNewSession.addEventListener("click", () => {
        handleNewSession();
      });

      el.sessionList.addEventListener("click", (event) => {
        const target = event.target;
        const item = target.closest("[data-session-id]");
        if (!item) return;

        const id = item.getAttribute("data-session-id");
        const deleteBtn = target.closest("[data-action='delete-session']");
        const renameBtn = target.closest("[data-action='rename-session']");

        if (deleteBtn) {
          event.stopPropagation();
          handleDeleteSession(id);
          return;
        }

        if (renameBtn) {
          event.stopPropagation();
          handleRenameSession(id);
          return;
        }

        selectSession(id);
      });

      el.btnSend.addEventListener("click", () => {
        triggerSend();
      });

      el.chatInput.addEventListener("keydown", (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          triggerSend();
        }
      });

      el.btnToggleJson.addEventListener("click", () => {
        const isOpen = el.rawJsonBody.classList.toggle("open");
        el.btnToggleJson.textContent = isOpen ? "收起 JSON" : "展开 JSON";
      });

      el.btnCopyJson.addEventListener("click", async () => {
        if (!lastRawResponse) {
          showToast("当前没有可复制的 JSON");
          return;
        }
        try {
          await navigator.clipboard.writeText(lastRawResponse);
          showToast("已复制 JSON 到剪贴板");
        } catch (err) {
          console.error(err);
          showToast("复制失败，请检查浏览器权限");
        }
      });

      if (el.btnMobileSidebar) {
        el.btnMobileSidebar.addEventListener("click", () => {
          toggleMobilePanel("left");
        });
      }

      if (el.btnMobileInsight) {
        el.btnMobileInsight.addEventListener("click", () => {
          toggleMobilePanel("right");
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          closeMobilePanels();
        });
      }

      window.addEventListener("resize", () => {
        if (!isMobileViewport()) {
          closeMobilePanels();
        }
      });
    }
    //在 bindGlobalEvents 下面加一个小 helper
    // 控制遮罩显示：只要有任一抽屉打开就显示
    function updateMobileOverlay() {
      if (!el.mobileOverlay) return;
      const visible = isSidebarOpenMobile || isInsightOpenMobile;
      if (visible) {
        el.mobileOverlay.classList.add("visible");
      } else {
        el.mobileOverlay.classList.remove("visible");
      }
    }

    function isMobileViewport() {
      return window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
    }

     function toggleMobilePanel(target) {
      if (!isMobileViewport()) return;
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (!sidebar || !insight || !el.appShell || !el.mainPanel) return;

      const isSame = currentMobilePanel === target;
      if (isSame) {
        closeMobilePanels();
        return;
      }

      // 打开任意一侧前，先清理主面板的内联 transform，避免残留
      el.mainPanel.style.transform = "";

      if (target === "left") {
        // 左侧：保持现有行为不变
        sidebar.classList.add("sidebar-open");
        insight.classList.remove("insight-open");

        el.appShell.classList.add("push-right");
        el.appShell.classList.remove("push-left");

        el.mainPanel.classList.add("move-right");
        el.mainPanel.classList.remove("move-left");

        currentMobilePanel = "left";
      } else if (target === "right") {
        // 右侧：抽屉滑出 + 主面板整体向左推
        insight.classList.add("insight-open");
        sidebar.classList.remove("sidebar-open");

        el.appShell.classList.add("push-left");
        el.appShell.classList.remove("push-right");

        // ★ 关键：用右侧抽屉的实际宽度来平移主面板，避免“纯覆盖”
        const drawerWidth = insight.offsetWidth || 0;
        if (drawerWidth > 0) {
          el.mainPanel.style.transform = `translateX(-${drawerWidth}px)`;
        } else {
          // 兜底：偶尔拿不到宽度时，还可以退回 CSS class 方案
          el.mainPanel.classList.add("move-left");
        }
        el.mainPanel.classList.remove("move-right");

        currentMobilePanel = "right";
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.classList.add("visible");
      }
    }



    function closeMobilePanels() {
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (sidebar) sidebar.classList.remove("sidebar-open");
      if (insight) insight.classList.remove("insight-open");

      if (el.appShell) {
        el.appShell.classList.remove("push-right", "push-left");
      }

      if (el.mainPanel) {
        el.mainPanel.classList.remove("move-right", "move-left");
        el.mainPanel.style.transform = ""; // ★ 清掉右侧打开时设置的内联位移
      }

      currentMobilePanel = null;
      if (el.mobileOverlay) {
        el.mobileOverlay.classList.remove("visible");
      }
    }


    // === IndexedDB + localStorage 封装 ===

    async function initIndexedDB() {
      if (!("indexedDB" in window)) {
        useIndexedDB = false;
        console.warn("[IndexedDB] 不支持，自动使用 localStorage。");
        return;
      }

      try {
        dbPromise = new Promise((resolve, reject) => {
          let request;
          try {
            request = indexedDB.open(DB_NAME, DB_VERSION);
          } catch (err) {
            reject(err);
            return;
          }

          request.onerror = () => {
            reject(request.error || new Error("indexedDB open error"));
          };

          request.onsuccess = () => {
            resolve(request.result);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(SESSION_STORE)) {
              const sessionStore = db.createObjectStore(SESSION_STORE, { keyPath: "id" });
              sessionStore.createIndex("updatedAt", "updatedAt", { unique: false });
            }
            if (!db.objectStoreNames.contains(MESSAGE_STORE)) {
              const messageStore = db.createObjectStore(MESSAGE_STORE, { keyPath: "id" });
              messageStore.createIndex("sessionId", "sessionId", { unique: false });
            }
          };
        });

        await dbPromise;
      } catch (err) {
        console.warn("[IndexedDB] 初始化失败，自动切换 localStorage。", err);
        dbPromise = null;
        useIndexedDB = false;
      }
    }

    function dbReadAll(storeName, indexName, query, direction = "prev") {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readonly");
              let store = tx.objectStore(storeName);
              if (indexName) {
                store = store.index(indexName);
              }
              const items = [];
              const req = store.openCursor(query, direction);
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  items.push(cursor.value);
                  cursor.continue();
                } else {
                  resolve(items);
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbPut(storeName, value) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.put(value);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDelete(storeName, key) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.delete(key);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDeleteWhereMessages(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readwrite");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.openCursor(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  cursor.delete();
                  cursor.continue();
                } else {
                  resolve();
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbReadMessagesBySession(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readonly");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.getAll(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve(req.result || []);
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    async function loadSessionsFromStorage() {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadAll(SESSION_STORE, "updatedAt");
        } catch (err) {
          console.warn("[IndexedDB] 读取 sessions 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_SESSIONS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        console.warn("[localStorage] 读取 sessions 失败。", err);
        return [];
      }
    }

    async function loadMessagesFromStorage(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadMessagesBySession(sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 读取 messages 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.filter((m) => m.sessionId === sessionId);
      } catch (err) {
        console.warn("[localStorage] 读取 messages 失败。", err);
        return [];
      }
    }

    async function saveSession(session) {
      // 先确保内存 sessions 更新
      const idx = sessions.findIndex((s) => s.id === session.id);
      if (idx === -1) sessions.push(session);
      else sessions[idx] = session;

      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(SESSION_STORE, session);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 session 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
      } catch (err) {
        console.warn("[localStorage] 写入 sessions 失败。", err);
      }
    }

    async function saveMessage(message) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(MESSAGE_STORE, message);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 message 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        const arr = raw ? (JSON.parse(raw) || []) : [];
        arr.push(message);
        localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arr));
      } catch (err) {
        console.warn("[localStorage] 写入 messages 失败。", err);
      }
    }

    async function deleteSessionAndMessages(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbDeleteWhereMessages(sessionId);
          await dbDelete(SESSION_STORE, sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 删除会话失败，尝试 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          const rawS = localStorage.getItem(LS_SESSIONS_KEY);
          let arrS = rawS ? JSON.parse(rawS) : [];
          if (Array.isArray(arrS)) {
            arrS = arrS.filter((s) => s.id !== sessionId);
            localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(arrS));
          }
          const rawM = localStorage.getItem(LS_MESSAGES_KEY);
          let arrM = rawM ? JSON.parse(rawM) : [];
          if (Array.isArray(arrM)) {
            arrM = arrM.filter((m) => m.sessionId !== sessionId);
            localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arrM));
          }
        } catch (err) {
          console.warn("[localStorage] 删除会话失败。", err);
        }
      }
    }

    // === Session / message model ===

    function createSessionObject() {
      const id = crypto.randomUUID ? crypto.randomUUID() : "s_" + Date.now();
      const ts = Date.now();
      return {
        id,
        title: "新会话",
        createdAt: ts,
        updatedAt: ts,
        totalTokens: 0,
        isEmpty: true,
        lastCallOverview: null,
        lastRawJson: "",
      };
    }

    /*function createMessage(sessionId, role, content) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
      };
    }*/
        function createMessage(sessionId, role, content, meta) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
        meta: meta || null,
      };
    }


    async function initSessions() {
      let stored = await loadSessionsFromStorage();
      if (!stored || stored.length === 0) {
        const session = createSessionObject();
        sessions = [session];
        currentSessionId = session.id;
        await saveSession(session);
      } else {
        sessions = stored;
        currentSessionId = sessions[0].id;
      }
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    function formatShortTime(timestamp) {
      if (!timestamp) return "-";
      const d = new Date(timestamp);
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }

    function renderSessionList() {
      el.sessionList.innerHTML = "";
      sessions.forEach((session) => {
        const item = document.createElement("div");
        item.className = "session-item" + (session.id === currentSessionId ? " active" : "");
        item.setAttribute("data-session-id", session.id);

        const headerRow = document.createElement("div");
        headerRow.className = "session-header-row";

        const headerLeft = document.createElement("div");
        headerLeft.className = "session-header-left";

        const titleSpan = document.createElement("div");
        titleSpan.className = "session-title";
        titleSpan.textContent = session.title || "未命名会话";

        const renameBtn = document.createElement("button");
        renameBtn.className = "btn-rename-session";
        renameBtn.setAttribute("data-action", "rename-session");
        renameBtn.textContent = "✎";

        headerLeft.appendChild(titleSpan);
        headerLeft.appendChild(renameBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-delete-session";
        deleteBtn.setAttribute("data-action", "delete-session");
        deleteBtn.textContent = "×";

        headerRow.appendChild(headerLeft);
        headerRow.appendChild(deleteBtn);

        const metaRow = document.createElement("div");
        metaRow.className = "session-meta";

        const timeSpan = document.createElement("span");
        timeSpan.textContent = formatShortTime(session.updatedAt);

        const tokenSpan = document.createElement("span");
        tokenSpan.className = "session-tokens";
        tokenSpan.textContent = `${session.totalTokens || 0} tokens`;

        metaRow.appendChild(timeSpan);
        metaRow.appendChild(tokenSpan);

        item.appendChild(headerRow);
        item.appendChild(metaRow);

        el.sessionList.appendChild(item);
      });
    }

    async function selectSession(sessionId) {
      if (!sessionId) return;
      if (sessionId === currentSessionId) {
        if (isMobileViewport()) closeMobilePanels();
        return;
      }
      currentSessionId = sessionId;
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
      if (isMobileViewport()) closeMobilePanels();
    }

    async function renderCurrentSessionMessages() {
      if (!currentSessionId) return;
      const messages = await loadMessagesFromStorage(currentSessionId);
      if (!messages || messages.length === 0) {
        el.chatMessages.innerHTML = "";
        el.chatMessages.appendChild(el.chatEmpty);
        el.chatEmpty.style.display = "flex";
        return;
      }
      el.chatMessages.innerHTML = "";
    /*  messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false);
        });*/

            messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false, msg.meta || null);
        });

      scrollToBottom();
    }

    async function handleNewSession() {
      const existingEmpty = sessions.find((s) => s.isEmpty);
      if (existingEmpty) {
        currentSessionId = existingEmpty.id;
        renderSessionList();
        await renderCurrentSessionMessages();
        hydrateCurrentSessionInsights();
        if (isMobileViewport()) closeMobilePanels();
        return;
      }

      const session = createSessionObject();
      sessions.unshift(session);
      currentSessionId = session.id;
      await saveSession(session);
      await cleanupOldSessionsIfNecessary();

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleDeleteSession(sessionId) {
      if (!sessionId) return;

      await deleteSessionAndMessages(sessionId);

      sessions = sessions.filter((s) => s.id !== sessionId);

      if (sessions.length === 0) {
        const newSession = createSessionObject();
        sessions = [newSession];
        currentSessionId = newSession.id;
        await saveSession(newSession);
      } else if (currentSessionId === sessionId) {
        currentSessionId = sessions[0].id;
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 同步 sessions 失败。", e);
        }
      }

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleRenameSession(sessionId) {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) return;
      const newTitle = window.prompt("请输入会话标题：", session.title || "");
      if (newTitle === null) return;
      const trimmed = newTitle.trim();
      session.title = trimmed || "未命名会话";
      session.updatedAt = Date.now();
      await saveSession(session);
      renderSessionList();
    }

    async function cleanupOldSessionsIfNecessary() {
      if (sessions.length <= MAX_SESSIONS) return;
      const sorted = [...sessions].sort((a, b) => b.updatedAt - a.updatedAt);
      const keep = sorted.slice(0, MAX_SESSIONS);
      const remove = sorted.slice(MAX_SESSIONS);

      sessions = keep;

      for (const s of remove) {
        await deleteSessionAndMessages(s.id);
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 清理 sessions 时同步失败。", e);
        }
      }
    }
//11.23新增step4.1相关的4段函数
        // ===== PATCH BEGIN: Agent 模式辅助函数 / userId =====
    function getOrInitUserId() {
      const key = "agentWorker:userId";
      try {
        const existing = localStorage.getItem(key);
        if (existing) return existing;

        const id =
          (crypto.randomUUID && crypto.randomUUID()) ||
          "u_" + Date.now() + "_" + Math.random().toString(16).slice(2);
        localStorage.setItem(key, id);
        return id;
      } catch (e) {
        return "anonymous";
      }
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent 模式 UI 状态同步 =====
    // ===== PATCH BEGIN: Agent 模式 UI 状态同步 =====
    function applyModeUiState() {
      if (el.modeSelect) {
        el.modeSelect.value = currentMode;
      }
      if (el.agentSelect) {
        el.agentSelect.value = currentAgentId;
        // 只有 Agent 模式才允许切换 Agent
        el.agentSelect.disabled = currentMode !== MODE_AGENT_DEVOPS;
      }
      if (el.envSelect) {
        el.envSelect.value = currentEnvId;
      }

      if (el.currentAgentLabel) {
        el.currentAgentLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? `agent:${currentAgentId}`
            : "worker-direct";
      }

      if (el.routeLabel) {
        el.routeLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "模式：Agent Runtime /api/agent"
            : "模式：直连 Worker";
      }

      // 仅在非发送中时更新提示文案
      if (el.requestMetaHint && !isSending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }

      // ★ 真的做到：每次模式 / 环境切换时都刷新一次运行健康（后端没实现就静默失败）
      if (typeof refreshHealthPanel === "function") {
        try {
          const r = refreshHealthPanel();
          if (r && typeof r.then === "function") {
            r.catch(() => {});
          }
        } catch (e) {
          // 静默，不影响前端其它逻辑
          console.debug("[AgentUI] refreshHealthPanel 调用失败（已忽略）", e);
        }
      }
    }
    // ===== PATCH END =====


    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent payload 组装 & runtime 摘要提取 =====
    function buildAgentPayload(inputText) {
      return {
        tenant_id: "oliverfr",
        agent: currentAgentId,
        env: currentEnvId,
        session_id: currentSessionId,
        user_id: currentUserId || "anonymous",
        input: inputText,
        meta: {
          source: "agent-worker-ui",
          mode: currentMode,
          ua: navigator.userAgent || "",
        },
      };
    }

// ★ 全量替换原来的 extractRuntimeMetaFromAgentResponse
function extractRuntimeMetaFromAgentResponse(data) {
  if (!data || typeof data !== "object") return null;

  const meta =
    data.meta && typeof data.meta === "object" ? data.meta : null;
  const extra =
    data.extra && typeof data.extra === "object" ? data.extra : null;
  const debug =
    data.debug && typeof data.debug === "object" ? data.debug : null;

  // 1）runtime：支持顶层 runtime / agent_runtime 以及 meta.runtime / extra.runtime / debug.runtime
  const rt =
    (data.runtime && typeof data.runtime === "object" && data.runtime) ||
    (data.agent_runtime && typeof data.agent_runtime === "object" && data.agent_runtime) ||
    (meta && meta.runtime && typeof meta.runtime === "object" && meta.runtime) ||
    (extra && extra.runtime && typeof extra.runtime === "object" && extra.runtime) ||
    (debug && debug.runtime && typeof debug.runtime === "object" && debug.runtime) ||
    null;

  // 2）节点 / 步骤
  const nodesFromRt =
    rt &&
    (rt.nodes_executed ||
      rt.nodes ||
      rt.steps ||
      rt.flow);

  const nodesFallback =
    data.nodes_executed ||
    data.nodes ||
    data.steps ||
    data.flow ||
    (debug && (debug.nodes_executed || debug.nodes)) ||
    null;

  const nodes = Array.isArray(nodesFromRt || nodesFallback)
    ? (nodesFromRt || nodesFallback)
    : [];

  // 3）工具调用
  const toolsFromRt =
    rt &&
    (rt.tools ||
      rt.tools_used ||
      rt.tool_calls);

  const toolsFallback =
    data.tools ||
    data.tools_used ||
    data.tool_calls ||
    (debug && (debug.tools || debug.tools_used || debug.tool_calls)) ||
    null;

  const tools = Array.isArray(toolsFromRt || toolsFallback)
    ? (toolsFromRt || toolsFallback)
    : [];

  // 4）RAG 统计
  const ragFromRt =
    rt &&
    ((rt.rag && typeof rt.rag === "object" && rt.rag) ||
      (rt.rag_stats && typeof rt.rag_stats === "object" && rt.rag_stats) ||
      (rt.rag_status && typeof rt.rag_status === "object" && rt.rag_status));

  const ragTop =
    (data.rag && typeof data.rag === "object" && data.rag) ||
    (data.rag_stats && typeof data.rag_stats === "object" && data.rag_stats) ||
    (data.rag_status && typeof data.rag_status === "object" && data.rag_status) ||
    null;

  const rag = ragFromRt || ragTop;
  let ragHits = 0;
  if (rag) {
    if (typeof rag.hits_count === "number") ragHits = rag.hits_count;
    else if (typeof rag.hits === "number") ragHits = rag.hits;
    else if (typeof rag.top_k === "number") ragHits = rag.top_k;
    else if (Array.isArray(rag.docs)) ragHits = rag.docs.length;
  }

  // 5）graphVersion / taskType / traceId
  const graphVersion =
    (rt && (rt.graph_version || rt.graphVersion)) ||
    (meta && (meta.graph_version || meta.graphVersion)) ||
    data.graph_version ||
    data.graphVersion ||
    null;

  const taskType =
    (rt && (rt.task_type || rt.taskType)) ||
    (meta && (meta.task_type || meta.taskType)) ||
    data.task_type ||
    data.taskType ||
    null;

  const traceId =
    (rt && (rt.trace_id || rt.traceId)) ||
    (meta && (meta.trace_id || meta.traceId)) ||
    (extra && (extra.trace_id || extra.traceId)) ||
    data.trace_id ||
    data.traceId ||
    data._gateway_trace_id ||
    null;

  // 6）服务端 timings：debug.timings_ms / debug.timingsMs
  let serverTotalMs = null;
  let serverTimings = null;
  if (debug) {
    const t =
      (debug.timings_ms && typeof debug.timings_ms === "object" && debug.timings_ms) ||
      (debug.timingsMs && typeof debug.timingsMs === "object" && debug.timingsMs) ||
      null;
    if (t) {
      if (typeof t.total === "number") serverTotalMs = t.total;
      serverTimings = t;
    }
  }

  return {
    graphVersion,
    taskType,
    traceId,
    nodeCount: nodes.length,
    toolCount: tools.length,
    ragHits,
    rawNodes: nodes,
    rawTools: tools,
    rawRag: rag || null,
    serverTotalMs,
    serverTimings,
  };
}


    // ===== PATCH END =====
    // ===== PATCH BEGIN: 统一调用后端（直连 Worker / Agent Runtime） =====
// ===== [PATCH REPLACE · Step 4.2.2 · 统一后端调用（附带 agentRaw）] =====
async function callBackendWithMode(userText) {
  const start = performance.now();
  let durationMs = 0;
  let rawResponse = "";
  let replyText = "";
  let modelName = "gpt-5-mini";
  let usage = null;
  let runtimeMeta = null;
  let agentRaw = null;
  let status = 0;
  let ok = false;

  try {
    if (currentMode === MODE_AGENT_DEVOPS) {
      const payload = buildAgentPayload(userText);
      const res = await fetch(resolveAgentEndpoint(), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      durationMs = performance.now() - start;
      status = res.status;
      const text = await res.text();
      rawResponse = text;

      if (!res.ok) {
        // ⭐ 关键：把 agent 端的错误体打给你看
        console.error(
          "[Agent /api/agent] HTTP", status,
          "body:", text.slice(0, 1000)  // 避免太长
        );
        return { ok: false, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
      }

      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }

       if (data) {
        agentRaw = data;
        replyText = data.reply || data.output || "";
        modelName =
          data.model ||
          (data.runtime && data.runtime.model_profile) ||
          modelName;

        // ★ 修复点：usage 兼容顶层 usage + extra.usage + cost.usage
        const extraUsage =
          data.extra && typeof data.extra === "object" ? data.extra.usage : null;

        usage =
          data.usage ||                 // Cloud Shell 截图里就是这个
          extraUsage ||                 // 兼容有些实现把 usage 挂在 extra 里
          (data.cost && data.cost.usage) || // 兼容 cost.usage 形式
          null;

        runtimeMeta = extractRuntimeMetaFromAgentResponse(data);
        if (runtimeMeta && typeof runtimeMeta === "object") {
          data._runtime_meta = runtimeMeta;
        }
      }

      // ===== PATCH ADD: 兼容 AgentResponse.cost 字段（tokens + 费用） =====
      if (!usage && data.cost && typeof data.cost === "object") {
        const c = data.cost;
        usage = {
          // 支持多种命名：tokens_prompt / prompt_tokens / input_tokens
          prompt_tokens:
            (typeof c.tokens_prompt === "number" ? c.tokens_prompt : null) ??
            (typeof c.prompt_tokens === "number" ? c.prompt_tokens : null) ??
            (typeof c.input_tokens === "number" ? c.input_tokens : null),

          // 支持：tokens_completion / completion_tokens / output_tokens
          completion_tokens:
            (typeof c.tokens_completion === "number" ? c.tokens_completion : null) ??
            (typeof c.completion_tokens === "number" ? c.completion_tokens : null) ??
            (typeof c.output_tokens === "number" ? c.output_tokens : null),

          // total_tokens 如果缺失，就用 prompt + completion 兜底
          total_tokens:
            (typeof c.total_tokens === "number"
              ? c.total_tokens
              : (typeof c.tokens_prompt === "number" &&
                 typeof c.tokens_completion === "number")
                ? c.tokens_prompt + c.tokens_completion
                : null),

          // 费用估算：usd_estimate / usd / estimated_cost_usd
          usd_estimate:
            (typeof c.usd_estimate === "number" ? c.usd_estimate : null) ??
            (typeof c.usd === "number" ? c.usd : null) ??
            (typeof c.estimated_cost_usd === "number" ? c.estimated_cost_usd : null),
        };
      }

      ok = true;
      return { ok, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
    } else {
      // ⭐ 直连 Worker
      const res = await fetch(WORKER_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ input: userText }),
      });

      durationMs = performance.now() - start;
      status = res.status;
      const text = await res.text();
      rawResponse = text;

      if (!res.ok) {
        // ⭐ 关键：把 Worker 的错误体打给你看
        console.error(
          "[Worker /agent/] HTTP", status,
          "body:", text.slice(0, 1000)
        );
        return { ok: false, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
      }

      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }

      if (data) {
        replyText = data.output || "";
        modelName = data.model || modelName;
        usage = data.usage || null;
      }

      ok = true;
      return { ok, status, durationMs, rawResponse, replyText, modelName, usage, runtimeMeta, agentRaw };
    }
  } catch (err) {
    durationMs = performance.now() - start;
    rawResponse = String(err || "Unknown error");
    console.error("[Backend] 网络异常:", err);
    return {
      ok: false,
      status: "network_error",
      durationMs,
      rawResponse,
      replyText: "",
      modelName,
      usage: null,
      runtimeMeta: null,
      agentRaw: null,
    };
  }
}


    // ===== PATCH END =====
  
    // === Worker 调用 ===

    /*async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMsg = createMessage(currentSessionId, "user", raw);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true);
      el.chatInput.value = "";

      const start = performance.now();
      let ok = false;
      let modelName = "gpt-5-mini";
      let usage = null;
      let outputText = "";
      lastRawResponse = "";
      lastOverview = null;

      try {
        const res = await fetch(WORKER_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: raw }),
        });

        const durationMs = performance.now() - start;

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          lastRawResponse = text || "";
          updateCallOverviewError(res.status, durationMs, null);
          updateRawJson(text || "");
          lastOverview = {
            ok: false,
            status: res.status,
            durationMs,
            modelName,
            usage: null,
          };
          showToast("Worker 调用失败，请检查 Worker 日志。");
        } else {
          const data = await res.json();
          ok = true;
          outputText = data.output || "";
          modelName = data.model || modelName;
          usage = data.usage || null;
          lastRawResponse = JSON.stringify(data, null, 2);
          updateCallOverviewSuccess(durationMs, modelName, usage);
          updateRawJson(lastRawResponse);
          lastOverview = {
            ok: true,
            status: res.status || 200,
            durationMs,
            modelName,
            usage: usage || null,
          };
        }
      } catch (err) {
        console.error(err);
        const durationMs = performance.now() - start;
        updateCallOverviewError("网络错误", durationMs, null);
        lastRawResponse = String(err || "Unknown error");
        updateRawJson(lastRawResponse);
        lastOverview = {
          ok: false,
          status: "network_error",
          durationMs,
          modelName,
          usage: null,
        };
        showToast("网络异常，无法访问 Worker。");
      } finally {
        isSending = false;
        setSendingState(false);
      }

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          outputText || "（Worker 未返回内容）"
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", outputText || "（Worker 未返回内容）", true);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();
    }*/
    // === Worker 调用 ===

    async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMeta = {
        mode: currentMode,
      };

      const userMsg = createMessage(currentSessionId, "user", raw, userMeta);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true, userMeta);
      el.chatInput.value = "";

      // ===== PATCH BEGIN: 按模式调用后端（直连 / Agent） =====
      const result = await callBackendWithMode(raw);
      const {
        ok,
        status,
        durationMs,
        rawResponse,
        replyText,
        modelName,
        usage,
        runtimeMeta,
         agentRaw, // ★ 新增
      } = result;

         lastRawResponse = rawResponse || "";
      lastOverview = {
        ok,
        status,
        durationMs,
        modelName,
        usage: usage || null,
        mode: currentMode,
        runtimeMeta: runtimeMeta || null,
      };

      // ★ 用 lastOverview，而不是不存在的 overview，顺便把 runtimeMeta 传给概览
      if (lastOverview.ok) {
        updateCallOverviewSuccess(
          typeof lastOverview.durationMs === "number"
            ? lastOverview.durationMs
            : 0,
          modelName,
          usage,
          lastOverview.runtimeMeta || null
        );
      } else {
        updateCallOverviewError(
          status || "-",
          typeof durationMs === "number" ? durationMs : null,
          usage || null
        );
      }

      updateRawJson(rawResponse || "");


      if (!ok) {
        if (status === "network_error") {
          showToast("网络异常，无法访问后端。");
        } else if (currentMode === MODE_AGENT_DEVOPS) {
          showToast(`Agent 调用失败（${status}），请检查 Agent Worker 日志。`);
        } else {
          showToast(`Worker 调用失败（${status}），请检查 Worker 日志。`);
        }
      }
      // ===== PATCH END =====

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const safeReply = replyText || "（后端未返回内容）";
        const assistantMeta = {
          mode: currentMode,
          runtimeMeta: runtimeMeta || null,
          rawAgent: agentRaw || null, // ★ 新增
        };
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          safeReply,
          assistantMeta
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", safeReply, true, assistantMeta);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();

      isSending = false;
      setSendingState(false);
    }

    function deriveTitleFromText(text) {
      const trimmed = text.replace(/\s+/g, " ").trim();
      if (!trimmed) return "新会话";
      return trimmed.length > 22 ? trimmed.slice(0, 22) + "…" : trimmed;
    }

    /*function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";
      el.requestMetaHint.textContent = sending
        ? "正在调用 Cloudflare  &AI智能体…"
        : "就绪：调用 Cloudflare Worker 智能体。";
    }*/
        function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";

      if (!el.requestMetaHint) return;

      if (sending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "正在调用 Agent Runtime 智能体…"
            : "正在调用 Cloudflare Worker 智能体…";
      } else {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }
    }


function appendMessageBubble(role, content, hideEmptyHint, meta) {
  if (hideEmptyHint && el.chatEmpty.parentNode === el.chatMessages) {
    el.chatEmpty.style.display = "none";
    el.chatMessages.innerHTML = "";
  }

  const bubble = document.createElement("div");
  bubble.className = "chat-message " + role;
  bubble.textContent = content;
  el.chatMessages.appendChild(bubble);

  // ===== PATCH BEGIN: Agent Trace 可视化（仅 Agent 模式的 assistant 消息） =====
  if (
    role === "assistant" &&
    meta &&
    meta.mode === MODE_AGENT_DEVOPS &&
    meta.runtimeMeta
  ) {
    const rm = meta.runtimeMeta;

    const nodeCount =
      typeof rm.nodeCount === "number" ? rm.nodeCount : 0;
    const toolCount =
      typeof rm.toolCount === "number" ? rm.toolCount : 0;
    const ragHits =
      typeof rm.ragHits === "number" ? rm.ragHits : 0;
    const task = rm.taskType || "-";
    const traceId = rm.traceId || "-";

    const summary = document.createElement("div");
    summary.className = "agent-trace-summary";
    summary.innerHTML =
      `<strong>Agent trace</strong> · task=${task} · nodes=${nodeCount}` +
      ` · tools=${toolCount} · RAG hits=${ragHits} · trace=${traceId}（点击展开详情）`;

    const detail = document.createElement("div");
    detail.className = "agent-trace-detail";
    const lines = [];

    if (Array.isArray(rm.rawNodes) && rm.rawNodes.length) {
      lines.push("Nodes:");
      rm.rawNodes.forEach((n, idx) => {
        const label = n.name || n.id || `node_${idx + 1}`;
        const status = n.status || n.state || "done";
        lines.push(`  - ${label} [${status}]`);
      });
    }

    if (Array.isArray(rm.rawTools) && rm.rawTools.length) {
      lines.push("");
      lines.push("Tools:");
      rm.rawTools.forEach((t, idx) => {
        const name = t.name || t.tool || `tool_${idx + 1}`;
        const status = t.status || t.state || "ok";
        lines.push(`  - ${name} [${status}]`);
      });
    }

    if (rm.rawRag) {
      lines.push("");
      lines.push("RAG:");
      lines.push(`  - hits ≈ ${ragHits}`);
    }

    if (!lines.length) {
      lines.push("（Agent runtime 未返回详细 trace，仅有汇总信息。）");
    }

    detail.textContent = lines.join("\n");

    summary.addEventListener("click", () => {
      detail.classList.toggle("open");
    });

    el.chatMessages.appendChild(summary);
    el.chatMessages.appendChild(detail);
  }
  // ===== PATCH END =====
}


    function scrollToBottom() {
      requestAnimationFrame(() => {
        el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
      });
    }

    // === 调用概览 / JSON ===

    /*function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }*/
    function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      if (el.currentModelLabel) {
        el.currentModelLabel.textContent = "gpt-5-mini";
      }
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }

    /*function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }*/
    function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        applyModeUiState();
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.mode) {
        currentMode = overview.mode;
      }
      applyModeUiState();

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }

    /*function updateCallOverviewSuccess(durationMs, modelName, usage) {
      el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 成功';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      el.ovModel.textContent = modelName || "gpt-5-mini";
      const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
      el.ovPromptTokens.textContent = pt;
      el.ovCompletionTokens.textContent = ct;
      el.ovTotalTokens.textContent = tt;
    }*/
  // ===== PATCH REPLACE · updateCallOverviewSuccess：加入 serverTotalMs =====
function updateCallOverviewSuccess(durationMs, modelName, usage, runtimeMeta) {
  // 前端测得的总耗时
  const clientMs =
    typeof durationMs === "number" && Number.isFinite(durationMs)
      ? durationMs
      : 0;

  // 若有服务端 graph 总耗时，则一起显示
  let durationLabel = `${clientMs.toFixed(0)} ms`;
  if (
    runtimeMeta &&
    typeof runtimeMeta.serverTotalMs === "number" &&
    Number.isFinite(runtimeMeta.serverTotalMs)
  ) {
    durationLabel = `${clientMs.toFixed(0)} ms / srv≈${runtimeMeta.serverTotalMs.toFixed(
      0
    )} ms`;
  }

  el.ovDuration.textContent = durationLabel;

  const pill = document.createElement("span");
  pill.className = "call-status-pill";
  pill.innerHTML = '<span class="call-status-dot"></span> 成功';
  el.ovStatus.innerHTML = "";
  el.ovStatus.appendChild(pill);

  const modelText = modelName || "gpt-5-mini";
  el.ovModel.textContent = modelText;
  if (el.currentModelLabel) {
    el.currentModelLabel.textContent = modelText;
  }

  const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
  const ct =
    (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
  const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
  el.ovPromptTokens.textContent = pt;
  el.ovCompletionTokens.textContent = ct;
  el.ovTotalTokens.textContent = tt;

  // 保持原有 UI 同步逻辑
  applyModeUiState();
}


  function updateCallOverviewError(status, durationMs, usage) {
  el.ovDuration.textContent =
    typeof durationMs === "number" ? `${durationMs.toFixed(0)} ms` : "-";

  let hint = "";
  if (status === 502 || status === "502") {
    hint = "（通常是 Worker 崩溃 / 未捕获异常）";
  } else if (status === 500 || status === "500") {
    hint = "（后端服务返回 500，检查 Cloud Run / OpenAI）";
  } else if (status === "network_error") {
    hint = "（浏览器到站点网络异常）";
  }

  const pill = document.createElement("span");
  pill.className = "call-status-pill error";
  pill.innerHTML = `<span class="call-status-dot"></span> 失败（${status}）${hint}`;
  el.ovStatus.innerHTML = "";
  el.ovStatus.appendChild(pill);

  el.ovPromptTokens.textContent = "-";
  el.ovCompletionTokens.textContent = "-";
  el.ovTotalTokens.textContent = "-";
}

// ===== [ADD · Step 4.2.3 · 右侧智能体信息渲染 · 复用 rawJson 面板容器] =====
function ensureAgentInfoMount() {
  // 复用你现有的右侧 JSON 容器
  if (!el.rawJsonBody) return null;
  let box = document.getElementById("agentInfoBox");
  if (!box) {
    box = document.createElement("div");
    box.id = "agentInfoBox";
    box.style.cssText = "margin-bottom:8px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;background:#f9fafb;";
    el.rawJsonBody.insertBefore(box, el.rawJsonBody.firstChild); // 放在最上面
  }
  return box;
}

function clearAgentInfo() {
  const box = document.getElementById("agentInfoBox");
  if (box && box.parentNode) box.parentNode.removeChild(box);
}

// ===== [PATCH REPLACE · renderAgentInfo：补充 tokens & cost 展示] =====
// ===== [PATCH REPLACE · renderAgentInfo：吃掉 runtimeMeta / nodes / tokens，替换掉写死文案] =====
function renderAgentInfo(agentObj) {
  // 判定是否像 Agent 响应：有 reply / state_snapshot / trace_id / agent / runtime 等字段
  const looksLikeAgent =
    agentObj &&
    typeof agentObj === "object" &&
    (
      typeof agentObj.reply === "string" ||
      agentObj.state_snapshot ||
      agentObj.trace_id ||
      agentObj.agent ||
      agentObj.runtime
    );

  if (!looksLikeAgent) {
    if (typeof clearAgentInfo === "function") clearAgentInfo();
    return;
  }

  const box = typeof ensureAgentInfoMount === "function"
    ? ensureAgentInfoMount()
    : null;
  if (!box) return;

  // 1）优先使用前面挂在 _runtime_meta 上的结构，其次现场再解析一遍
  let meta = null;
  if (agentObj._runtime_meta && typeof agentObj._runtime_meta === "object") {
    meta = agentObj._runtime_meta;
  } else if (typeof extractRuntimeMetaFromAgentResponse === "function") {
    meta = extractRuntimeMetaFromAgentResponse(agentObj);
  }

  // 2）基础字段
  const rt    = agentObj.runtime && typeof agentObj.runtime === "object" ? agentObj.runtime : null;
  const agent = agentObj.agent || (rt && rt.agent) || "-";
  const env   = agentObj.env   || (rt && rt.env)   || "-";

  const graphVersion =
    (meta && meta.graphVersion) ||
    (rt && (rt.graph_version || rt.graphVersion)) ||
    agentObj.graph_version ||
    agentObj.graphVersion ||
    "-";

  const taskType =
    (meta && meta.taskType) ||
    (agentObj.state_snapshot && agentObj.state_snapshot.task_type) ||
    (rt && (rt.task_type || rt.taskType)) ||
    agentObj.task_type ||
    agentObj.taskType ||
    "-";

  const traceId =
    (meta && meta.traceId) ||
    agentObj.trace_id ||
    agentObj.traceId ||
    (rt && (rt.trace_id || rt.traceId)) ||
    agentObj._gateway_trace_id ||
    "-";

  // 3）节点 / 工具 / RAG 命中
  const nodeCount = meta && typeof meta.nodeCount === "number"
    ? meta.nodeCount
    : Array.isArray(agentObj.nodes_executed)
      ? agentObj.nodes_executed.length
      : Array.isArray(rt && rt.nodes_executed)
        ? rt.nodes_executed.length
        : 0;

  const toolCount = meta && typeof meta.toolCount === "number"
    ? meta.toolCount
    : Array.isArray(agentObj.tools_used)
      ? agentObj.tools_used.length
      : Array.isArray(rt && rt.tools_used)
        ? rt.tools_used.length
        : 0;

  const ragHits = meta && typeof meta.ragHits === "number"
    ? meta.ragHits
    : 0;

  // 4）tokens / 费用：兼容 cost / usage 多种命名
  let promptTokens = null;
  let completionTokens = null;
  let totalTokens = null;
  let usdEstimate = null;

  const cost =
    (agentObj.cost && typeof agentObj.cost === "object" && agentObj.cost) ||
    (rt && rt.cost && typeof rt.cost === "object" && rt.cost) ||
    null;

  const usage =
    (agentObj.usage && typeof agentObj.usage === "object" && agentObj.usage) ||
    (rt && rt.usage && typeof rt.usage === "object" && rt.usage) ||
    null;

  if (usage) {
    if (typeof usage.prompt_tokens === "number") promptTokens = usage.prompt_tokens;
    if (typeof usage.completion_tokens === "number") completionTokens = usage.completion_tokens;
    if (typeof usage.total_tokens === "number") totalTokens = usage.total_tokens;
  }

  if (cost) {
    if (promptTokens == null) {
      if (typeof cost.tokens_prompt === "number") promptTokens = cost.tokens_prompt;
      else if (typeof cost.prompt_tokens === "number") promptTokens = cost.prompt_tokens;
      else if (typeof cost.input_tokens === "number") promptTokens = cost.input_tokens;
    }
    if (completionTokens == null) {
      if (typeof cost.tokens_completion === "number") completionTokens = cost.tokens_completion;
      else if (typeof cost.completion_tokens === "number") completionTokens = cost.completion_tokens;
      else if (typeof cost.output_tokens === "number") completionTokens = cost.output_tokens;
    }
    if (totalTokens == null) {
      if (typeof cost.total_tokens === "number") {
        totalTokens = cost.total_tokens;
      } else if (
        typeof promptTokens === "number" &&
        typeof completionTokens === "number"
      ) {
        totalTokens = promptTokens + completionTokens;
      }
    }
    if (typeof cost.usd_estimate === "number") {
      usdEstimate = cost.usd_estimate;
    } else if (typeof cost.usd === "number") {
      usdEstimate = cost.usd;
    } else if (typeof cost.estimated_cost_usd === "number") {
      usdEstimate = cost.estimated_cost_usd;
    }
  }

  // 5）服务端 timings
  const serverTotalMs =
    meta && typeof meta.serverTotalMs === "number"
      ? meta.serverTotalMs
      : null;

  const nodesPreview =
    meta && Array.isArray(meta.rawNodes) && meta.rawNodes.length
      ? meta.rawNodes.slice(0, 6)
      : null;

  // 6）真正渲染：替换掉之前写死的「未返回详细 trace」文案
  const parts = [];

  parts.push(
    '<div style="font-size:11px;color:#9ca3af;margin-bottom:4px;">' +
      '<strong style="color:#e5e7eb;">智能体执行摘要 (Agent Mode)</strong>' +
    "</div>"
  );

  parts.push('<div style="font-size:11px;line-height:1.6;color:#d1d5db;">');

  parts.push(
    `  <div>Agent：<span style="color:#e5e7eb;">${agent}</span>` +
    ` · Env：<span style="color:#e5e7eb;">${env}</span></div>`
  );

  if (graphVersion && graphVersion !== "-") {
    parts.push(
      `  <div>Graph：<span style="color:#e5e7eb;">${String(graphVersion)}</span></div>`
    );
  }

  parts.push(
    `  <div>任务类型：<span style="color:#e5e7eb;">${String(taskType || "-")}</span></div>`
  );

  if (nodeCount || toolCount || ragHits) {
    parts.push(
      `  <div>节点：<span style="color:#e5e7eb;">${nodeCount || 0}</span>` +
      ` · 工具：<span style="color:#e5e7eb;">${toolCount || 0}</span>` +
      ` · RAG 命中：<span style="color:#e5e7eb;">${ragHits || 0}</span></div>`
    );
  }

  if (promptTokens != null || completionTokens != null || totalTokens != null) {
    parts.push(
      `  <div>Tokens：prompt <span style="color:#e5e7eb;">${promptTokens ?? "-"}</span>` +
      ` · completion <span style="color:#e5e7eb;">${completionTokens ?? "-"}</span>` +
      ` · total <span style="color:#e5e7eb;">${totalTokens ?? "-"}</span></div>`
    );
  }

  if (usdEstimate != null) {
    parts.push(
      `  <div>估算费用：<span style="color:#e5e7eb;">$${usdEstimate.toFixed(5)}</span></div>`
    );
  }

  if (serverTotalMs != null) {
    parts.push(
      `  <div>服务端耗时：<span style="color:#e5e7eb;">${serverTotalMs.toFixed(1)} ms</span></div>`
    );
  }

  parts.push(
    `  <div style="margin-top:4px;">Trace ID：` +
    `<span style="color:#e5e7eb;">${String(traceId || "-")}</span></div>`
  );

  parts.push("</div>");

  if (nodesPreview && nodesPreview.length) {
    const previewLines = nodesPreview.map((n, idx) => {
      if (typeof n === "string") return `#${idx + 1} ${n}`;
      try {
        return `#${idx + 1} ${JSON.stringify(n)}`;
      } catch {
        return `#${idx + 1} [object]`;
      }
    });

    parts.push(
      '<pre style="margin-top:6px;font-size:11px;' +
        'white-space:pre-wrap;color:#9ca3af;' +
        'border-top:1px dashed rgba(148,163,184,0.5);padding-top:4px;">' +
        previewLines.join("\n") +
      "</pre>"
    );
  }

  box.innerHTML = parts.join("");
}
// ===== [PATCH REPLACE END] =====

    
// ===== [NEW] Agent trace 详情格式化（优先用 debug / state_snapshot / trace） =====
function formatAgentTraceDetail(agentObj) {
  if (!agentObj || typeof agentObj !== "object") {
    return "(暂无可展示的 trace 数据)";
  }

  // 根据当前 AgentResponse 里常见的字段，按优先级挑一份最有用的结构出来
  const snapshot = agentObj.state_snapshot || null;
  const debug = agentObj.debug || null;
  const trace =
    agentObj.trace_detail || agentObj.trace_log || agentObj.trace || null;

  // 优先级：debug > state_snapshot > trace > 整个 agentObj
  const payload = debug || snapshot || trace || agentObj;

  try {
    return JSON.stringify(payload, null, 2);
  } catch (err) {
    try {
      return String(payload);
    } catch {
      return "(暂无可展示的 trace 数据)";
    }
  }
}


// ===== [PATCH ADD · 健康面板挂载] =====

/*function ensureHealthPanelMount() {
  if (!el.rawJsonBody) return null;

  let box = document.getElementById("healthInfoBox");
  if (!box) {
    box = document.createElement("div");
    box.id = "healthInfoBox";
    box.style.cssText =
      "margin-bottom:8px;" +
      "border:1px dashed #cbd5e1;" +
      "border-radius:8px;" +
      "padding:8px;" +
      "background-color:transparent;"; // 关键：改成透明，跟外层同色
    el.rawJsonBody.insertBefore(box, el.rawJsonBody.firstChild);
  }
  return box;
}*/
function ensureHealthPanelMount() {
  if (!el.rawJsonBody) return null;

  let box = document.getElementById("healthInfoBox");
  if (!box) {
    box = document.createElement("div");
    box.id = "healthInfoBox";
    // 背景去掉白色，用透明让它继承「原始返回」卡片的深色背景
    box.style.cssText =
      "margin-bottom:8px;border:1px dashed #cbd5e1;border-radius:8px;padding:8px;background:transparent;";
    // 放在最上面（在 AgentInfo 之上）
    el.rawJsonBody.insertBefore(box, el.rawJsonBody.firstChild);
  } else {
    // 复用旧节点时兜底：如果之前被写成白底/浅灰，再强制改回透明
    const bg = box.style.background || box.style.backgroundColor || "";
    if (!bg || bg === "#fff" || bg === "#ffffff" || bg === "#f8fafc") {
      box.style.background = "transparent";
    }
  }

  // 新增：把内部块（包含「智能体执行摘要 (Agent Mode)」和「运行健康」）的白底一并清掉
  const inner = box.children;
  for (let i = 0; i < inner.length; i++) {
    const node = inner[i];
    if (!node || !node.style) continue;
    const bg = node.style.background || node.style.backgroundColor || "";
    if (!bg || bg === "#fff" || bg === "#ffffff" || bg === "#f8fafc") {
      node.style.background = "transparent";
    }
  }

  return box;
}




// ===== [PATCH ADD · 健康面板渲染] =====
function renderHealthPanel(workerHealth, debugHealth) {
  const box = ensureHealthPanelMount();
  if (!box) return;

  // 解析 Worker /health
  const wh = workerHealth || {};
  const wStatus   = wh.status || wh.worker?.status || "-";
  const wEnv      = wh.env || wh.worker?.env || "-";
  const tokenParam = wh.token_param || (debugHealth && debugHealth.token_param) || "-";
  const allowOrigins = Array.isArray(wh.allow_origins) ? wh.allow_origins.join(", ") : "-";

  // 解析 /debug-health 中转到 Cloud Run 的结果
  const dh = debugHealth || {};
  const rt = dh.runtime || {};
  const rtStatus = rt.status ?? "-";
  const rtUrl    = rt.url || "-";
  const body     = rt.body || {};
  const graphOk  = (body && (body.graph_init_ok === true)) ? "true" : "false";

  box.innerHTML = `
    <div style="font-weight:600;margin-bottom:6px;">运行健康（Worker & Cloud Run）</div>
    <div><strong>worker.status：</strong>${wStatus}</div>
    <div><strong>worker.env：</strong>${wEnv}</div>
    <div><strong>token_param：</strong>${tokenParam}</div>
    <div><strong>allow_origins：</strong>${allowOrigins}</div>
    <div style="margin-top:6px;"><strong>cloudrun.health：</strong>${rtStatus}（${rtUrl}）</div>
    <div><strong>graph_init_ok：</strong>${graphOk}</div>
  `;
}

// ===== [PATCH ADD · 拉取 /health & /debug-health 并渲染] =====
// ===== [PATCH REPLACE · 拉取 /health & /debug-health 并渲染 —— 强制锁到 /agent/* ] =====
async function refreshHealthPanel() {
  try {
    // 这里不再完全信任 WORKER_ENDPOINT，以防有人误改成其它域名
    const origin = window.location.origin;
    const base = new URL("/agent/", origin); // ★ 强制定位到站点下的 /agent/

    const u1 = new URL("health", base).toString();        // => https://oliverfr.com/agent/health
    const u2 = new URL("debug-health", base).toString();  // => https://oliverfr.com/agent/debug-health

    const [h1, h2] = await Promise.all([
      fetch(u1, { credentials: "omit" }).then(r => (r.ok ? r.json() : null)).catch(() => null),
      fetch(u2, { credentials: "omit" }).then(r => (r.ok ? r.json() : null)).catch(() => null),
    ]);

    renderHealthPanel(h1, h2);
  } catch (e) {
    console.warn("[health-panel] 刷新运行健康失败：", e);
    // 静默：不影响主流程
  }
}



// ===== [PATCH REPLACE · Step 4.2.3 · updateRawJson：联动智能体信息面板] =====
function updateRawJson(text) {
  if (!text) {
    lastRawResponse = "";
    el.rawJsonPlaceholder.style.display = "block";
    el.rawJsonPre.style.display = "none";
    el.rawJsonPre.textContent = "";
    clearAgentInfo(); // ★ 同时清理上方智能体信息块
    return;
  }

  // 同步 lastRawResponse，保证“复制 JSON”一致
  if (typeof text === "string") {
    lastRawResponse = text;
  } else {
    try { lastRawResponse = JSON.stringify(text, null, 2); }
    catch { lastRawResponse = String(text); }
  }

  el.rawJsonPlaceholder.style.display = "none";
  el.rawJsonPre.style.display = "block";

  let parsed = null;
  try {
    parsed = typeof text === "string" ? JSON.parse(text) : text;
    el.rawJsonPre.textContent = JSON.stringify(parsed, null, 2);
  } catch {
    el.rawJsonPre.textContent = lastRawResponse;
  }

  // ★ 尝试渲染智能体信息（仅当能解析为对象时）
  if (parsed && typeof parsed === "object") {
    renderAgentInfo(parsed);
  } else {
    clearAgentInfo();
  }
}

       // === Toast ===

    let toastTimer = null;

    function showToast(message) {
      el.toastText.textContent = message;
      el.toast.classList.add("visible");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.toast.classList.remove("visible");
      }, 2800);
    }

    function showFatalError(err) {
      console.error(err);
      showToast("初始化失败，请检查浏览器控制台。");
    }

    // === Mobile drawer logic · 仅手机端使用 ===
    (function () {
      const mainPanel  = document.querySelector(".main-panel");
      const sidebarEl  = document.querySelector(".sidebar");
      const insightEl  = document.querySelector(".insight-panel");
      const overlayEl  = document.getElementById("mobileOverlay");
      const btnSidebar = document.getElementById("btnMobileSidebarToggle");
      const btnInsight = document.getElementById("btnMobileInsightToggle");

      // 桌面端或元素缺失时，直接退出，不影响其它逻辑
      if (!mainPanel || !sidebarEl || !overlayEl || !btnSidebar || !btnInsight) return;

      let sidebarOpen = false;
      let insightOpen = false;

      function syncOverlay() {
        if (sidebarOpen || insightOpen) {
          overlayEl.classList.add("visible");
        } else {
          overlayEl.classList.remove("visible");
        }
      }

      // 左侧会话栏按钮：打开时主面板向右推
      btnSidebar.addEventListener("click", () => {
        sidebarOpen = !sidebarOpen;
        sidebarEl.classList.toggle("sidebar-open", sidebarOpen);
        mainPanel.classList.toggle("push-right", sidebarOpen);

        if (sidebarOpen) {
          // 只允许一侧打开
          insightOpen = false;
          if (insightEl) insightEl.classList.remove("insight-open");
          mainPanel.classList.remove("push-left");
        }

        syncOverlay();
      });

      // 右侧调用概览按钮：打开时主面板向左推
      btnInsight.addEventListener("click", () => {
        insightOpen = !insightOpen;
        if (insightEl) {
          insightEl.classList.toggle("insight-open", insightOpen);
        }
        mainPanel.classList.toggle("push-left", insightOpen);

        if (insightOpen) {
          sidebarOpen = false;
          sidebarEl.classList.remove("sidebar-open");
          mainPanel.classList.remove("push-right");
        }

        syncOverlay();
      });

      // 点击遮罩：关闭两边抽屉 & 还原主界面
      overlayEl.addEventListener("click", () => {
        sidebarOpen = false;
        insightOpen = false;
        sidebarEl.classList.remove("sidebar-open");
        if (insightEl) insightEl.classList.remove("insight-open");
        mainPanel.classList.remove("push-right");
        mainPanel.classList.remove("push-left");
        syncOverlay();
      });
    })();

    /* ===== PATCH REPLACE · 调用概览渲染（兼容 usage + cost，显示 tokens & cost） ===== */

// 把各种可能的 usage / cost 结构统一成一个简单的 metrics
function extractUsageMetrics(usage) {
  const u = usage && typeof usage === "object" ? usage : {};

  function toNum(v) {
    if (typeof v === "number" && !Number.isNaN(v)) return v;
    if (typeof v === "string" && v.trim() !== "" && !Number.isNaN(Number(v))) {
      return Number(v);
    }
    return null;
  }

  const promptTokens =
    toNum(u.tokens_prompt) ??
    toNum(u.prompt_tokens) ??
    toNum(u.input_tokens);

  const completionTokens =
    toNum(u.tokens_completion) ??
    toNum(u.completion_tokens) ??
    toNum(u.output_tokens);

  let totalTokens =
    toNum(u.total_tokens) ??
    toNum(u.totalTokens);

  if (totalTokens == null && promptTokens != null && completionTokens != null) {
    totalTokens = promptTokens + completionTokens;
  }

  const usdEstimate =
    toNum(u.usd_estimate) ??
    toNum(u.usd) ??
    toNum(u.estimated_cost_usd);

  return { promptTokens, completionTokens, totalTokens, usdEstimate };
}

function formatDurationMs(ms) {
  if (typeof ms !== "number" || !Number.isFinite(ms) || ms < 0) return "-";
  if (ms < 1000) return `${Math.round(ms)} ms`;
  const sec = ms / 1000;
  if (sec < 60) return `${sec.toFixed(2)} s`;
  const m = Math.floor(sec / 60);
  const s = Math.round(sec % 60);
  return `${m}m ${s}s`;
}

function updateCallOverviewSuccess(durationMs, modelName, usage, runtimeMeta) {
  const metrics = extractUsageMetrics(usage || {});
  const { promptTokens, completionTokens, totalTokens, usdEstimate } = metrics;

  if (el.ovDuration) {
    el.ovDuration.textContent = formatDurationMs(durationMs);
  }
  if (el.ovModel) {
    el.ovModel.textContent = modelName || "gpt-5-mini";
  }

  // 状态 pill：成功 + 可选 task_type 文案
  if (el.ovStatus) {
    const taskLabel =
      runtimeMeta && runtimeMeta.taskType
        ? `成功 · ${runtimeMeta.taskType}`
        : "调用成功";

    el.ovStatus.innerHTML = `
      <span class="call-status-pill">
        <span class="call-status-dot"></span>
        ${taskLabel}
      </span>
    `;
  }

  if (el.ovPromptTokens) {
    el.ovPromptTokens.textContent =
      promptTokens != null ? String(promptTokens) : "-";
  }
  if (el.ovCompletionTokens) {
    el.ovCompletionTokens.textContent =
      completionTokens != null ? String(completionTokens) : "-";
  }
  if (el.ovTotalTokens) {
    if (totalTokens != null && usdEstimate != null && usdEstimate > 0) {
      // 同时展示 tokens 与约算费用
      el.ovTotalTokens.textContent =
        `${totalTokens}（≈ $${usdEstimate.toFixed(6)}）`;
    } else if (totalTokens != null) {
      el.ovTotalTokens.textContent = String(totalTokens);
    } else if (usdEstimate != null && usdEstimate > 0) {
      el.ovTotalTokens.textContent = `≈ $${usdEstimate.toFixed(6)}`;
    } else {
      el.ovTotalTokens.textContent = "-";
    }
  }
}

function updateCallOverviewError(status, durationMs, usage) {
  const metrics = extractUsageMetrics(usage || {});
  const { promptTokens, completionTokens, totalTokens, usdEstimate } = metrics;

  if (el.ovDuration) {
    el.ovDuration.textContent = formatDurationMs(durationMs);
  }

  if (el.ovStatus) {
    const label = status || "错误";
    el.ovStatus.innerHTML = `
      <span class="call-status-pill error">
        <span class="call-status-dot"></span>
        失败 · ${label}
      </span>
    `;
  }

  if (el.ovPromptTokens) {
    el.ovPromptTokens.textContent =
      promptTokens != null ? String(promptTokens) : "-";
  }
  if (el.ovCompletionTokens) {
    el.ovCompletionTokens.textContent =
      completionTokens != null ? String(completionTokens) : "-";
  }
  if (el.ovTotalTokens) {
    if (totalTokens != null && usdEstimate != null && usdEstimate > 0) {
      el.ovTotalTokens.textContent =
        `${totalTokens}（≈ $${usdEstimate.toFixed(6)}）`;
    } else if (totalTokens != null) {
      el.ovTotalTokens.textContent = String(totalTokens);
    } else if (usdEstimate != null && usdEstimate > 0) {
      el.ovTotalTokens.textContent = `≈ $${usdEstimate.toFixed(6)}`;
    } else {
      el.ovTotalTokens.textContent = "-";
    }
  }
}

  </script>
</body>
</html>





































