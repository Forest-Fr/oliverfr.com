<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Agent Worker 测试面板</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg-page: #edf2ff;
    --bg-card: #ffffff;
    --bg-card-soft: #f5f7ff;
    --border-subtle: #e2e8ff;
    --border-strong: #c7d2fe;
    --text-main: #111827;
    --text-sub: #6b7280;
    --text-mute: #9ca3af;
    --accent: #4f46e5;
    --accent-soft: rgba(79, 70, 229, 0.1);
    --accent-strong: #4338ca;
    --accent-stronger: #312e81;
    --danger: #f97316;
    --danger-soft: rgba(248, 113, 113, 0.18);
    --radius-lg: 24px;
    --radius-md: 16px;
    --radius-sm: 10px;
    --shadow-soft: 0 22px 45px rgba(15, 23, 42, 0.18);
    --shadow-subtle: 0 1px 2px rgba(15, 23, 42, 0.04);
    --shadow-strong: 0 24px 60px rgba(15, 23, 42, 0.35);
    --input-height: 40px;
  }

  * ,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  html, body {
    margin: 0;
    padding: 0;
  }

  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "PingFang SC", "Microsoft YaHei", sans-serif;
    color: var(--text-main);
    background:
      radial-gradient(circle at top left, #e0e7ff 0, transparent 55%),
      radial-gradient(circle at bottom right, #e0f2fe 0, transparent 55%),
      #e5e7eb;
    min-height: 100vh;
  }

  /* ===== 页面整体布局 ===== */

  .page-shell {
    min-height: 100vh;
    padding: 18px 20px;
    display: flex;
    justify-content: center;
    align-items: stretch;
  }

  .app-layout {
    width: 100%;
    max-width: 1440px;
    display: grid;
    grid-template-columns: 290px minmax(520px, 1.45fr) minmax(320px, 380px);
    gap: 20px;
    align-items: flex-start;
  }

  @media (max-width: 1200px) {
    .app-layout {
      grid-template-columns: 260px minmax(0, 1.2fr);
      grid-template-rows: auto auto;
      grid-template-areas:
        "left center"
        "left right";
    }
    .panel-left {
      grid-area: left;
    }
    .panel-main {
      grid-area: center;
    }
    .panel-right {
      grid-area: right;
    }
  }

  @media (max-width: 960px) {
    .page-shell {
      padding: 12px;
    }
    .app-layout {
      max-width: 100%;
      grid-template-columns: minmax(0, 1fr);
      grid-template-areas:
        "center"
        "left"
        "right";
      gap: 12px;
    }
    .panel-left,
    .panel-main,
    .panel-right {
      min-height: auto;
    }
  }

  /* ===== 通用卡片样式（面板） ===== */

  .panel {
    background: linear-gradient(145deg, #f9fbff 0%, #ffffff 55%, #eef2ff 100%);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-subtle);
    box-shadow: var(--shadow-soft);
    padding: 18px 18px 16px;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
  }

  .panel::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background:
      radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.12), transparent 55%),
      radial-gradient(circle at 100% 0, rgba(147, 51, 234, 0.08), transparent 55%);
    opacity: 0.7;
    mix-blend-mode: screen;
  }

  .panel-inner {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .panel-left {
    background:
      radial-gradient(circle at top left, #0f172a 0, #020617 55%, #020617 100%);
    border-radius: var(--radius-lg);
    border: 1px solid rgba(148, 163, 184, 0.4);
    box-shadow: var(--shadow-strong);
    color: #e5e7eb;
    padding: 18px 16px 16px;
  }

  .panel-left::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.24), transparent 55%),
      radial-gradient(circle at 100% 20%, rgba(168, 85, 247, 0.18), transparent 60%);
    opacity: 0.9;
    mix-blend-mode: screen;
  }

  .panel-left .panel-inner {
    z-index: 1;
  }

  .panel-main {
    min-height: 520px;
  }

  .panel-right {
    min-height: 520px;
  }

  /* ===== 左栏：标题区 ===== */

  .brand-title {
    font-size: 18px;
    font-weight: 650;
    letter-spacing: 0.02em;
    color: #f9fafb;
    margin-bottom: 4px;
  }

  .brand-subtitle {
    font-size: 13px;
    color: #cbd5f5;
  }

  .brand-divider {
    height: 1px;
    background: linear-gradient(
      90deg,
      rgba(148, 163, 184, 0.4),
      rgba(148, 163, 184, 0.1)
    );
    margin: 14px 0 10px;
  }

  /* ===== 左栏：环境信息 / Agent 信息 ===== */

  .env-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .env-badge {
    padding: 3px 9px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    background: radial-gradient(circle at 0 0, rgba(129, 140, 248, 0.3), transparent 55%);
    font-size: 11px;
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .env-dot {
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: #22c55e;
    box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.35);
  }

  .env-tag {
    font-size: 11px;
    color: #9ca3af;
  }

  .env-tag strong {
    color: #e5e7eb;
    font-weight: 500;
  }

  /* ===== 左栏：新会话按钮 ===== */

  .new-session-block {
    margin-top: 14px;
    margin-bottom: 10px;
  }

  .new-session-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-radius: 999px;
    padding: 6px 10px 6px 8px;
    border: 1px solid rgba(148, 163, 184, 0.55);
    background:
      radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.35), transparent 60%),
      linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
    box-shadow: 0 12px 30px rgba(15, 23, 42, 0.65);
    cursor: pointer;
  }

  .new-session-main {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .new-session-icon {
    width: 24px;
    height: 24px;
    border-radius: 999px;
    border: 1px solid rgba(191, 219, 254, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at 0 0, #38bdf8, #4f46e5);
    color: #f9fafb;
    font-size: 14px;
  }

  .new-session-text {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .new-session-title {
    font-size: 13px;
    font-weight: 550;
    color: #e5e7eb;
  }

  .new-session-desc {
    font-size: 11px;
    color: #9ca3af;
  }

  .new-session-shortcut {
    font-size: 11px;
    color: #cbd5f5;
    opacity: 0.9;
  }

  /* ===== 左栏：模式切换（本地 / Worker） ===== */

  .mode-toggle {
    margin-top: 10px;
    padding: 7px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.85);
    border: 1px solid rgba(148, 163, 184, 0.55);
    display: flex;
    gap: 4px;
    position: relative;
  }

  .mode-toggle-btn {
    flex: 1;
    border-radius: 999px;
    padding: 5px 8px;
    border: none;
    font-size: 11px;
    color: #e5e7eb;
    background: transparent;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    cursor: pointer;
    position: relative;
    z-index: 1;
    white-space: nowrap;
  }

  .mode-toggle-btn span.mode-label-main {
    font-weight: 500;
  }

  .mode-toggle-btn span.mode-label-sub {
    font-size: 10px;
    color: #9ca3af;
  }

  .mode-toggle-btn.active {
    background:
      radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.35), transparent 60%),
      linear-gradient(135deg, #4f46e5, #6366f1);
    box-shadow: 0 0 0 1px rgba(191, 219, 254, 0.85),
      0 12px 30px rgba(15, 23, 42, 0.85);
  }

  .mode-toggle-btn.active span.mode-label-sub {
    color: #e5e7eb;
  }

  /* ===== 左栏：已保存会话列表 ===== */

  .session-list-header {
    margin-top: 14px;
    margin-bottom: 6px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #9ca3af;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .session-badge-count {
    font-size: 11px;
    padding: 2px 7px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.7);
    border: 1px solid rgba(148, 163, 184, 0.7);
    color: #e5e7eb;
  }

  .session-list {
    margin-top: 4px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: calc(100vh - 280px);
    overflow-y: auto;
    padding-right: 3px;
  }

  .session-list::-webkit-scrollbar {
    width: 5px;
  }

  .session-list::-webkit-scrollbar-track {
    background: transparent;
  }

  .session-list::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.7);
    border-radius: 999px;
  }

  /* ====== PATCH 11-24：缩短“被存储的聊天记录卡片”宽度，避免右边被遮住 ====== */
  .session-card {
    position: relative;
    width: calc(100% - 10px); /* 比侧栏整体略窄，右侧留出 10px 安全边距 */
    padding: 8px 9px 7px;
    border-radius: var(--radius-md);
    background:
      radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.35), transparent 55%),
      linear-gradient(145deg, #020617, #020617);
    border: 1px solid rgba(148, 163, 184, 0.6);
    box-shadow: 0 8px 22px rgba(15, 23, 42, 0.7);
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .session-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
  }

  .session-card-title {
    font-size: 12px;
    font-weight: 500;
    color: #e5e7eb;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .session-card-tools {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .session-icon-btn {
    width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.65);
    background: rgba(15, 23, 42, 0.9);
    color: #e5e7eb;
    font-size: 12px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }

  .session-card-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
    font-size: 11px;
    color: #9ca3af;
  }

  .session-token-pill {
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.8);
    border: 1px solid rgba(148, 163, 184, 0.6);
    color: #e5e7eb;
  }

  /* ===== 中间主区域：顶部信息栏 ===== */

  .main-header {
    margin-bottom: 10px;
  }

  .main-title {
    font-size: 17px;
    font-weight: 630;
    color: var(--text-main);
    margin-bottom: 2px;
  }

  .main-subtitle {
    font-size: 13px;
    color: var(--text-sub);
  }

  .main-meta-row {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
  }

  .pill-muted {
    border-radius: 999px;
    padding: 3px 7px;
    background: var(--bg-card-soft);
    border: 1px solid var(--border-subtle);
  }

  /* ===== 中间主区域：对话区 ===== */

  .chat-box {
    margin-top: 8px;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-subtle);
    background: var(--bg-card);
    box-shadow: var(--shadow-subtle);
    padding: 12px 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    height: 360px;
  }

  .chat-log {
    flex: 1;
    overflow-y: auto;
    font-size: 13px;
    color: var(--text-main);
  }

  .chat-log::-webkit-scrollbar {
    width: 6px;
  }

  .chat-log::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.7);
    border-radius: 999px;
  }

  .chat-input-row {
    margin-top: 8px;
    border-radius: 999px;
    border: 1px solid var(--border-subtle);
    background: var(--bg-card-soft);
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 4px 4px 10px;
  }

  .chat-textarea {
    flex: 1;
    border: none;
    background: transparent;
    resize: none;
    outline: none;
    font-size: 13px;
    padding: 6px 0;
    max-height: 80px;
  }

  .btn-send {
    min-width: 70px;
    height: 32px;
    border-radius: 999px;
    border: none;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: #f9fafb;
    font-size: 13px;
    font-weight: 500;
    box-shadow: 0 10px 25px rgba(79, 70, 229, 0.45);
    cursor: pointer;
    padding: 0 12px;
  }

  /* ===== 右栏：最近一次调用概要 ===== */

  .right-section-title {
    font-size: 13px;
    font-weight: 550;
    color: var(--text-main);
    margin-bottom: 4px;
  }

  .right-section-sub {
    font-size: 11px;
    color: var(--text-sub);
    margin-bottom: 8px;
  }

  .right-summary-card {
    margin-bottom: 10px;
    padding: 8px 9px;
    border-radius: var(--radius-md);
    border: 1px dashed var(--border-subtle);
    background: var(--bg-card-soft);
    font-size: 12px;
  }

  .right-summary-label {
    font-size: 11px;
    color: var(--text-mute);
    margin-bottom: 4px;
  }

  .right-summary-value {
    font-size: 13px;
    color: var(--text-main);
  }

  .right-json-card {
    margin-top: 8px;
    padding: 8px 9px;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-subtle);
    background: #0f172a;
    color: #e5e7eb;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
      "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    min-height: 160px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .right-json-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    font-size: 11px;
    color: #9ca3af;
  }

  .btn-ghost {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.65);
    background: rgba(15, 23, 42, 0.85);
    color: #e5e7eb;
    font-size: 11px;
    padding: 2px 8px;
    cursor: pointer;
  }

  .error-pill {
    position: fixed;
    right: 26px;
    bottom: 18px;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 5px 10px;
    border-radius: 999px;
    background: var(--danger-soft);
    border: 1px solid rgba(248, 113, 113, 0.6);
    color: #7f1d1d;
    font-size: 12px;
    box-shadow: 0 16px 40px rgba(248, 113, 113, 0.35);
  }

  .error-pill-icon {
    width: 18px;
    height: 18px;
    border-radius: 999px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: #f97316;
    color: #fff;
    font-size: 12px;
  }

  @media (max-width: 768px) {
    .error-pill {
      right: 12px;
      bottom: 12px;
      font-size: 11px;
      padding: 4px 8px;
    }
  }
</style>


</head>
<body>
  <div class="app-shell">
    <!-- 手机端顶部左右菜单按钮 -->
    <div class="mobile-top-bar">
      <button class="mobile-toggle-btn mobile-toggle-btn-left" id="btnMobileSidebar" aria-label="展开会话列表">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
      <button class="mobile-toggle-btn mobile-toggle-btn-right" id="btnMobileInsight" aria-label="展开调用概览">
        <div class="mobile-toggle-icon">
          <span></span>
          <span></span>
        </div>
      </button>
    </div>

    <!-- 左侧：会话列表 -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title-row">
          <div class="sidebar-title">
            <span class="status-dot"></span>
            Agent Worker 控制台
          </div>
        </div>
        <div class="sidebar-subtitle">本地对接 · Cloudflare &AI 智能体</div>
        <div class="sidebar-tags">
          <div class="tag-chip"><strong>Agent</strong> worker-agent</div>
          <div class="tag-chip"><strong>Model</strong> gpt-5-mini</div>
          <div class="tag-chip"><strong>Route</strong> Worker → OpenAI Chat</div>
        </div>
        <div class="sidebar-divider"></div>
      </div>

      <div class="sidebar-actions">
        <button class="btn-new-session" id="btnNewSession">
          <span class="btn-icon">＋</span>
          新建会话
        </button>
        <div class="sidebar-env">
          <span class="sidebar-env-dot"></span>
          环境：Dev
        </div>
      </div>

      <div class="session-list" id="sessionList">
        <!-- JS 渲染会话 -->
      </div>

      <div class="sidebar-footer">
        本页面仅作 <strong>AI 智能体链路测试</strong>，不保存服务端日志。
      </div>
    </aside>

    <!-- 中间：主聊天区域 -->
    <main class="main-panel">
      <div class="main-header">
        <div class="main-header-left">
          <div class="breadcrumbs">
            <span>Agent Worker 测试面板</span>
            <span>·</span>
            <span>前端 → Cloudflare  → OpenAI Chat Completions</span>
          </div>
          <div class="agent-title-row">
            <div class="agent-name">Agent Worker 测试面板</div>
            <div class="pill">
              <span>Agent:</span>
              <strong id="currentAgentLabel">worker-agent</strong>
            </div>
            <div class="pill">
              <span>模型:</span>
              <strong id="currentModelLabel">gpt-5-mini</strong>
            </div>
          </div>
        </div>
            <!--
        <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span>Worker: AI Agent</span>
          </div>
        </div>
        -->
               <div class="main-header-right">
          <div class="env-pill">
            <span class="env-pill-dot"></span>
            <span id="routeLabel">模式：直连 Worker</span>
          </div>

          <!-- ===== PATCH BEGIN: Agent / Env 选择控件（Step 4.1） ===== -->
          <div class="agent-env-controls">
            <label for="modeSelect">Call:</label>
            <select id="modeSelect" class="agent-env-select">
              <option value="direct">直连 Worker</option>
              <option value="agent-devops">Agent · devops</option>
            </select>

            <label for="agentSelect">Agent:</label>
            <select id="agentSelect" class="agent-env-select">
              <option value="devops">devops</option>
            </select>

            <label for="envSelect">Env:</label>
            <select id="envSelect" class="agent-env-select">
              <option value="dev">Dev</option>
              <option value="prod" disabled>Prod（预留）</option>
            </select>
          </div>
          <!-- ===== PATCH END ===== -->
 
      </div>

      <section class="chat-surface">
        <div class="chat-messages" id="chatMessages">
          <div class="chat-empty" id="chatEmpty">
            <div>这里会显示你和 Worker 智能体的对话记录。</div>
            <div>试试输入：<strong>「帮我把下面的报错信息按原因拆解一下」</strong>。</div>
          </div>
        </div>

        <div class="chat-input-bar">
          <div class="chat-input-row">
            <textarea
              id="chatInput"
              class="chat-input"
              placeholder="在这里输入：比如『帮我总结一下今天要做的三件事』，然后按 Ctrl+Enter 或点击发送。"
            ></textarea>
            <button id="btnSend" class="send-button">
              <span class="send-button-icon">↗</span>
              <span id="btnSendLabel">发送</span>
            </button>
          </div>
          <div class="input-hint-row">
            <span>支持多行输入。<strong>Ctrl+Enter</strong> 发送。</span>
            <span id="requestMetaHint">就绪：调用 Cloudflare   &AI智能体。</span>
          </div>
        </div>
      </section>

      <div class="toast" id="toast">
        <span class="toast-icon">⚠️</span>
        <span id="toastText">错误信息</span>
      </div>
    </main>

    <!-- 右侧：调用概览 -->
    <aside class="insight-panel">
      <div class="insight-card">
        <h3>
          调用概览
          <span class="insight-tag">最近一次</span>
        </h3>
        <div class="call-overview-row">
          <span>耗时</span>
          <span id="ovDuration">-</span>
        </div>
        <div class="call-overview-row">
          <span>状态</span>
          <span id="ovStatus">
            <span class="call-status-pill">
              <span class="call-status-dot"></span>
              尚未调用
            </span>
          </span>
        </div>
        <div class="call-overview-row">
          <span>模型</span>
          <span id="ovModel">gpt-5-mini</span>
        </div>
        <div class="call-overview-row">
          <span>Prompt tokens</span>
          <span id="ovPromptTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Completion tokens</span>
          <span id="ovCompletionTokens">-</span>
        </div>
        <div class="call-overview-row">
          <span>Total tokens</span>
          <span id="ovTotalTokens">-</span>
        </div>
      </div>

      <div class="insight-card">
        <div class="raw-json-header">
          <span>原始返回</span>
          <div class="json-buttons">
            <button class="btn-ghost" id="btnToggleJson">展开 JSON</button>
            <button class="btn-ghost" id="btnCopyJson">复制</button>
          </div>
        </div>
        <div class="raw-json-body" id="rawJsonBody">
          <div class="raw-json-placeholder" id="rawJsonPlaceholder">
            尚未调用。调用后这里会显示 Worker 与 OpenAI 返回的完整 JSON。
          </div>
          <pre class="raw-json-pre" id="rawJsonPre" style="display:none;"></pre>
        </div>
      </div>

      <div class="insight-card">
        <h3>
          智能体说明
          <span class="insight-tag">worker-agent · Dev</span>
        </h3>
        <ul class="agent-desc-list">
          <li>· <span>职责：</span>验证 Cloudflare  → OpenAI gpt-5-mini 聊天链路。</li>
          <li>· <span>能力：</span>回答自然语言问题，展示模型与 tokens 信息。</li>
          <li>· <span>限制：</span>不访问业务数据库、不执行写操作工具调用。</li>
          <li>· <span>适用场景：</span>本地联调、链路健康检查、最小可用智能体测试。</li>
        </ul>
      </div>
    </aside>

    <!-- 移动端遮罩 -->
    <div class="mobile-overlay" id="mobileOverlay"></div>
  </div>

  <script>

      // === Config ===
    const WORKER_ENDPOINT = "https://agent.mefans.workers.dev/";

    // ===== PATCH BEGIN: Agent 模式后端端点常量 / Step 4.1 =====
    const AGENT_ENDPOINT = "https://agent.mefans.workers.dev/api/agent";

    const MODE_DIRECT = "direct";
    const MODE_AGENT_DEVOPS = "agent-devops";

    const AGENT_PROFILES = [
      { id: "devops", label: "devops · DevOps Agent" },
      // 后续可以扩展 cs / analytics 等
    ];

    const ENV_PROFILES = [
      { id: "dev", label: "Dev" },
      { id: "prod", label: "Prod", disabled: true }, // 预留
    ];
    // ===== PATCH END =====
    const DB_NAME = "agentWorkerDB";
    const DB_VERSION = 1;
    const SESSION_STORE = "sessions"; // 静态桶：会话 + 右侧 overview
    const MESSAGE_STORE = "messages"; // 动态桶：消息流水
    const MAX_SESSIONS = 50;

    const LS_SESSIONS_KEY = "agentWorker:sessions";
    const LS_MESSAGES_KEY = "agentWorker:messages";

    // === State ===
    let dbPromise = null;
    let useIndexedDB = true;
    let sessions = [];
    let currentSessionId = null;
    let isSending = false;
    let lastRawResponse = "";
// ===== PATCH BEGIN: Agent 模式前端状态 / Step 4.1 =====
    // 当前调用模式：直连 Worker / Agent Runtime
    let currentMode = MODE_DIRECT;
    // 当前 Agent profile（截图中的 devops / cs / analytics 之一，这里先只实现 devops）
    let currentAgentId = "devops";
    // 当前环境：Dev / Prod
    let currentEnvId = "dev";
    // 用于 /api/agent 的 user_id（延迟初始化，写入 localStorage）
    let currentUserId = null;
    // ===== PATCH END =====
        // 移动端抽屉状态（左右）
    let isSidebarOpenMobile = false;
    let isInsightOpenMobile = false;

    let lastOverview = null;
    let currentMobilePanel = null;

    const el = {};

    document.addEventListener("DOMContentLoaded", () => {
      cacheDom();
      bindGlobalEvents();
      initApp();
    });

    async function initApp() {
      try {
        await initIndexedDB();
        await initSessions();
          // ===== PATCH BEGIN: 初始化 Agent 模式 UI 状态 / Step 4.1 =====
        currentUserId = getOrInitUserId();
        applyModeUiState();
        // ===== PATCH END =====
      } catch (err) {
        showFatalError(err);
      }
    }

    function cacheDom() {
      el.appShell = document.querySelector(".app-shell");
       el.mainPanel = document.querySelector(".main-panel");   // ★ 新增：主聊天面板引用
      
      el.sessionList = document.getElementById("sessionList");
      el.btnNewSession = document.getElementById("btnNewSession");
      el.chatMessages = document.getElementById("chatMessages");
      el.chatEmpty = document.getElementById("chatEmpty");
      el.chatInput = document.getElementById("chatInput");
      el.btnSend = document.getElementById("btnSend");
      el.btnSendLabel = document.getElementById("btnSendLabel");
      el.requestMetaHint = document.getElementById("requestMetaHint");
//11.23新增step4.1
            el.currentAgentLabel = document.getElementById("currentAgentLabel");
      el.currentModelLabel = document.getElementById("currentModelLabel");
      el.routeLabel = document.getElementById("routeLabel");
      el.modeSelect = document.getElementById("modeSelect");
      el.agentSelect = document.getElementById("agentSelect");
      el.envSelect = document.getElementById("envSelect");

      el.ovDuration = document.getElementById("ovDuration");
      el.ovStatus = document.getElementById("ovStatus");
      el.ovModel = document.getElementById("ovModel");
      el.ovPromptTokens = document.getElementById("ovPromptTokens");
      el.ovCompletionTokens = document.getElementById("ovCompletionTokens");
      el.ovTotalTokens = document.getElementById("ovTotalTokens");

      el.rawJsonBody = document.getElementById("rawJsonBody");
      el.rawJsonPlaceholder = document.getElementById("rawJsonPlaceholder");
      el.rawJsonPre = document.getElementById("rawJsonPre");
      el.btnToggleJson = document.getElementById("btnToggleJson");
      el.btnCopyJson = document.getElementById("btnCopyJson");

      el.toast = document.getElementById("toast");
      el.toastText = document.getElementById("toastText");

            // 移动端抽屉相关（顶栏 + 遮罩 + 左右抽屉 + 整体容器）
      el.appShell = document.querySelector(".app-shell");
      el.mobileTopBar = document.querySelector(".mobile-top-bar");
      el.mobileOverlay = document.getElementById("mobileOverlay");
      el.btnToggleSidebar = document.getElementById("btnToggleSidebar");
      el.btnToggleInsight = document.getElementById("btnToggleInsight");
      el.sidebar = document.querySelector(".sidebar");
      el.insightPanel = document.querySelector(".insight-panel");

      el.btnMobileSidebar = document.getElementById("btnMobileSidebar");
      el.btnMobileInsight = document.getElementById("btnMobileInsight");
      el.mobileOverlay = document.getElementById("mobileOverlay");
    }

    function bindGlobalEvents() {
//11.23新增step4.1
       // ===== PATCH BEGIN: Agent / Env 控件事件绑定 =====
      if (el.modeSelect) {
        el.modeSelect.addEventListener("change", () => {
          const value = el.modeSelect.value === MODE_AGENT_DEVOPS ? MODE_AGENT_DEVOPS : MODE_DIRECT;
          currentMode = value;
          applyModeUiState();
        });
      }

      if (el.agentSelect) {
        el.agentSelect.addEventListener("change", () => {
          currentAgentId = el.agentSelect.value || "devops";
          applyModeUiState();
        });
      }

      if (el.envSelect) {
        el.envSelect.addEventListener("change", () => {
          currentEnvId = el.envSelect.value || "dev";
          applyModeUiState();
        });
      }
      // ===== PATCH END =====
      // ===== 移动端左右抽屉：两条横线菜单 =====
      if (el.btnToggleSidebar) {
        el.btnToggleSidebar.addEventListener("click", () => {
          const willOpen = !isSidebarOpenMobile;
          isSidebarOpenMobile = willOpen;

          if (el.sidebar) {
            el.sidebar.classList.toggle("sidebar-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-right", willOpen);
            // 打开左侧时，确保右侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-left");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-right", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-left");
            }
          }
          if (willOpen && isInsightOpenMobile) {
            // 左侧打开时，顺便关掉右侧抽屉
            isInsightOpenMobile = false;
            if (el.insightPanel) {
              el.insightPanel.classList.remove("insight-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.btnToggleInsight) {
        el.btnToggleInsight.addEventListener("click", () => {
          const willOpen = !isInsightOpenMobile;
          isInsightOpenMobile = willOpen;

          if (el.insightPanel) {
            el.insightPanel.classList.toggle("insight-open", willOpen);
          }
          if (el.appShell) {
            el.appShell.classList.toggle("push-left", willOpen);
            // 打开右侧时，确保左侧关闭
            if (willOpen) {
              el.appShell.classList.remove("push-right");
            }
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.toggle("push-left", willOpen);
            if (willOpen) {
              el.mobileTopBar.classList.remove("push-right");
            }
          }
          if (willOpen && isSidebarOpenMobile) {
            isSidebarOpenMobile = false;
            if (el.sidebar) {
              el.sidebar.classList.remove("sidebar-open");
            }
          }
          updateMobileOverlay();
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          // 点击遮罩：统一关闭左右抽屉 & 复位整体 transform
          isSidebarOpenMobile = false;
          isInsightOpenMobile = false;

          if (el.sidebar) {
            el.sidebar.classList.remove("sidebar-open");
          }
          if (el.insightPanel) {
            el.insightPanel.classList.remove("insight-open");
          }
          if (el.appShell) {
            el.appShell.classList.remove("push-right", "push-left");
          }
          if (el.mobileTopBar) {
            el.mobileTopBar.classList.remove("push-right", "push-left");
          }
          updateMobileOverlay();
        });
      }

      el.btnNewSession.addEventListener("click", () => {
        handleNewSession();
      });

      el.sessionList.addEventListener("click", (event) => {
        const target = event.target;
        const item = target.closest("[data-session-id]");
        if (!item) return;

        const id = item.getAttribute("data-session-id");
        const deleteBtn = target.closest("[data-action='delete-session']");
        const renameBtn = target.closest("[data-action='rename-session']");

        if (deleteBtn) {
          event.stopPropagation();
          handleDeleteSession(id);
          return;
        }

        if (renameBtn) {
          event.stopPropagation();
          handleRenameSession(id);
          return;
        }

        selectSession(id);
      });

      el.btnSend.addEventListener("click", () => {
        triggerSend();
      });

      el.chatInput.addEventListener("keydown", (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          triggerSend();
        }
      });

      el.btnToggleJson.addEventListener("click", () => {
        const isOpen = el.rawJsonBody.classList.toggle("open");
        el.btnToggleJson.textContent = isOpen ? "收起 JSON" : "展开 JSON";
      });

      el.btnCopyJson.addEventListener("click", async () => {
        if (!lastRawResponse) {
          showToast("当前没有可复制的 JSON");
          return;
        }
        try {
          await navigator.clipboard.writeText(lastRawResponse);
          showToast("已复制 JSON 到剪贴板");
        } catch (err) {
          console.error(err);
          showToast("复制失败，请检查浏览器权限");
        }
      });

      if (el.btnMobileSidebar) {
        el.btnMobileSidebar.addEventListener("click", () => {
          toggleMobilePanel("left");
        });
      }

      if (el.btnMobileInsight) {
        el.btnMobileInsight.addEventListener("click", () => {
          toggleMobilePanel("right");
        });
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.addEventListener("click", () => {
          closeMobilePanels();
        });
      }

      window.addEventListener("resize", () => {
        if (!isMobileViewport()) {
          closeMobilePanels();
        }
      });
    }
    //在 bindGlobalEvents 下面加一个小 helper
    // 控制遮罩显示：只要有任一抽屉打开就显示
    function updateMobileOverlay() {
      if (!el.mobileOverlay) return;
      const visible = isSidebarOpenMobile || isInsightOpenMobile;
      if (visible) {
        el.mobileOverlay.classList.add("visible");
      } else {
        el.mobileOverlay.classList.remove("visible");
      }
    }

    function isMobileViewport() {
      return window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
    }

     function toggleMobilePanel(target) {
      if (!isMobileViewport()) return;
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (!sidebar || !insight || !el.appShell || !el.mainPanel) return;

      const isSame = currentMobilePanel === target;
      if (isSame) {
        closeMobilePanels();
        return;
      }

      // 打开任意一侧前，先清理主面板的内联 transform，避免残留
      el.mainPanel.style.transform = "";

      if (target === "left") {
        // 左侧：保持现有行为不变
        sidebar.classList.add("sidebar-open");
        insight.classList.remove("insight-open");

        el.appShell.classList.add("push-right");
        el.appShell.classList.remove("push-left");

        el.mainPanel.classList.add("move-right");
        el.mainPanel.classList.remove("move-left");

        currentMobilePanel = "left";
      } else if (target === "right") {
        // 右侧：抽屉滑出 + 主面板整体向左推
        insight.classList.add("insight-open");
        sidebar.classList.remove("sidebar-open");

        el.appShell.classList.add("push-left");
        el.appShell.classList.remove("push-right");

        // ★ 关键：用右侧抽屉的实际宽度来平移主面板，避免“纯覆盖”
        const drawerWidth = insight.offsetWidth || 0;
        if (drawerWidth > 0) {
          el.mainPanel.style.transform = `translateX(-${drawerWidth}px)`;
        } else {
          // 兜底：偶尔拿不到宽度时，还可以退回 CSS class 方案
          el.mainPanel.classList.add("move-left");
        }
        el.mainPanel.classList.remove("move-right");

        currentMobilePanel = "right";
      }

      if (el.mobileOverlay) {
        el.mobileOverlay.classList.add("visible");
      }
    }



    function closeMobilePanels() {
      const sidebar = document.querySelector(".sidebar");
      const insight = document.querySelector(".insight-panel");
      if (sidebar) sidebar.classList.remove("sidebar-open");
      if (insight) insight.classList.remove("insight-open");

      if (el.appShell) {
        el.appShell.classList.remove("push-right", "push-left");
      }

      if (el.mainPanel) {
        el.mainPanel.classList.remove("move-right", "move-left");
        el.mainPanel.style.transform = ""; // ★ 清掉右侧打开时设置的内联位移
      }

      currentMobilePanel = null;
      if (el.mobileOverlay) {
        el.mobileOverlay.classList.remove("visible");
      }
    }


    // === IndexedDB + localStorage 封装 ===

    async function initIndexedDB() {
      if (!("indexedDB" in window)) {
        useIndexedDB = false;
        console.warn("[IndexedDB] 不支持，自动使用 localStorage。");
        return;
      }

      try {
        dbPromise = new Promise((resolve, reject) => {
          let request;
          try {
            request = indexedDB.open(DB_NAME, DB_VERSION);
          } catch (err) {
            reject(err);
            return;
          }

          request.onerror = () => {
            reject(request.error || new Error("indexedDB open error"));
          };

          request.onsuccess = () => {
            resolve(request.result);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(SESSION_STORE)) {
              const sessionStore = db.createObjectStore(SESSION_STORE, { keyPath: "id" });
              sessionStore.createIndex("updatedAt", "updatedAt", { unique: false });
            }
            if (!db.objectStoreNames.contains(MESSAGE_STORE)) {
              const messageStore = db.createObjectStore(MESSAGE_STORE, { keyPath: "id" });
              messageStore.createIndex("sessionId", "sessionId", { unique: false });
            }
          };
        });

        await dbPromise;
      } catch (err) {
        console.warn("[IndexedDB] 初始化失败，自动切换 localStorage。", err);
        dbPromise = null;
        useIndexedDB = false;
      }
    }

    function dbReadAll(storeName, indexName, query, direction = "prev") {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readonly");
              let store = tx.objectStore(storeName);
              if (indexName) {
                store = store.index(indexName);
              }
              const items = [];
              const req = store.openCursor(query, direction);
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  items.push(cursor.value);
                  cursor.continue();
                } else {
                  resolve(items);
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbPut(storeName, value) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.put(value);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDelete(storeName, key) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              const req = store.delete(key);
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve();
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbDeleteWhereMessages(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readwrite");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.openCursor(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                  cursor.delete();
                  cursor.continue();
                } else {
                  resolve();
                }
              };
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    function dbReadMessagesBySession(sessionId) {
      if (!useIndexedDB || !dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            try {
              const tx = db.transaction(MESSAGE_STORE, "readonly");
              const store = tx.objectStore(MESSAGE_STORE);
              const index = store.index("sessionId");
              const req = index.getAll(IDBKeyRange.only(sessionId));
              req.onerror = () => reject(req.error);
              req.onsuccess = () => resolve(req.result || []);
            } catch (e) {
              reject(e);
            }
          })
      );
    }

    async function loadSessionsFromStorage() {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadAll(SESSION_STORE, "updatedAt");
        } catch (err) {
          console.warn("[IndexedDB] 读取 sessions 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_SESSIONS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        console.warn("[localStorage] 读取 sessions 失败。", err);
        return [];
      }
    }

    async function loadMessagesFromStorage(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          return await dbReadMessagesBySession(sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 读取 messages 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }
      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.filter((m) => m.sessionId === sessionId);
      } catch (err) {
        console.warn("[localStorage] 读取 messages 失败。", err);
        return [];
      }
    }

    async function saveSession(session) {
      // 先确保内存 sessions 更新
      const idx = sessions.findIndex((s) => s.id === session.id);
      if (idx === -1) sessions.push(session);
      else sessions[idx] = session;

      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(SESSION_STORE, session);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 session 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
      } catch (err) {
        console.warn("[localStorage] 写入 sessions 失败。", err);
      }
    }

    async function saveMessage(message) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbPut(MESSAGE_STORE, message);
          return;
        } catch (err) {
          console.warn("[IndexedDB] 写入 message 失败，降级到 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      try {
        const raw = localStorage.getItem(LS_MESSAGES_KEY);
        const arr = raw ? (JSON.parse(raw) || []) : [];
        arr.push(message);
        localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arr));
      } catch (err) {
        console.warn("[localStorage] 写入 messages 失败。", err);
      }
    }

    async function deleteSessionAndMessages(sessionId) {
      if (useIndexedDB && dbPromise) {
        try {
          await dbDeleteWhereMessages(sessionId);
          await dbDelete(SESSION_STORE, sessionId);
        } catch (err) {
          console.warn("[IndexedDB] 删除会话失败，尝试 localStorage。", err);
          useIndexedDB = false;
          dbPromise = null;
        }
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          const rawS = localStorage.getItem(LS_SESSIONS_KEY);
          let arrS = rawS ? JSON.parse(rawS) : [];
          if (Array.isArray(arrS)) {
            arrS = arrS.filter((s) => s.id !== sessionId);
            localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(arrS));
          }
          const rawM = localStorage.getItem(LS_MESSAGES_KEY);
          let arrM = rawM ? JSON.parse(rawM) : [];
          if (Array.isArray(arrM)) {
            arrM = arrM.filter((m) => m.sessionId !== sessionId);
            localStorage.setItem(LS_MESSAGES_KEY, JSON.stringify(arrM));
          }
        } catch (err) {
          console.warn("[localStorage] 删除会话失败。", err);
        }
      }
    }

    // === Session / message model ===

    function createSessionObject() {
      const id = crypto.randomUUID ? crypto.randomUUID() : "s_" + Date.now();
      const ts = Date.now();
      return {
        id,
        title: "新会话",
        createdAt: ts,
        updatedAt: ts,
        totalTokens: 0,
        isEmpty: true,
        lastCallOverview: null,
        lastRawJson: "",
      };
    }

    /*function createMessage(sessionId, role, content) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
      };
    }*/
        function createMessage(sessionId, role, content, meta) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
        meta: meta || null,
      };
    }


    async function initSessions() {
      let stored = await loadSessionsFromStorage();
      if (!stored || stored.length === 0) {
        const session = createSessionObject();
        sessions = [session];
        currentSessionId = session.id;
        await saveSession(session);
      } else {
        sessions = stored;
        currentSessionId = sessions[0].id;
      }
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    function formatShortTime(timestamp) {
      if (!timestamp) return "-";
      const d = new Date(timestamp);
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }

    function renderSessionList() {
      el.sessionList.innerHTML = "";
      sessions.forEach((session) => {
        const item = document.createElement("div");
        item.className = "session-item" + (session.id === currentSessionId ? " active" : "");
        item.setAttribute("data-session-id", session.id);

        const headerRow = document.createElement("div");
        headerRow.className = "session-header-row";

        const headerLeft = document.createElement("div");
        headerLeft.className = "session-header-left";

        const titleSpan = document.createElement("div");
        titleSpan.className = "session-title";
        titleSpan.textContent = session.title || "未命名会话";

        const renameBtn = document.createElement("button");
        renameBtn.className = "btn-rename-session";
        renameBtn.setAttribute("data-action", "rename-session");
        renameBtn.textContent = "✎";

        headerLeft.appendChild(titleSpan);
        headerLeft.appendChild(renameBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-delete-session";
        deleteBtn.setAttribute("data-action", "delete-session");
        deleteBtn.textContent = "×";

        headerRow.appendChild(headerLeft);
        headerRow.appendChild(deleteBtn);

        const metaRow = document.createElement("div");
        metaRow.className = "session-meta";

        const timeSpan = document.createElement("span");
        timeSpan.textContent = formatShortTime(session.updatedAt);

        const tokenSpan = document.createElement("span");
        tokenSpan.className = "session-tokens";
        tokenSpan.textContent = `${session.totalTokens || 0} tokens`;

        metaRow.appendChild(timeSpan);
        metaRow.appendChild(tokenSpan);

        item.appendChild(headerRow);
        item.appendChild(metaRow);

        el.sessionList.appendChild(item);
      });
    }

    async function selectSession(sessionId) {
      if (!sessionId) return;
      if (sessionId === currentSessionId) {
        if (isMobileViewport()) closeMobilePanels();
        return;
      }
      currentSessionId = sessionId;
      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
      if (isMobileViewport()) closeMobilePanels();
    }

    async function renderCurrentSessionMessages() {
      if (!currentSessionId) return;
      const messages = await loadMessagesFromStorage(currentSessionId);
      if (!messages || messages.length === 0) {
        el.chatMessages.innerHTML = "";
        el.chatMessages.appendChild(el.chatEmpty);
        el.chatEmpty.style.display = "flex";
        return;
      }
      el.chatMessages.innerHTML = "";
    /*  messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false);
        });*/

            messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false, msg.meta || null);
        });

      scrollToBottom();
    }

    async function handleNewSession() {
      const existingEmpty = sessions.find((s) => s.isEmpty);
      if (existingEmpty) {
        currentSessionId = existingEmpty.id;
        renderSessionList();
        await renderCurrentSessionMessages();
        hydrateCurrentSessionInsights();
        if (isMobileViewport()) closeMobilePanels();
        return;
      }

      const session = createSessionObject();
      sessions.unshift(session);
      currentSessionId = session.id;
      await saveSession(session);
      await cleanupOldSessionsIfNecessary();

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleDeleteSession(sessionId) {
      if (!sessionId) return;

      await deleteSessionAndMessages(sessionId);

      sessions = sessions.filter((s) => s.id !== sessionId);

      if (sessions.length === 0) {
        const newSession = createSessionObject();
        sessions = [newSession];
        currentSessionId = newSession.id;
        await saveSession(newSession);
      } else if (currentSessionId === sessionId) {
        currentSessionId = sessions[0].id;
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 同步 sessions 失败。", e);
        }
      }

      renderSessionList();
      await renderCurrentSessionMessages();
      hydrateCurrentSessionInsights();
    }

    async function handleRenameSession(sessionId) {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) return;
      const newTitle = window.prompt("请输入会话标题：", session.title || "");
      if (newTitle === null) return;
      const trimmed = newTitle.trim();
      session.title = trimmed || "未命名会话";
      session.updatedAt = Date.now();
      await saveSession(session);
      renderSessionList();
    }

    async function cleanupOldSessionsIfNecessary() {
      if (sessions.length <= MAX_SESSIONS) return;
      const sorted = [...sessions].sort((a, b) => b.updatedAt - a.updatedAt);
      const keep = sorted.slice(0, MAX_SESSIONS);
      const remove = sorted.slice(MAX_SESSIONS);

      sessions = keep;

      for (const s of remove) {
        await deleteSessionAndMessages(s.id);
      }

      if (!useIndexedDB || !dbPromise) {
        try {
          localStorage.setItem(LS_SESSIONS_KEY, JSON.stringify(sessions));
        } catch (e) {
          console.warn("[localStorage] 清理 sessions 时同步失败。", e);
        }
      }
    }
//11.23新增step4.1相关的4段函数
        // ===== PATCH BEGIN: Agent 模式辅助函数 / userId =====
    function getOrInitUserId() {
      const key = "agentWorker:userId";
      try {
        const existing = localStorage.getItem(key);
        if (existing) return existing;

        const id =
          (crypto.randomUUID && crypto.randomUUID()) ||
          "u_" + Date.now() + "_" + Math.random().toString(16).slice(2);
        localStorage.setItem(key, id);
        return id;
      } catch (e) {
        return "anonymous";
      }
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent 模式 UI 状态同步 =====
    function applyModeUiState() {
      if (el.modeSelect) {
        el.modeSelect.value = currentMode;
      }
      if (el.agentSelect) {
        el.agentSelect.value = currentAgentId;
        // 只有 Agent 模式才允许切换 Agent
        el.agentSelect.disabled = currentMode !== MODE_AGENT_DEVOPS;
      }
      if (el.envSelect) {
        el.envSelect.value = currentEnvId;
      }

      if (el.currentAgentLabel) {
        el.currentAgentLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? `agent:${currentAgentId}`
            : "worker-direct";
      }

      if (el.routeLabel) {
        el.routeLabel.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "模式：Agent Runtime /api/agent"
            : "模式：直连 Worker";
      }

      // 仅在非发送中时更新提示文案
      if (el.requestMetaHint && !isSending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: Agent payload 组装 & runtime 摘要提取 =====
    function buildAgentPayload(inputText) {
      return {
        tenant_id: "oliverfr",
        agent: currentAgentId,
        env: currentEnvId,
        session_id: currentSessionId,
        user_id: currentUserId || "anonymous",
        input: inputText,
        meta: {
          source: "agent-worker-ui",
          mode: currentMode,
          ua: navigator.userAgent || "",
        },
      };
    }

function extractRuntimeMetaFromAgentResponse(data) {
      if (!data || typeof data !== "object") return null;

      // 1）runtime 主体：优先 runtime / agent_runtime
      const rt =
        (data.runtime && typeof data.runtime === "object" && data.runtime) ||
        (data.agent_runtime && typeof data.agent_runtime === "object" && data.agent_runtime) ||
        null;

      // 如果连 runtime 容器都没有，尽量从顶层抽一点基础信息，避免返回 null
      if (!rt) {
        return {
          graphVersion: data.graph_version || data.graphVersion || null,
          taskType: data.task_type || data.taskType || null,
          traceId: data.trace_id || data.traceId || data._gateway_trace_id || null,
          nodeCount: 0,
          toolCount: 0,
          ragHits: 0,
          rawNodes: [],
          rawTools: [],
          rawRag: null,
        };
      }

      // 2）节点/步骤：nodes / nodes_executed / steps / flow
      const nodesRaw =
        rt.nodes_executed ||
        rt.nodes ||
        rt.steps ||
        rt.flow ||
        null;
      const nodes = Array.isArray(nodesRaw) ? nodesRaw : [];

      // 3）工具调用：tools / tools_used / tool_calls
      const toolsRaw =
        rt.tools ||
        rt.tools_used ||
        rt.tool_calls ||
        null;
      const tools = Array.isArray(toolsRaw) ? toolsRaw : [];

      // 4）RAG 统计：rag / rag_stats / rag_status
      const rag =
        (rt.rag && typeof rt.rag === "object" && rt.rag) ||
        (rt.rag_stats && typeof rt.rag_stats === "object" && rt.rag_stats) ||
        (rt.rag_status && typeof rt.rag_status === "object" && rt.rag_status) ||
        null;

      let ragHits = 0;
      if (rag) {
        // 常见几种命名：hits_count / hits / top_k / docs[]
        if (typeof rag.hits_count === "number") {
          ragHits = rag.hits_count;
        } else if (typeof rag.hits === "number") {
          ragHits = rag.hits;
        } else if (typeof rag.top_k === "number") {
          ragHits = rag.top_k;
        } else if (Array.isArray(rag.docs)) {
          ragHits = rag.docs.length;
        }
      }

      // 5）graphVersion：runtime.graph_version / runtime.graphVersion / 顶层同名
      const graphVersion =
        rt.graph_version ||
        rt.graphVersion ||
        data.graph_version ||
        data.graphVersion ||
        null;

      // 6）taskType：runtime.task_type / runtime.taskType / 顶层同名
      const taskType =
        rt.task_type ||
        rt.taskType ||
        data.task_type ||
        data.taskType ||
        null;

      // 7）traceId：runtime.trace_id / runtime.traceId / 顶层 trace_id / _gateway_trace_id
      const traceId =
        rt.trace_id ||
        rt.traceId ||
        data.trace_id ||
        data.traceId ||
        data._gateway_trace_id ||
        null;

      // 返回结构保持与原函数完全一致，调用方无需改动
      return {
        graphVersion,
        taskType,
        traceId,
        nodeCount: Array.isArray(nodes) ? nodes.length : 0,
        toolCount: Array.isArray(tools) ? tools.length : 0,
        ragHits,
        rawNodes: nodes,
        rawTools: tools,
        rawRag: rag,
      };
    }
    // ===== PATCH END =====
    // ===== PATCH BEGIN: 统一调用后端（直连 Worker / Agent Runtime） =====
    async function callBackendWithMode(userText) {
      const start = performance.now();
      let durationMs = 0;
      let rawResponse = "";
      let replyText = "";
      let modelName = "gpt-5-mini";
      let usage = null;
      let runtimeMeta = null;
      let status = 0;
      let ok = false;

      try {
        if (currentMode === MODE_AGENT_DEVOPS) {
          const payload = buildAgentPayload(userText);
          const res = await fetch(AGENT_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          durationMs = performance.now() - start;
          status = res.status;
          const text = await res.text();
          rawResponse = text;

          if (!res.ok) {
            return {
              ok: false,
              status,
              durationMs,
              rawResponse,
              replyText,
              modelName,
              usage,
              runtimeMeta,
            };
          }

          let data = null;
          try {
            data = text ? JSON.parse(text) : null;
          } catch (_) {
            data = null;
          }

          if (data) {
            replyText = data.reply || data.output || "";
            modelName =
              data.model ||
              (data.runtime && data.runtime.model_profile) ||
              modelName;
            usage = data.usage || (data.cost && data.cost.usage) || null;
            runtimeMeta = extractRuntimeMetaFromAgentResponse(data);
          }

          ok = true;
          return {
            ok,
            status,
            durationMs,
            rawResponse,
            replyText,
            modelName,
            usage,
            runtimeMeta,
          };
        } else {
          // 直连 Worker 原逻辑
          const res = await fetch(WORKER_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ input: userText }),
          });
          durationMs = performance.now() - start;
          status = res.status;
          const text = await res.text();
          rawResponse = text;

          if (!res.ok) {
            return {
              ok: false,
              status,
              durationMs,
              rawResponse,
              replyText,
              modelName,
              usage,
              runtimeMeta,
            };
          }

          let data = null;
          try {
            data = text ? JSON.parse(text) : null;
          } catch (_) {
            data = null;
          }

          if (data) {
            replyText = data.output || "";
            modelName = data.model || modelName;
            usage = data.usage || null;
          }

          ok = true;
          return {
            ok,
            status,
            durationMs,
            rawResponse,
            replyText,
            modelName,
            usage,
            runtimeMeta,
          };
        }
      } catch (err) {
        durationMs = performance.now() - start;
        rawResponse = String(err || "Unknown error");
        return {
          ok: false,
          status: "network_error",
          durationMs,
          rawResponse,
          replyText: "",
          modelName,
          usage: null,
          runtimeMeta: null,
        };
      }
    }
    // ===== PATCH END =====
  
    // === Worker 调用 ===

    /*async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMsg = createMessage(currentSessionId, "user", raw);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true);
      el.chatInput.value = "";

      const start = performance.now();
      let ok = false;
      let modelName = "gpt-5-mini";
      let usage = null;
      let outputText = "";
      lastRawResponse = "";
      lastOverview = null;

      try {
        const res = await fetch(WORKER_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: raw }),
        });

        const durationMs = performance.now() - start;

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          lastRawResponse = text || "";
          updateCallOverviewError(res.status, durationMs, null);
          updateRawJson(text || "");
          lastOverview = {
            ok: false,
            status: res.status,
            durationMs,
            modelName,
            usage: null,
          };
          showToast("Worker 调用失败，请检查 Worker 日志。");
        } else {
          const data = await res.json();
          ok = true;
          outputText = data.output || "";
          modelName = data.model || modelName;
          usage = data.usage || null;
          lastRawResponse = JSON.stringify(data, null, 2);
          updateCallOverviewSuccess(durationMs, modelName, usage);
          updateRawJson(lastRawResponse);
          lastOverview = {
            ok: true,
            status: res.status || 200,
            durationMs,
            modelName,
            usage: usage || null,
          };
        }
      } catch (err) {
        console.error(err);
        const durationMs = performance.now() - start;
        updateCallOverviewError("网络错误", durationMs, null);
        lastRawResponse = String(err || "Unknown error");
        updateRawJson(lastRawResponse);
        lastOverview = {
          ok: false,
          status: "network_error",
          durationMs,
          modelName,
          usage: null,
        };
        showToast("网络异常，无法访问 Worker。");
      } finally {
        isSending = false;
        setSendingState(false);
      }

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          outputText || "（Worker 未返回内容）"
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", outputText || "（Worker 未返回内容）", true);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();
    }*/
    // === Worker 调用 ===

    async function triggerSend() {
      if (isSending) return;
      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("请输入内容后再发送。");
        return;
      }
      if (!currentSessionId) {
        showToast("当前会话未就绪，请刷新页面。");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMeta = {
        mode: currentMode,
      };

      const userMsg = createMessage(currentSessionId, "user", raw, userMeta);
      await saveMessage(userMsg);

      const session = sessions.find((s) => s.id === currentSessionId);
      if (session && (session.isEmpty || !session.title || session.title === "新会话")) {
        session.isEmpty = false;
        session.title = deriveTitleFromText(raw);
        session.updatedAt = Date.now();
        await saveSession(session);
      }

      appendMessageBubble("user", raw, true, userMeta);
      el.chatInput.value = "";

      // ===== PATCH BEGIN: 按模式调用后端（直连 / Agent） =====
      const result = await callBackendWithMode(raw);
      const {
        ok,
        status,
        durationMs,
        rawResponse,
        replyText,
        modelName,
        usage,
        runtimeMeta,
      } = result;

      lastRawResponse = rawResponse || "";
      lastOverview = {
        ok,
        status,
        durationMs,
        modelName,
        usage: usage || null,
        mode: currentMode,
        runtimeMeta: runtimeMeta || null,
      };

      if (ok) {
        updateCallOverviewSuccess(
          typeof durationMs === "number" ? durationMs : 0,
          modelName,
          usage || null
        );
      } else {
        updateCallOverviewError(
          status || "-",
          typeof durationMs === "number" ? durationMs : null,
          usage || null
        );
      }
      updateRawJson(rawResponse || "");

      if (!ok) {
        if (status === "network_error") {
          showToast("网络异常，无法访问后端。");
        } else if (currentMode === MODE_AGENT_DEVOPS) {
          showToast(`Agent 调用失败（${status}），请检查 Agent Worker 日志。`);
        } else {
          showToast(`Worker 调用失败（${status}），请检查 Worker 日志。`);
        }
      }
      // ===== PATCH END =====

      const sessionForMeta = sessions.find((s) => s.id === currentSessionId);

      if (ok) {
        const safeReply = replyText || "（后端未返回内容）";
        const assistantMeta = {
          mode: currentMode,
          runtimeMeta: runtimeMeta || null,
        };
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          safeReply,
          assistantMeta
        );
        await saveMessage(assistantMsg);

        if (sessionForMeta) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          sessionForMeta.totalTokens =
            (sessionForMeta.totalTokens || 0) + usedTokens;
          sessionForMeta.updatedAt = Date.now();
        }

        appendMessageBubble("assistant", safeReply, true, assistantMeta);
        scrollToBottom();
      }

      if (sessionForMeta && lastOverview) {
        sessionForMeta.lastCallOverview = lastOverview;
        sessionForMeta.lastRawJson = lastRawResponse;
        if (!sessionForMeta.updatedAt) {
          sessionForMeta.updatedAt = Date.now();
        }
        await saveSession(sessionForMeta);
      }

      if (ok) {
        renderSessionList();
      }

      hydrateCurrentSessionInsights();

      isSending = false;
      setSendingState(false);
    }

    function deriveTitleFromText(text) {
      const trimmed = text.replace(/\s+/g, " ").trim();
      if (!trimmed) return "新会话";
      return trimmed.length > 22 ? trimmed.slice(0, 22) + "…" : trimmed;
    }

    /*function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";
      el.requestMetaHint.textContent = sending
        ? "正在调用 Cloudflare  &AI智能体…"
        : "就绪：调用 Cloudflare Worker 智能体。";
    }*/
        function setSendingState(sending) {
      el.btnSend.disabled = sending;
      el.btnSendLabel.textContent = sending ? "调用中…" : "发送";

      if (!el.requestMetaHint) return;

      if (sending) {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "正在调用 Agent Runtime 智能体…"
            : "正在调用 Cloudflare Worker 智能体…";
      } else {
        el.requestMetaHint.textContent =
          currentMode === MODE_AGENT_DEVOPS
            ? "就绪：调用 Agent Runtime 智能体。"
            : "就绪：调用 Cloudflare Worker 智能体。";
      }
    }


function appendMessageBubble(role, content, hideEmptyHint, meta) {
  if (hideEmptyHint && el.chatEmpty.parentNode === el.chatMessages) {
    el.chatEmpty.style.display = "none";
    el.chatMessages.innerHTML = "";
  }

  const bubble = document.createElement("div");
  bubble.className = "chat-message " + role;
  bubble.textContent = content;
  el.chatMessages.appendChild(bubble);

  // ===== PATCH BEGIN: Agent Trace 可视化（仅 Agent 模式的 assistant 消息） =====
  if (
    role === "assistant" &&
    meta &&
    meta.mode === MODE_AGENT_DEVOPS &&
    meta.runtimeMeta
  ) {
    const rm = meta.runtimeMeta;

    const nodeCount =
      typeof rm.nodeCount === "number" ? rm.nodeCount : 0;
    const toolCount =
      typeof rm.toolCount === "number" ? rm.toolCount : 0;
    const ragHits =
      typeof rm.ragHits === "number" ? rm.ragHits : 0;
    const task = rm.taskType || "-";
    const traceId = rm.traceId || "-";

    const summary = document.createElement("div");
    summary.className = "agent-trace-summary";
    summary.innerHTML =
      `<strong>Agent trace</strong> · task=${task} · nodes=${nodeCount}` +
      ` · tools=${toolCount} · RAG hits=${ragHits} · trace=${traceId}（点击展开详情）`;

    const detail = document.createElement("div");
    detail.className = "agent-trace-detail";
    const lines = [];

    if (Array.isArray(rm.rawNodes) && rm.rawNodes.length) {
      lines.push("Nodes:");
      rm.rawNodes.forEach((n, idx) => {
        const label = n.name || n.id || `node_${idx + 1}`;
        const status = n.status || n.state || "done";
        lines.push(`  - ${label} [${status}]`);
      });
    }

    if (Array.isArray(rm.rawTools) && rm.rawTools.length) {
      lines.push("");
      lines.push("Tools:");
      rm.rawTools.forEach((t, idx) => {
        const name = t.name || t.tool || `tool_${idx + 1}`;
        const status = t.status || t.state || "ok";
        lines.push(`  - ${name} [${status}]`);
      });
    }

    if (rm.rawRag) {
      lines.push("");
      lines.push("RAG:");
      lines.push(`  - hits ≈ ${ragHits}`);
    }

    if (!lines.length) {
      lines.push("（Agent runtime 未返回详细 trace，仅有汇总信息。）");
    }

    detail.textContent = lines.join("\n");

    summary.addEventListener("click", () => {
      detail.classList.toggle("open");
    });

    el.chatMessages.appendChild(summary);
    el.chatMessages.appendChild(detail);
  }
  // ===== PATCH END =====
}


    function scrollToBottom() {
      requestAnimationFrame(() => {
        el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
      });
    }

    // === 调用概览 / JSON ===

    /*function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }*/
    function resetCallOverview() {
      el.ovDuration.textContent = "-";
      el.ovModel.textContent = "gpt-5-mini";
      if (el.currentModelLabel) {
        el.currentModelLabel.textContent = "gpt-5-mini";
      }
      el.ovPromptTokens.textContent = "-";
      el.ovCompletionTokens.textContent = "-";
      el.ovTotalTokens.textContent = "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 尚未调用';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);
    }

    /*function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }*/
    function hydrateCurrentSessionInsights() {
      const session = sessions.find((s) => s.id === currentSessionId) || null;
      if (!session || !session.lastCallOverview || !session.lastRawJson) {
        resetCallOverview();
        updateRawJson("");
        applyModeUiState();
        return;
      }
      const overview = session.lastCallOverview;
      const modelName = overview.modelName || "gpt-5-mini";
      const usage = overview.usage || null;

      if (overview.mode) {
        currentMode = overview.mode;
      }
      applyModeUiState();

      if (overview.ok) {
        updateCallOverviewSuccess(
          typeof overview.durationMs === "number" ? overview.durationMs : 0,
          modelName,
          usage
        );
      } else {
        updateCallOverviewError(
          overview.status || "-",
          typeof overview.durationMs === "number" ? overview.durationMs : null,
          usage
        );
      }
      updateRawJson(session.lastRawJson || "");
    }

    /*function updateCallOverviewSuccess(durationMs, modelName, usage) {
      el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 成功';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      el.ovModel.textContent = modelName || "gpt-5-mini";
      const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
      el.ovPromptTokens.textContent = pt;
      el.ovCompletionTokens.textContent = ct;
      el.ovTotalTokens.textContent = tt;
    }*/
    function updateCallOverviewSuccess(durationMs, modelName, usage) {
      el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      const pill = document.createElement("span");
      pill.className = "call-status-pill";
      pill.innerHTML = '<span class="call-status-dot"></span> 成功';
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      const modelText = modelName || "gpt-5-mini";
      el.ovModel.textContent = modelText;
      if (el.currentModelLabel) {
        el.currentModelLabel.textContent = modelText;
      }

      const pt = (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt = (usage && (usage.total_tokens || usage.totalTokens)) || "-";
      el.ovPromptTokens.textContent = pt;
      el.ovCompletionTokens.textContent = ct;
      el.ovTotalTokens.textContent = tt;

      applyModeUiState();
    }

    function updateCallOverviewError(status, durationMs, usage) {
      el.ovDuration.textContent =
        typeof durationMs === "number" ? `${durationMs.toFixed(0)} ms` : "-";

      const pill = document.createElement("span");
      pill.className = "call-status-pill error";
      pill.innerHTML = `<span class="call-status-dot"></span> 失败（${status}）`;
      el.ovStatus.innerHTML = "";
      el.ovStatus.appendChild(pill);

      if (!usage) {
        el.ovPromptTokens.textContent = "-";
        el.ovCompletionTokens.textContent = "-";
        el.ovTotalTokens.textContent = "-";
      }
    }

     function updateRawJson(text) {
      if (!text) {
        // 没有内容时，同时清空复制用的 lastRawResponse
        lastRawResponse = "";
        el.rawJsonPlaceholder.style.display = "block";
        el.rawJsonPre.style.display = "none";
        el.rawJsonPre.textContent = "";
        return;
      }

      // 同步 lastRawResponse，保证“复制 JSON”按钮和右侧展示始终一致
      if (typeof text === "string") {
        lastRawResponse = text;
      } else {
        try {
          lastRawResponse = JSON.stringify(text, null, 2);
        } catch {
          lastRawResponse = String(text);
        }
      }

      el.rawJsonPlaceholder.style.display = "none";
      el.rawJsonPre.style.display = "block";

      try {
        const parsed = typeof text === "string" ? JSON.parse(text) : text;
        el.rawJsonPre.textContent = JSON.stringify(parsed, null, 2);
      } catch {
        // 解析失败时，直接展示 lastRawResponse 文本
        el.rawJsonPre.textContent = lastRawResponse;
      }
    }


       // === Toast ===

    let toastTimer = null;

    function showToast(message) {
      el.toastText.textContent = message;
      el.toast.classList.add("visible");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.toast.classList.remove("visible");
      }, 2800);
    }

    function showFatalError(err) {
      console.error(err);
      showToast("初始化失败，请检查浏览器控制台。");
    }

    // === Mobile drawer logic · 仅手机端使用 ===
    (function () {
      const mainPanel  = document.querySelector(".main-panel");
      const sidebarEl  = document.querySelector(".sidebar");
      const insightEl  = document.querySelector(".insight-panel");
      const overlayEl  = document.getElementById("mobileOverlay");
      const btnSidebar = document.getElementById("btnMobileSidebarToggle");
      const btnInsight = document.getElementById("btnMobileInsightToggle");

      // 桌面端或元素缺失时，直接退出，不影响其它逻辑
      if (!mainPanel || !sidebarEl || !overlayEl || !btnSidebar || !btnInsight) return;

      let sidebarOpen = false;
      let insightOpen = false;

      function syncOverlay() {
        if (sidebarOpen || insightOpen) {
          overlayEl.classList.add("visible");
        } else {
          overlayEl.classList.remove("visible");
        }
      }

      // 左侧会话栏按钮：打开时主面板向右推
      btnSidebar.addEventListener("click", () => {
        sidebarOpen = !sidebarOpen;
        sidebarEl.classList.toggle("sidebar-open", sidebarOpen);
        mainPanel.classList.toggle("push-right", sidebarOpen);

        if (sidebarOpen) {
          // 只允许一侧打开
          insightOpen = false;
          if (insightEl) insightEl.classList.remove("insight-open");
          mainPanel.classList.remove("push-left");
        }

        syncOverlay();
      });

      // 右侧调用概览按钮：打开时主面板向左推
      btnInsight.addEventListener("click", () => {
        insightOpen = !insightOpen;
        if (insightEl) {
          insightEl.classList.toggle("insight-open", insightOpen);
        }
        mainPanel.classList.toggle("push-left", insightOpen);

        if (insightOpen) {
          sidebarOpen = false;
          sidebarEl.classList.remove("sidebar-open");
          mainPanel.classList.remove("push-right");
        }

        syncOverlay();
      });

      // 点击遮罩：关闭两边抽屉 & 还原主界面
      overlayEl.addEventListener("click", () => {
        sidebarOpen = false;
        insightOpen = false;
        sidebarEl.classList.remove("sidebar-open");
        if (insightEl) insightEl.classList.remove("insight-open");
        mainPanel.classList.remove("push-right");
        mainPanel.classList.remove("push-left");
        syncOverlay();
      });
    })();
  </script>
</body>
</html>





























