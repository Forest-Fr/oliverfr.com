<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Agent Worker æµ‹è¯•é¢æ¿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg-page: #edf2ff;
    --bg-card: #ffffff;
    --bg-card-soft: #f5f7ff;
    --border-subtle: #e2e8ff;
    --border-strong: #c7d2fe;
    --text-main: #111827;
    --text-sub: #6b7280;
    --text-mute: #9ca3af;
    --accent: #4f46e5;
    --accent-soft: rgba(79, 70, 229, 0.1);
    --accent-strong: #3730a3;
    --danger: #ef4444;
    --radius-lg: 18px;
    --radius-md: 10px;
    --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.14);
    --shadow-subtle: 0 8px 20px rgba(15, 23, 42, 0.12);
    --sidebar-width: 280px;
    --insight-width: 320px;
  }

  * {
    box-sizing: border-box;
  }

  html,
  body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "Segoe UI", sans-serif;
    background: radial-gradient(circle at top, #e0e7ff 0, #eef2ff 55%, #e5e7eb 100%);
    color: var(--text-main);
  }

  body {
    display: flex;
    justify-content: center;
    align-items: stretch;
    padding: 20px;
  }

  .app-shell {
    display: flex;
    flex-direction: row;
    width: min(1320px, 100%);
    height: 100%;
    max-height: 880px;
    background: linear-gradient(145deg, #f9fafb, #eef2ff);
    border-radius: 26px;
    box-shadow: var(--shadow-soft);
    overflow: hidden;
    border: 1px solid rgba(148, 163, 184, 0.45);
    position: relative;
  }

  /* å·¦ä¾§ï¼šä¼šè¯åˆ—è¡¨ */

  .sidebar {
    width: var(--sidebar-width);
    background: radial-gradient(circle at top left, #1e293b 0, #020617 60%);
    color: #e5e7eb;
    padding: 18px 18px 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    border-right: 1px solid rgba(148, 163, 184, 0.3);
    position: relative;
    z-index: 1;
  }

  .sidebar-header {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .sidebar-title-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-title {
    font-weight: 700;
    font-size: 18px;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-dot {
    width: 9px;
    height: 9px;
    border-radius: 999px;
    background: #22c55e;
    box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.35);
  }

  .sidebar-subtitle {
    font-size: 12px;
    color: #9ca3af;
  }

  .sidebar-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
  }

  .tag-chip {
    font-size: 11px;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.65);
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: radial-gradient(circle at top, rgba(148, 163, 184, 0.26), transparent);
  }

  .tag-chip strong {
    font-weight: 600;
  }

  .sidebar-divider {
    height: 1px;
    background: linear-gradient(to right, rgba(148, 163, 184, 0.5), transparent);
    margin-top: 6px;
  }

  .sidebar-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 4px;
  }

  .btn-new-session {
    border: none;
    border-radius: 999px;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: #f9fafb;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, background 0.1s ease-out;
  }

  .btn-new-session:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 24px rgba(79, 70, 229, 0.6);
    background: linear-gradient(135deg, #4338ca, #4f46e5);
  }

  .btn-new-session:active {
    transform: translateY(0);
    box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6);
  }

  .btn-icon {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.4);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }

  .sidebar-env {
    font-size: 11px;
    color: #9ca3af;
    padding: 3px 7px;
    border-radius: 999px;
    border: 1px dashed rgba(148, 163, 184, 0.8);
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: rgba(15, 23, 42, 0.45);
  }

  .sidebar-env-dot {
    width: 5px;
    height: 5px;
    border-radius: 999px;
    background: #22c55e;
  }

  .session-list {
    flex: 1;
    margin-top: 4px;
    padding-top: 4px;
    overflow: hidden auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .session-item {
    position: relative;
    border-radius: 12px;
    padding: 8px 9px;
    cursor: pointer;
    border: 1px solid transparent;
    background: rgba(15, 23, 42, 0.45);
    display: flex;
    flex-direction: column;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .session-item:hover {
    background: rgba(15, 23, 42, 0.7);
    border-color: rgba(148, 163, 184, 0.7);
  }

  .session-item.active {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.6), rgba(37, 99, 235, 0.6));
    border-color: #c7d2fe;
    transform: translateX(2px);
  }

  .session-header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .session-title {
    font-size: 13px;
    font-weight: 500;
    color: #e5e7eb;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    max-width: 190px;
  }

  .session-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
  }

  .session-tokens {
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.8);
    border: 1px solid rgba(148, 163, 184, 0.7);
    font-size: 10px;
  }

  .btn-delete-session {
    border: none;
    background: transparent;
    color: #9ca3af;
    font-size: 13px;
    padding: 0 0 0 8px;
    cursor: pointer;
    opacity: 0.0;
    transition: opacity 0.08s ease-out, color 0.08s ease-out;
  }

  .session-item:hover .btn-delete-session {
    opacity: 1;
  }

  .btn-delete-session:hover {
    color: #fecaca;
  }

  .sidebar-footer {
    margin-top: 6px;
    font-size: 11px;
    color: #6b7280;
  }

  /* ä¸­é—´ï¼šèŠå¤©é¢æ¿ */

  .main-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px 18px 14px;
    gap: 10px;
    position: relative;
    z-index: 0;
  }

  .main-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .main-header-left {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .breadcrumbs {
    font-size: 11px;
    color: var(--text-mute);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .breadcrumbs span {
    display: inline-flex;
    align-items: center;
  }

  .agent-title-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .agent-name {
    font-size: 18px;
    font-weight: 700;
  }

  .pill {
    font-size: 11px;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border-strong);
    background: var(--bg-card-soft);
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .main-header-right {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-mute);
  }

  .env-pill {
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px dashed #d4d4ff;
    background: rgba(219, 234, 254, 0.6);
    color: #1d4ed8;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-weight: 500;
  }

  .env-pill-dot {
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: #22c55e;
  }

  .chat-surface {
    flex: 1;
    border-radius: 18px;
    background: radial-gradient(circle at top left, #eef2ff 0, #f9fafb 55%);
    border: 1px solid var(--border-subtle);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.08);
  }

  .chat-messages {
    flex: 1;
    padding: 16px 18px 12px;
    overflow: auto;
    scroll-behavior: smooth;
  }

  .chat-empty {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    color: var(--text-mute);
    text-align: center;
    font-size: 13px;
  }

  .chat-message {
    max-width: 80%;
    padding: 10px 12px;
    border-radius: 14px;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .chat-message.user {
    margin-left: auto;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    border-bottom-right-radius: 4px;
    box-shadow: 0 10px 22px rgba(79, 70, 229, 0.35);
  }

  .chat-message.assistant {
    margin-right: auto;
    background: rgba(255, 255, 255, 0.95);
    border-bottom-left-radius: 4px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
  }

  .chat-meta-row {
    display: flex;
    justify-content: flex-end;
    font-size: 11px;
    color: var(--text-mute);
    margin-bottom: 6px;
    gap: 8px;
  }

  .chat-input-bar {
    border-top: 1px solid var(--border-subtle);
    padding: 10px 12px;
    background: linear-gradient(to top, rgba(249, 250, 251, 0.94), rgba(249, 250, 251, 0.9));
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .chat-input-row {
    display: flex;
    gap: 8px;
    align-items: flex-end;
  }

  .chat-input {
    flex: 1;
    border-radius: 12px;
    border: 1px solid var(--border-subtle);
    padding: 8px 10px;
    resize: none;
    min-height: 42px;
    max-height: 96px;
    font-size: 14px;
    line-height: 1.4;
    outline: none;
    background: rgba(255, 255, 255, 0.96);
  }

  .chat-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.3);
  }

  .send-button {
    border: none;
    border-radius: 999px;
    padding: 9px 18px;
    font-size: 13px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    background: linear-gradient(135deg, #4f46e5, #6366f1);
    color: white;
    box-shadow: 0 10px 24px rgba(79, 70, 229, 0.5);
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s ease-out;
  }

  .send-button:hover:not([disabled]) {
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(79, 70, 229, 0.6);
  }

  .send-button:active:not([disabled]) {
    transform: translateY(0);
    box-shadow: 0 6px 14px rgba(31, 41, 55, 0.55);
  }

  .send-button[disabled] {
    opacity: 0.65;
    cursor: default;
    box-shadow: 0 4px 10px rgba(148, 163, 184, 0.6);
  }

  .send-button-icon {
    font-size: 14px;
    background: rgba(15, 23, 42, 0.3);
    border-radius: 999px;
    padding: 4px;
    display: inline-flex;
  }

  .input-hint-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-mute);
  }

  .input-hint-row strong {
    color: var(--text-sub);
  }

  /* å³ä¾§ï¼šè°ƒç”¨æ¦‚è§ˆ & åŸå§‹ JSON */

  .insight-panel {
    width: var(--insight-width);
    padding: 14px 14px 12px;
    border-left: 1px solid rgba(148, 163, 184, 0.4);
    background: linear-gradient(160deg, rgba(15, 23, 42, 0.98), #020617);
    color: #e5e7eb;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .insight-card {
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    padding: 10px 11px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.8);
  }

  .insight-card h3 {
    margin: 0 0 6px;
    font-size: 13px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .insight-tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(37, 99, 235, 0.25);
    border: 1px solid rgba(129, 140, 248, 0.7);
  }

  .call-overview-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    margin-bottom: 2px;
    color: #9ca3af;
  }

  .call-overview-row span:last-child {
    color: #e5e7eb;
  }

  .call-overview-row strong {
    color: #e5e7eb;
  }

  .call-status-pill {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid rgba(52, 211, 153, 0.8);
    background: rgba(5, 150, 105, 0.2);
    color: #bbf7d0;
  }

  .call-status-pill.error {
    border-color: rgba(248, 113, 113, 0.9);
    background: rgba(127, 29, 29, 0.85);
    color: #fecaca;
  }

  .call-status-dot {
    width: 6px;
    height: 6px;
    border-radius: 999px;
    background: #22c55e;
  }

  .call-status-pill.error .call-status-dot {
    background: #f97373;
  }

  .raw-json-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #9ca3af;
    margin-bottom: 6px;
  }

  .json-buttons {
    display: flex;
    gap: 6px;
  }

  .btn-ghost {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.7);
    font-size: 11px;
    padding: 3px 8px;
    color: #e5e7eb;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    transition: background 0.08s ease-out, border 0.08s ease-out, transform 0.06s ease-out;
  }

  .btn-ghost:hover {
    background: rgba(15, 23, 42, 0.95);
    border-color: rgba(251, 191, 36, 0.85);
    transform: translateY(-0.5px);
  }

  .btn-ghost:active {
    transform: translateY(0);
  }

  .raw-json-body {
    position: relative;
    border-radius: 10px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    background: radial-gradient(circle at top left, rgba(17, 24, 39, 0.9), #020617);
    padding: 8px 9px;
    max-height: 160px;
    overflow: hidden;
    transition: max-height 0.18s ease-out;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
      "Courier New", monospace;
    font-size: 11px;
    color: #e5e7eb;
  }

  .raw-json-body.open {
    max-height: 260px;
    overflow: auto;
  }

  .raw-json-placeholder {
    color: #6b7280;
    font-size: 11px;
  }

  .raw-json-pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .agent-desc-list {
    list-style: none;
    padding-left: 0;
    margin: 6px 0 0;
    font-size: 11px;
    color: #9ca3af;
  }

  .agent-desc-list li {
    margin-bottom: 4px;
    display: flex;
    gap: 4px;
  }

  .agent-desc-list li span {
    color: #e5e7eb;
  }

  /* toast */

  .toast {
    position: absolute;
    right: 24px;
    bottom: 22px;
    z-index: 40;
    padding: 8px 11px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.92);
    color: #f9fafb;
    font-size: 12px;
    display: none;
    align-items: center;
    gap: 8px;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(248, 250, 252, 0.22);
  }

  .toast.visible {
    display: inline-flex;
  }

  .toast-icon {
    font-size: 14px;
  }

  @media (max-width: 1120px) {
    .insight-panel {
      display: none;
    }
  }

  @media (max-width: 900px) {
    body {
      padding: 0;
    }

    .app-shell {
      border-radius: 0;
      box-shadow: none;
      max-height: none;
      height: 100%;
    }

    /* æ‰‹æœºç«¯ï¼šå·¦ä¾§ä¼šè¯åˆ—è¡¨ä½œä¸ºæŠ½å±‰ï¼Œä¸é»˜è®¤å±•ç¤ºï¼Œç”± JS æ§åˆ¶ .sidebar-open */
    .sidebar {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: min(80vw, 300px);
      max-width: 320px;
      transform: translateX(-100%);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      box-shadow: none;
      z-index: 40;
    }

    .app-shell.sidebar-open .sidebar {
      transform: translateX(0);
      box-shadow: 0 0 0 9999px rgba(15, 23, 42, 0.45);
    }
  }

  /* endpoint pill æ–‡æ¡ˆï¼Œä¸å†æ˜¯å…·ä½“åŸŸåï¼Œé™åˆ¶ä¸€ä¸‹å®½åº¦å³å¯ */
  .aw-pill-endpoint .aw-pill-value {
    max-width: 180px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* åŸºç¡€ï¼šå³ä¾§åŒºåŸŸä¿æŒæ¨ªå‘å¯¹é½ */
  .aw-header-right {
    display: flex;
    align-items: center;
  }

  /* ä¸¤æ¡æ¨ªçº¿çš„æ±‰å ¡æŒ‰é’®ï¼ˆé»˜è®¤éšè—ï¼Œåªæœ‰å°å±æ‰æ˜¾ç¤ºï¼‰ */
  .aw-mobile-menu {
    display: none; /* é»˜è®¤ä¸å±•ç¤ºï¼Œmedia query é‡Œå†æ‰“å¼€ */
    position: relative;
    margin-left: 12px;
    padding: 6px 4px;
    background: transparent;
    border: none;
    cursor: pointer;
  }

  .aw-mobile-menu .line {
    display: block;
    height: 2px;
    border-radius: 999px;
    background: rgba(17, 24, 39, 0.95);
  }

  /* ä¸Šé¢é‚£æ¡æ›´é•¿ */
  .aw-mobile-menu .line-1 {
    width: 18px;
  }

  /* ä¸‹é¢é‚£æ¡æ›´çŸ­ã€ä¸å·¦è¾¹å¯¹é½ */
  .aw-mobile-menu .line-2 {
    width: 12px;
    margin-top: 5px;
  }

  @media (max-width: 768px) {
    .aw-header-right {
      gap: 4px;
    }

    /* æ‰‹æœºç«¯ä¸éœ€è¦çœ‹åˆ°åç«¯ pillï¼Œé¿å…æŒ¤å ç©ºé—´ */
    .aw-header-right .aw-pill-endpoint {
      display: none;
    }

    /* åªåœ¨å°å±å±•ç¤ºæ±‰å ¡æŒ‰é’® */
    .aw-mobile-menu {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-start; /* å·¦è¾¹å¯¹é½ï¼Œå³ä¾§è‡ªç„¶é•¿çŸ­ä¸ä¸€ */
      justify-content: center;
    }
  }
</style>

</head>
<body>
  <div class="app-shell">
  <!-- å·¦ä¾§ï¼šä¼šè¯åˆ—è¡¨ -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title-row">
        <div class="sidebar-title">
          <span class="status-dot"></span>
          Agent Worker æ§åˆ¶å°
        </div>
      </div>
      <!-- 11.22 è°ƒæ•´ï¼šæ–‡æ¡ˆæ”¹ä¸º Cloudflare Worker æ™ºèƒ½ä½“ï¼Œé¿å…æš´éœ²å…·ä½“åŸŸå -->
      <div class="sidebar-subtitle">æœ¬åœ°å¯¹æ¥ Â· Cloudflare AIæ™ºèƒ½ä½“</div>
      <div class="sidebar-tags">
        <div class="tag-chip"><strong>Agent</strong> worker-agent</div>
        <div class="tag-chip"><strong>Model</strong> gpt-5-mini</div>
        <div class="tag-chip"><strong>Route</strong> Worker â†’ OpenAI Chat</div>
      </div>
      <div class="sidebar-divider"></div>
    </div>

    <div class="sidebar-actions">
      <button class="btn-new-session" id="btnNewSession">
        <span class="btn-icon">ï¼‹</span>
        æ–°å»ºä¼šè¯
      </button>
      <div class="sidebar-env">
        <span class="sidebar-env-dot"></span>
        ç¯å¢ƒï¼šDev
      </div>
    </div>

    <div class="session-list" id="sessionList">
      <!-- JS æ¸²æŸ“ä¼šè¯ -->
    </div>

    <div class="sidebar-footer">
      æœ¬é¡µé¢ä»…ä½œ <strong>AI æ™ºèƒ½ä½“é“¾è·¯æµ‹è¯•</strong>ï¼Œä¸ä¿å­˜æœåŠ¡ç«¯æ—¥å¿—ã€‚
    </div>
  </aside>

  <!-- ä¸­é—´ï¼šä¸»èŠå¤©åŒºåŸŸ -->
  <main class="main-panel">
    <div class="main-header">
      <div class="main-header-left">
        <div class="breadcrumbs">
          <span>Agent Worker æµ‹è¯•é¢æ¿</span>
          <span>Â·</span>
          <!-- 11.22 è°ƒæ•´ï¼šè¡¥å…¨ä¸º Cloudflare Worker â†’ OpenAI Chat -->
          <span>å‰ç«¯ â†’ Cloudflare   â†’ OpenAI Chat</span>
        </div>
        <div class="agent-title-row">
          <div class="agent-name">Agent Worker æµ‹è¯•é¢æ¿</div>
          <div class="pill">
            <span>Agent:</span>
            <strong id="currentAgentLabel">worker-agent</strong>
          </div>
          <div class="pill">
            <span>æ¨¡å‹:</span>
            <strong id="currentModelLabel">gpt-5-mini</strong>
          </div>
        </div>
      </div>
      <div class="main-header-right">
        <div class="env-pill">
          <span class="env-pill-dot"></span>
          <span>AIæ™ºèƒ½ä½“</span>
        </div>
        <!-- 11.22 æ–°å¢ï¼šæ‰‹æœºç«¯ä¸¤æ¡æ¨ªçº¿æ±‰å ¡èœå•æŒ‰é’®ï¼Œä»…åœ¨å°å±æ˜¾ç¤ºï¼ˆé…åˆ CSSï¼‰ -->
        <button class="aw-mobile-menu" id="awMobileMenu" aria-label="æ‰“å¼€èœå•">
          <span class="line line-1"></span>
          <span class="line line-2"></span>
        </button>
      </div>
    </div>

    <section class="chat-surface">
      <div class="chat-messages" id="chatMessages">
        <div class="chat-empty" id="chatEmpty">
          <div>è¿™é‡Œä¼šæ˜¾ç¤ºä½ å’Œ Worker æ™ºèƒ½ä½“çš„å¯¹è¯è®°å½•ã€‚</div>
          <div>è¯•è¯•è¾“å…¥ï¼š<strong>ã€Œå¸®æˆ‘æŠŠä¸‹é¢çš„æŠ¥é”™ä¿¡æ¯æŒ‰åŸå› æ‹†è§£ä¸€ä¸‹ã€</strong>ã€‚</div>
        </div>
      </div>

      <div class="chat-input-bar">
        <div class="chat-input-row">
          <textarea
            id="chatInput"
            class="chat-input"
            placeholder="åœ¨è¿™é‡Œè¾“å…¥ï¼šæ¯”å¦‚ã€å¸®æˆ‘æ€»ç»“ä¸€ä¸‹ä»Šå¤©è¦åšçš„ä¸‰ä»¶äº‹ã€ï¼Œç„¶åæŒ‰ Ctrl+Enter æˆ–ç‚¹å‡»å‘é€ã€‚"
          ></textarea>
          <button id="btnSend" class="send-button">
            <span class="send-button-icon">â†—</span>
            <span id="btnSendLabel">å‘é€</span>
          </button>
        </div>
        <div class="input-hint-row">
          <span>æ”¯æŒå¤šè¡Œè¾“å…¥ã€‚<strong>Ctrl+Enter</strong> å‘é€ã€‚</span>
          <!-- 11.22 è°ƒæ•´ï¼šæ–‡æ¡ˆæ”¹ä¸º Cloudflare Worker æ™ºèƒ½ä½“ -->
          <span id="requestMetaHint">å°±ç»ªï¼šè°ƒç”¨ Cloudflare  AIæ™ºèƒ½ä½“ã€‚</span>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">
      <span class="toast-icon">âš ï¸</span>
      <span id="toastText">é”™è¯¯ä¿¡æ¯</span>
    </div>
  </main>

  <!-- å³ä¾§ï¼šè°ƒç”¨æ¦‚è§ˆ -->
  <aside class="insight-panel">
    <div class="insight-card">
      <h3>
        è°ƒç”¨æ¦‚è§ˆ
        <span class="insight-tag">æœ€è¿‘ä¸€æ¬¡</span>
      </h3>
      <div class="call-overview-row">
        <span>è€—æ—¶</span>
        <span id="ovDuration">-</span>
      </div>
      <div class="call-overview-row">
        <span>çŠ¶æ€</span>
        <span id="ovStatus">
          <span class="call-status-pill">
            <span class="call-status-dot"></span>
            å°šæœªè°ƒç”¨
          </span>
        </span>
      </div>
      <div class="call-overview-row">
        <span>æ¨¡å‹</span>
        <span id="ovModel">gpt-5-mini</span>
      </div>
      <div class="call-overview-row">
        <span>Prompt tokens</span>
        <span id="ovPromptTokens">-</span>
      </div>
      <div class="call-overview-row">
        <span>Completion tokens</span>
        <span id="ovCompletionTokens">-</span>
      </div>
      <div class="call-overview-row">
        <span>Total tokens</span>
        <span id="ovTotalTokens">-</span>
      </div>
    </div>

    <div class="insight-card">
      <div class="raw-json-header">
        <span>åŸå§‹è¿”å›</span>
        <div class="json-buttons">
          <button class="btn-ghost" id="btnToggleJson">å±•å¼€ JSON</button>
          <button class="btn-ghost" id="btnCopyJson">å¤åˆ¶</button>
        </div>
      </div>
      <div class="raw-json-body" id="rawJsonBody">
        <div class="raw-json-placeholder" id="rawJsonPlaceholder">
          å°šæœªè°ƒç”¨ã€‚è°ƒç”¨åè¿™é‡Œä¼šæ˜¾ç¤º Worker ä¸ OpenAI è¿”å›çš„å®Œæ•´ JSONã€‚
        </div>
        <pre class="raw-json-pre" id="rawJsonPre" style="display:none;"></pre>
      </div>
    </div>

    <div class="insight-card">
      <h3>
        æ™ºèƒ½ä½“è¯´æ˜
        <span class="insight-tag">worker-agent Â· Dev</span>
      </h3>
      <ul class="agent-desc-list">
        <li>Â· <span>èŒè´£ï¼š</span>éªŒè¯ Cloudflare â†’ OpenAI gpt-5-mini èŠå¤©é“¾è·¯ã€‚</li>
        <li>Â· <span>èƒ½åŠ›ï¼š</span>å›ç­”è‡ªç„¶è¯­è¨€é—®é¢˜ï¼Œå±•ç¤ºæ¨¡å‹ä¸ tokens ä¿¡æ¯ã€‚</li>
        <li>Â· <span>é™åˆ¶ï¼š</span>ä¸è®¿é—®ä¸šåŠ¡æ•°æ®åº“ã€ä¸æ‰§è¡Œå†™æ“ä½œå·¥å…·è°ƒç”¨ã€‚</li>
        <li>Â· <span>é€‚ç”¨åœºæ™¯ï¼š</span>å¯¹æ¥è”è°ƒã€é“¾è·¯å¥åº·æ£€æŸ¥ã€æœ€å°å¯ç”¨æ™ºèƒ½ä½“æµ‹è¯•ã€‚</li>
      </ul>
    </div>
  </aside>
</div>


<script>
  (function () {
    "use strict";

    // === Agent / Model Config ===
    const AGENT_CONFIGS = {
      "worker-agent": {
        key: "worker-agent",
        label: "worker-agent Â· Dev",
        endpoint: "https://agent.mefans.workers.dev/",
        defaultModel: "gpt-5-mini",
      },
      // å¦‚æœä»¥åè¦æ‰©å±•æ›´å¤šæ™ºèƒ½ä½“ï¼Œå¯ä»¥åœ¨è¿™é‡ŒåŠ ï¼š
      // "ops-agent": { key: "ops-agent", label: "Ops Agent", endpoint: "...", defaultModel: "gpt-5-mini" }
    };

    let currentAgentKey = "worker-agent"; // é»˜è®¤æ™ºèƒ½ä½“
    let currentModelName = AGENT_CONFIGS["worker-agent"].defaultModel;

    // === IndexedDB Config ===
    const DB_NAME = "agentWorkerDB";
    const DB_VERSION = 1;
    const SESSION_STORE = "sessions";
    const MESSAGE_STORE = "messages";

    const MAX_DYNAMIC_SESSIONS = 50; // åŠ¨æ€æ¡¶æœ€å¤šä¿ç•™å¤šå°‘æ¡
    const BUCKET_DYNAMIC = "dynamic"; // åŠ¨æ€æ¡¶ï¼šæœ€è¿‘ä¼šè¯ï¼Œè‡ªåŠ¨å›æ”¶
    const BUCKET_STATIC = "static"; // é™æ€æ¡¶ï¼špin å›ºå®šçš„ä¼šè¯ï¼Œä¸è‡ªåŠ¨å›æ”¶

    // === In-memory State ===
    let dbPromise = null;
    let sessions = [];
    let currentSessionId = null;
    let isSending = false;
    let lastRawResponse = "";
    let lastCallDurationMs = 0;

    // ä¼šè¯åˆ—è¡¨è§†å›¾çŠ¶æ€
    const viewState = {
      searchKeyword: "",
      showPinnedOnly: false,
      agentFilter: "all", // "all" æˆ–å…·ä½“ agentKey
    };

    // === DOM refs ===
    const el = {};

    document.addEventListener("DOMContentLoaded", () => {
      cacheDom();
      bindGlobalEvents();
      initIndexedDB()
        .then(initSessions)
        .catch(showFatalError);
    });

    // ==========================
    // DOM ç¼“å­˜
    // ==========================
    function cacheDom() {
      // å·¦ä¾§ä¼šè¯æ 
      el.sessionList = document.getElementById("sessionList");
      el.btnNewSession = document.getElementById("btnNewSession");
      el.sessionSearchInput = document.getElementById("sessionSearch"); // å¯é€‰
      el.sessionFilterPinned = document.getElementById("sessionFilterPinned"); // å¯é€‰
      el.agentFilterSelect = document.getElementById("agentFilter"); // å¯é€‰
      el.agentTabs = document.querySelectorAll("[data-agent-key]"); // å¯é€‰ tab å½¢å¼

      // ä¸­é—´èŠå¤©åŒºåŸŸ
      el.chatMessages = document.getElementById("chatMessages");
      el.chatEmpty = document.getElementById("chatEmpty");
      el.chatInput = document.getElementById("chatInput");
      el.btnSend = document.getElementById("btnSend");
      el.btnSendLabel = document.getElementById("btnSendLabel");
      el.requestMetaHint = document.getElementById("requestMetaHint");

      // é¡¶éƒ¨ / å³ä¾§ Agent/Model å±•ç¤ºï¼ˆå¯é€‰ï¼‰
      el.currentAgentLabel = document.getElementById("currentAgentLabel"); // ä¾‹å¦‚ â€œworker-agent Â· Devâ€
      el.currentModelLabel = document.getElementById("currentModelLabel"); // ä¾‹å¦‚ â€œgpt-5-miniâ€
      el.agentSelector = document.getElementById("agentSelector"); // ä¸‹æ‹‰é€‰æ‹©æ™ºèƒ½ä½“ï¼ˆå¯é€‰ï¼‰
      el.modelSelector = document.getElementById("modelSelector"); // ä¸‹æ‹‰é€‰æ‹©æ¨¡å‹ï¼ˆå¯é€‰ï¼‰

      // è°ƒç”¨æ¦‚è§ˆ
      el.ovDuration = document.getElementById("ovDuration");
      el.ovStatus = document.getElementById("ovStatus");
      el.ovModel = document.getElementById("ovModel");
      el.ovPromptTokens = document.getElementById("ovPromptTokens");
      el.ovCompletionTokens = document.getElementById("ovCompletionTokens");
      el.ovTotalTokens = document.getElementById("ovTotalTokens");

      // åŸå§‹ JSON
      el.rawJsonBody = document.getElementById("rawJsonBody");
      el.rawJsonPlaceholder = document.getElementById("rawJsonPlaceholder");
      el.rawJsonPre = document.getElementById("rawJsonPre");
      el.btnToggleJson = document.getElementById("btnToggleJson");
      el.btnCopyJson = document.getElementById("btnCopyJson");

      // è°ƒç”¨è½¨è¿¹ / å·¥å…·æ—¶é—´çº¿ï¼ˆå¯é€‰å®¹å™¨ï¼‰
      el.traceTimeline = document.getElementById("traceTimeline");
      el.traceEmpty = document.getElementById("traceEmpty");

      // Toast
      el.toast = document.getElementById("toast");
      el.toastText = document.getElementById("toastText");

      // æ‰‹æœºç«¯æ±‰å ¡æŒ‰é’® / å¤–å£³
      el.mobileMenuBtn = document.getElementById("mobileMenuBtn");
      el.appShell = document.querySelector(".app-shell");
    }

    // ==========================
    // äº‹ä»¶ç»‘å®š
    // ==========================
    function bindGlobalEvents() {
      // æ–°å»ºä¼šè¯
      if (el.btnNewSession) {
        el.btnNewSession.addEventListener("click", () => {
          handleNewSession();
           // âœ… æ‰‹æœºç«¯ï¼šæ–°å»ºä¼šè¯åè‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ 
    if (el.appShell) {
      el.appShell.classList.remove("sidebar-open");
    }
          
        });
      }

      // ä¼šè¯åˆ—è¡¨ç‚¹å‡»ï¼ˆé€‰æ‹© / åˆ é™¤ / pinï¼‰
      if (el.sessionList) {
        el.sessionList.addEventListener("click", (event) => {
          const target = event.target;
          const deleteBtn = target.closest("[data-action='delete-session']");
          const pinBtn = target.closest("[data-action='pin-session']");
          const item = target.closest("[data-session-id]");

          if (!item) return;
          const id = item.getAttribute("data-session-id");

          if (deleteBtn) {
            event.stopPropagation();
            handleDeleteSession(id);
            return;
          }

          if (pinBtn) {
            event.stopPropagation();
            handlePinSession(id);
            return;
          }
 // âœ… ç‚¹å‡»æ ‡é¢˜è§¦å‘é‡å‘½åï¼Œè€Œä¸æ˜¯åˆ‡æ¢ä¼šè¯
    if (renameTarget) {
      event.stopPropagation();
      handleRenameSession(id);
      return;
    }

          selectSession(id);
     // âœ… æ‰‹æœºç«¯ï¼šé€‰æ‹©ä¼šè¯åè‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ 
    if (el.appShell) {
      el.appShell.classList.remove("sidebar-open");
    }
          
        });
      }

      // æœç´¢ / è¿‡æ»¤
      if (el.sessionSearchInput) {
        el.sessionSearchInput.addEventListener("input", (e) => {
          viewState.searchKeyword = e.target.value.trim();
          renderSessionList();
        });
      }

      if (el.sessionFilterPinned) {
        el.sessionFilterPinned.addEventListener("change", (e) => {
          viewState.showPinnedOnly = !!e.target.checked;
          renderSessionList();
        });
      }

      if (el.agentFilterSelect) {
        el.agentFilterSelect.addEventListener("change", (e) => {
          viewState.agentFilter = e.target.value || "all";
          renderSessionList();
        });
      }

      // Agent tabs ç‚¹å‡»åˆ‡æ¢
      if (el.agentTabs && el.agentTabs.length) {
        el.agentTabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            const key = tab.getAttribute("data-agent-key");
            if (key && AGENT_CONFIGS[key]) {
              setCurrentAgent(key);
              // é«˜äº® tab
              el.agentTabs.forEach((t) =>
                t.classList.toggle("active", t === tab)
              );
            }
          });
        });
      }

      // Agent / Model ä¸‹æ‹‰åˆ‡æ¢
      if (el.agentSelector) {
        el.agentSelector.addEventListener("change", (e) => {
          const key = e.target.value;
          if (key && AGENT_CONFIGS[key]) {
            setCurrentAgent(key);
          }
        });
      }

      if (el.modelSelector) {
        el.modelSelector.addEventListener("change", (e) => {
          const val = e.target.value;
          if (val) {
            currentModelName = val;
            if (el.currentModelLabel) el.currentModelLabel.textContent = val;
          }
        });
      }

      // å‘é€
      if (el.btnSend) {
        el.btnSend.addEventListener("click", () => {
          triggerSend();
        });
      }

      // Ctrl+Enter å‘é€
      if (el.chatInput) {
        el.chatInput.addEventListener("keydown", (event) => {
          if (
            (event.ctrlKey || event.metaKey) &&
            event.key === "Enter" &&
            !event.shiftKey
          ) {
            event.preventDefault();
            triggerSend();
          }
        });
      }

      // å±•å¼€ / æ”¶èµ· JSON
      if (el.btnToggleJson && el.rawJsonBody) {
        el.btnToggleJson.addEventListener("click", () => {
          const isOpen = el.rawJsonBody.classList.toggle("open");
          el.btnToggleJson.textContent = isOpen ? "æ”¶èµ· JSON" : "å±•å¼€ JSON";
        });
      }

      // å¤åˆ¶ JSON
      if (el.btnCopyJson) {
        el.btnCopyJson.addEventListener("click", async () => {
          if (!lastRawResponse) {
            showToast("å½“å‰æ²¡æœ‰å¯å¤åˆ¶çš„ JSON");
            return;
          }
          try {
            await navigator.clipboard.writeText(lastRawResponse);
            showToast("å·²å¤åˆ¶ JSON åˆ°å‰ªè´´æ¿");
          } catch (err) {
            console.error(err);
            showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™");
          }
        });
      }

      // æ‰‹æœºç«¯æ±‰å ¡ï¼šåˆ‡æ¢å·¦ä¾§ä¼šè¯æŠ½å±‰
      if (el.mobileMenuBtn && el.appShell) {
        el.mobileMenuBtn.addEventListener("click", () => {
          el.appShell.classList.toggle("sidebar-open");
        });
      }
    }

    // ==========================
    // Agent åˆ‡æ¢
    // ==========================
    function getCurrentAgentConfig() {
      return AGENT_CONFIGS[currentAgentKey] || AGENT_CONFIGS["worker-agent"];
    }

    function setCurrentAgent(agentKey) {
      if (!AGENT_CONFIGS[agentKey]) return;
      currentAgentKey = agentKey;
      const cfg = getCurrentAgentConfig();
      currentModelName = cfg.defaultModel || "gpt-5-mini";

      if (el.currentAgentLabel) el.currentAgentLabel.textContent = cfg.label;
      if (el.currentModelLabel) el.currentModelLabel.textContent = currentModelName;

      // å¦‚æœæœ‰ Agent è¿‡æ»¤å™¨ï¼Œé€‰æ‹©å¯¹åº”é¡¹
      if (el.agentFilterSelect) {
        const options = Array.from(el.agentFilterSelect.options);
        const matched = options.find((opt) => opt.value === agentKey);
        if (matched) el.agentFilterSelect.value = agentKey;
      }
    }

    // ==========================
    // IndexedDB helpers
    // ==========================
    function initIndexedDB() {
      if (!("indexedDB" in window)) {
        showToast("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ IndexedDBï¼Œå°†ä½¿ç”¨å†…å­˜æ¨¡å¼ï¼ˆåˆ·æ–°åä¸¢å¤±ï¼‰ã€‚");
        return Promise.resolve();
      }
      if (dbPromise) return dbPromise;

      dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          // sessions
          if (!db.objectStoreNames.contains(SESSION_STORE)) {
            const sessionStore = db.createObjectStore(SESSION_STORE, {
              keyPath: "id",
            });
            sessionStore.createIndex("updatedAt", "updatedAt", { unique: false });
            sessionStore.createIndex("bucket", "bucket", { unique: false });
            sessionStore.createIndex("agentKey", "agentKey", { unique: false });
          }
          // messages
          if (!db.objectStoreNames.contains(MESSAGE_STORE)) {
            const messageStore = db.createObjectStore(MESSAGE_STORE, {
              keyPath: "id",
            });
            messageStore.createIndex("sessionId", "sessionId", { unique: false });
          }
        };
      });

      return dbPromise;
    }

    function dbReadAll(storeName, indexName, query, direction = "prev") {
      if (!dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readonly");
            let store = tx.objectStore(storeName);
            if (indexName) store = store.index(indexName);

            const items = [];
            const req = store.openCursor(query, direction);
            req.onerror = () => reject(req.error);
            req.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                items.push(cursor.value);
                cursor.continue();
              } else {
                resolve(items);
              }
            };
          })
      );
    }

    function dbPut(storeName, value) {
      if (!dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const req = store.put(value);
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve();
          })
      );
    }

    function dbDelete(storeName, key) {
      if (!dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const req = store.delete(key);
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve();
          })
      );
    }

    function dbDeleteWhereMessages(sessionId) {
      if (!dbPromise) return Promise.resolve();
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            const tx = db.transaction(MESSAGE_STORE, "readwrite");
            const store = tx.objectStore(MESSAGE_STORE);
            const index = store.index("sessionId");
            const req = index.openCursor(IDBKeyRange.only(sessionId));
            req.onerror = () => reject(req.error);
            req.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                cursor.delete();
                cursor.continue();
              } else {
                resolve();
              }
            };
          })
      );
    }

    function dbReadMessagesBySession(sessionId) {
      if (!dbPromise) return Promise.resolve([]);
      return dbPromise.then(
        (db) =>
          new Promise((resolve, reject) => {
            const tx = db.transaction(MESSAGE_STORE, "readonly");
            const store = tx.objectStore(MESSAGE_STORE);
            const index = store.index("sessionId");
            const req = index.getAll(IDBKeyRange.only(sessionId));
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve(req.result || []);
          })
      );
    }

    // ==========================
    // Session / message model
    // ==========================
    function createSessionObject() {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "s_" + Date.now() + "_" + Math.random();
      const ts = Date.now();
      return {
        id,
        title: "æ–°ä¼šè¯",
        createdAt: ts,
        updatedAt: ts,
        totalTokens: 0,
        isEmpty: true,
        pinned: false,
        bucket: BUCKET_DYNAMIC, // é»˜è®¤è¿›å…¥åŠ¨æ€æ¡¶
        agentKey: currentAgentKey,
        lastUserText: "",
      };
    }

    function createMessage(sessionId, role, content) {
      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : "m_" + Date.now() + "_" + Math.random();
      return {
        id,
        sessionId,
        role,
        content,
        createdAt: Date.now(),
      };
    }

    
    // æ—§ç‰ˆæœ¬ï¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªé»˜è®¤ä¼šè¯
    /*async function initSessions() {
      let stored = await dbReadAll(SESSION_STORE, "updatedAt");
      if (!stored || stored.length === 0) {
        const session = createSessionObject();
        sessions = [session];
        currentSessionId = session.id;
        await dbPut(SESSION_STORE, session);
      } else {
        sessions = stored;
        currentSessionId = sessions[0].id;
      }
      renderSessionList();
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }
    */

    // æ–°ç‰ˆæœ¬ï¼šé¦–æ¬¡è¿›å…¥æ—¶ä¸è‡ªåŠ¨åˆ›å»ºä¼šè¯ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»â€œæ–°å»ºä¼šè¯â€
    async function initSessions() {
      // ä» IndexedDB åŠ è½½å·²æœ‰ä¼šè¯ï¼ŒæŒ‰ updatedAt å€’åº
      let stored = await dbReadAll(SESSION_STORE, "updatedAt");
      if (!stored || stored.length === 0) {
        // ä¸å†è‡ªåŠ¨åˆ›å»ºâ€œæ–°ä¼šè¯â€
        sessions = [];
        currentSessionId = null;
      } else {
        sessions = stored; // å·²æŒ‰ updatedAt desc æ’å¥½
        currentSessionId = sessions[0].id;
      }

      renderSessionList();
       applySessionMetaToUi();
      
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }

    // è§†å›¾è¿‡æ»¤åçš„ä¼šè¯åˆ—è¡¨ï¼ˆåˆ† pinned / normalï¼‰
    function getVisibleSessions() {
      let list = [...sessions];

      if (viewState.agentFilter !== "all") {
        list = list.filter((s) => s.agentKey === viewState.agentFilter);
      }
      if (viewState.searchKeyword) {
        const q = viewState.searchKeyword.toLowerCase();
        list = list.filter((s) => {
          const title = (s.title || "").toLowerCase();
          const last = (s.lastUserText || "").toLowerCase();
          return title.includes(q) || last.includes(q);
        });
      }
      if (viewState.showPinnedOnly) {
        list = list.filter((s) => s.pinned);
      }
// âœ… ä¸åœ¨å·¦ä¾§åˆ—è¡¨æ¸²æŸ“ç©ºç™½ä¼šè¯ï¼ˆisEmpty=trueï¼‰
  // æ—§æ•°æ®é‡Œå¯èƒ½æ²¡æœ‰ isEmptyï¼Œundefined ä¹Ÿä¼šè¢«å½“æˆã€Œéç©ºã€æ­£å¸¸å±•ç¤º
  list = list.filter((s) => !s.isEmpty);
      
      const pinned = list.filter((s) => s.pinned);
      const normal = list.filter((s) => !s.pinned);

      pinned.sort((a, b) => b.updatedAt - a.updatedAt);
      normal.sort((a, b) => b.updatedAt - a.updatedAt);

      return { pinned, normal };
    }

    function renderSessionList() {
      if (!el.sessionList) return;
      el.sessionList.innerHTML = "";

      const { pinned, normal } = getVisibleSessions();

      if (pinned.length === 0 && normal.length === 0) {
        const empty = document.createElement("div");
        empty.className = "session-empty-hint";
        empty.textContent = "æš‚æ— ä¼šè¯ã€‚";
        el.sessionList.appendChild(empty);
        return;
      }

      if (pinned.length > 0) {
        const header = document.createElement("div");
        header.className = "session-section-title";
        header.textContent = "å·²å›ºå®š";
        el.sessionList.appendChild(header);

        pinned.forEach((session) => {
          el.sessionList.appendChild(renderSessionItem(session));
        });
      }

      if (normal.length > 0) {
        if (pinned.length > 0) {
          const header = document.createElement("div");
          header.className = "session-section-title";
          header.textContent = "æœ€è¿‘";
          el.sessionList.appendChild(header);
        }
        normal.forEach((session) => {
          el.sessionList.appendChild(renderSessionItem(session));
        });
      }
    }

    function renderSessionItem(session) {
      const item = document.createElement("div");
      item.className =
        "session-item" + (session.id === currentSessionId ? " active" : "");
      item.setAttribute("data-session-id", session.id);

      const headerRow = document.createElement("div");
      headerRow.className = "session-header-row";

      const titleSpan = document.createElement("div");
      titleSpan.className = "session-title";
      titleSpan.textContent = session.title || "æœªå‘½åä¼šè¯";
// âœ… æ”¯æŒç‚¹å‡»æ ‡é¢˜è¿›è¡Œé‡å‘½å
titleSpan.setAttribute("data-action", "rename-session");
      
      const actions = document.createElement("div");
      actions.className = "session-actions";

      const pinBtn = document.createElement("button");
      pinBtn.className =
        "btn-pin-session" + (session.pinned ? " pinned" : "");
      pinBtn.setAttribute("type", "button");
      pinBtn.setAttribute("data-action", "pin-session");
      pinBtn.textContent = session.pinned ? "ğŸ“Œ" : "ğŸ“";

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "btn-delete-session";
      deleteBtn.setAttribute("type", "button");
      deleteBtn.setAttribute("data-action", "delete-session");
      deleteBtn.textContent = "Ã—";

      actions.appendChild(pinBtn);
      actions.appendChild(deleteBtn);

      headerRow.appendChild(titleSpan);
      headerRow.appendChild(actions);

      const metaRow = document.createElement("div");
      metaRow.className = "session-meta";

      const timeSpan = document.createElement("span");
      timeSpan.textContent = formatShortTime(session.updatedAt);

      const tokenSpan = document.createElement("span");
      tokenSpan.className = "session-tokens";
      tokenSpan.textContent = `${session.totalTokens || 0} tokens`;

      metaRow.appendChild(timeSpan);
      metaRow.appendChild(tokenSpan);

      item.appendChild(headerRow);
      item.appendChild(metaRow);
      return item;
    }

    function formatShortTime(timestamp) {
      if (!timestamp) return "-";
      const d = new Date(timestamp);
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }

    async function selectSession(sessionId) {
      if (sessionId === currentSessionId) return;
      currentSessionId = sessionId;
      renderSessionList();
       applySessionMetaToUi();        // âœ… åˆ‡æ¢ä¼šè¯æ—¶åŒæ­¥å³ä¾§ tokens + JSON
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }

    function clearEmptyHint() {
      if (!el.chatEmpty) return;
      el.chatEmpty.style.display = "none";
      if (el.chatEmpty.parentNode) {
        el.chatEmpty.parentNode.removeChild(el.chatEmpty);
      }
    }

   
    // æ—§ç‰ˆæœ¬ï¼šå¦‚æœæ²¡æœ‰ä¼šè¯åˆ™ä¸æ˜¾ç¤ºç©ºç™½æç¤º
   /* async function renderCurrentSessionMessages() {
      if (!currentSessionId || !el.chatMessages) return;

      const messages = await dbReadMessagesBySession(currentSessionId);
      clearEmptyHint();
      el.chatMessages.innerHTML = "";

      if (!messages || messages.length === 0) {
        if (el.chatEmpty) {
          el.chatEmpty.style.display = "flex";
          el.chatMessages.appendChild(el.chatEmpty);
        }
        return;
      }

      messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false);
        });
      scrollToBottom();
    }
    */

    // æ–°ç‰ˆæœ¬ï¼šæ”¯æŒâ€œæ— å½“å‰ä¼šè¯â€æ—¶çš„ä¸­å¤®ç©ºç™½æç¤º
    async function renderCurrentSessionMessages() {
      if (!el.chatMessages) return;

      // æ²¡æœ‰é€‰ä¸­ä»»ä½•ä¼šè¯ï¼šæ˜¾ç¤ºä¸­é—´çš„ç©ºç™½æç¤º
      if (!currentSessionId) {
        el.chatMessages.innerHTML = "";
        if (el.chatEmpty) {
          el.chatEmpty.style.display = "flex";
          el.chatMessages.appendChild(el.chatEmpty);
        }
        return;
      }

      const messages = await dbReadMessagesBySession(currentSessionId);
      el.chatMessages.innerHTML = "";

      if (!messages || messages.length === 0) {
        if (el.chatEmpty) {
          el.chatEmpty.style.display = "flex";
          el.chatMessages.appendChild(el.chatEmpty);
        }
        return;
      }

      clearEmptyHint();

      messages
        .sort((a, b) => a.createdAt - b.createdAt)
        .forEach((msg) => {
          appendMessageBubble(msg.role, msg.content, false);
        });
      scrollToBottom();
    }

    async function handleNewSession() {
      // å¦‚æœå·²ç»å­˜åœ¨ä¸€ä¸ªç©ºç™½ä¼šè¯ï¼Œç›´æ¥åˆ‡è¿‡å»ï¼Œé¿å…å¤šä¸ªç©ºç™½çª—å£
      const existingEmpty = sessions.find((s) => s.isEmpty);
      if (existingEmpty) {
        currentSessionId = existingEmpty.id;
        renderSessionList();
        await renderCurrentSessionMessages();
        return;
      }

      const session = createSessionObject();
      sessions.unshift(session);
      currentSessionId = session.id;

      await dbPut(SESSION_STORE, session);
      await cleanupOldSessionsIfNecessary();

      renderSessionList();
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }

   
    // æ—§ç‰ˆæœ¬ï¼šåˆ å…‰æ‰€æœ‰ä¼šè¯æ—¶ä¼šè‡ªåŠ¨æ–°å»ºä¸€ä¸ª
    /*async function handleDeleteSession(sessionId) {
      if (!sessionId) return;

      await dbDeleteWhereMessages(sessionId);
      await dbDelete(SESSION_STORE, sessionId);

      sessions = sessions.filter((s) => s.id !== sessionId);

      if (sessions.length === 0) {
        const newSession = createSessionObject();
        sessions = [newSession];
        currentSessionId = newSession.id;
        await dbPut(SESSION_STORE, newSession);
      } else if (currentSessionId === sessionId) {
        currentSessionId = sessions[0].id;
      }

      renderSessionList();
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }
    */

    // æ–°ç‰ˆæœ¬ï¼šåˆ å…‰æ‰€æœ‰ä¼šè¯æ—¶ä¿æŒâ€œæ— ä¼šè¯â€çŠ¶æ€ï¼Œä¸­å¿ƒæ˜¾ç¤ºç©ºç™½æç¤º
    async function handleDeleteSession(sessionId) {
      if (!sessionId) return;

      // åˆ é™¤è¯¥ä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯
      await dbDeleteWhereMessages(sessionId);
      await dbDelete(SESSION_STORE, sessionId);

      // å†…å­˜ä¸­ç§»é™¤
      sessions = sessions.filter((s) => s.id !== sessionId);

      if (sessions.length === 0) {
        // åˆ åˆ° 0 ä¸ªä¼šè¯æ—¶ï¼Œä¸å†è‡ªåŠ¨æ–°å»ºç©ºä¼šè¯
        currentSessionId = null;
      } else if (currentSessionId === sessionId) {
        // å½“å‰ä¼šè¯è¢«åˆ ï¼Œåˆ‡åˆ°æœ€æ–°çš„ä¸€ä¸ª
        currentSessionId = sessions[0].id;
      }

      renderSessionList();
      await renderCurrentSessionMessages();
      resetTraceTimeline();
    }
//æ–°å¢renameå‡½æ•°
    async function handleRenameSession(sessionId) {
  if (!sessionId) return;
  const session = sessions.find((s) => s.id === sessionId);
  if (!session) return;

  const nextTitle = window.prompt("é‡å‘½åä¼šè¯", session.title || "æœªå‘½åä¼šè¯");
  if (nextTitle == null) return; // ç”¨æˆ·å–æ¶ˆ
  const trimmed = nextTitle.trim();
  if (!trimmed) return;

  session.title = trimmed;
  session.updatedAt = Date.now();
  await dbPut(SESSION_STORE, session);

  renderSessionList();
}

    async function handlePinSession(sessionId) {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) return;

      session.pinned = !session.pinned;
      // pinned â†’ é™æ€æ¡¶ï¼›å–æ¶ˆ pin â†’ åŠ¨æ€æ¡¶
      session.bucket = session.pinned ? BUCKET_STATIC : BUCKET_DYNAMIC;
      await dbPut(SESSION_STORE, session);

      renderSessionList();
    }

    async function cleanupOldSessionsIfNecessary() {
      // åªæ¸…ç†åŠ¨æ€æ¡¶ä¸­æœª pin çš„ä¼šè¯
      const dynamic = sessions.filter(
        (s) => s.bucket === BUCKET_DYNAMIC && !s.pinned
      );
      if (dynamic.length <= MAX_DYNAMIC_SESSIONS) return;

      const sorted = [...dynamic].sort((a, b) => b.updatedAt - a.updatedAt);
      const keepDynamic = sorted.slice(0, MAX_DYNAMIC_SESSIONS);
      const removeDynamic = sorted.slice(MAX_DYNAMIC_SESSIONS);

      const keepIds = new Set(keepDynamic.map((s) => s.id));
      const toRemove = removeDynamic.map((s) => s.id);

      for (const sid of toRemove) {
        await dbDeleteWhereMessages(sid);
        await dbDelete(SESSION_STORE, sid);
      }

      sessions = sessions.filter(
        (s) => !toRemove.includes(s.id) // åˆ é™¤çš„
      );
    }

    // ==========================
    // å‘é€ & Worker äº¤äº’
    // ==========================
    async function triggerSend() {
      if (isSending) return;
      if (!el.chatInput) return;

      const raw = el.chatInput.value.trim();
      if (!raw) {
        showToast("è¯·è¾“å…¥å†…å®¹åå†å‘é€ã€‚");
        return;
      }
      if (!currentSessionId) {
        showToast("å½“å‰æ²¡æœ‰ä¼šè¯ï¼Œè¯·å…ˆç‚¹å‡»å·¦ä¾§ã€Œæ–°å»ºä¼šè¯ã€ã€‚");
        return;
      }

      isSending = true;
      setSendingState(true);

      const userMsg = createMessage(currentSessionId, "user", raw);
      await dbPut(MESSAGE_STORE, userMsg);

      // æ›´æ–°ä¼šè¯å…ƒä¿¡æ¯
      const session = sessions.find((s) => s.id === currentSessionId);
      if (session) {
        session.lastUserText = raw;
        session.updatedAt = Date.now();

        if (session.isEmpty) {
          session.isEmpty = false;
          session.title = deriveTitleFromText(raw);
        }
        await dbPut(SESSION_STORE, session);
      }

      appendMessageBubble("user", raw, true);
      el.chatInput.value = "";

      const agentCfg = getCurrentAgentConfig();
      const endpoint = agentCfg.endpoint;
      const payload = {
        agent: agentCfg.key,
        model: currentModelName,
        input: raw,
      };

      const start = performance.now();
      let ok = false;
      let modelName = currentModelName || "gpt-5-mini";
      let usage = null;
      let outputText = "";
      lastCallDurationMs = 0;

      try {
        const res = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload),
        });

        const durationMs = performance.now() - start;
        lastCallDurationMs = durationMs;

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          lastRawResponse = text || "";
          updateCallOverviewError(res.status, durationMs, null);
          updateRawJson(text || "");
          updateTraceTimelineFromResponse(null, durationMs, {
            ok: false,
            status: res.status,
          });
          showToast("Worker è°ƒç”¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ Worker æ—¥å¿—ã€‚");
        } else {
          const data = await res.json();
          ok = true;
          outputText = data.output || "";
          modelName = data.model || modelName;
          usage = data.usage || null;
          lastRawResponse = JSON.stringify(data, null, 2);

          updateCallOverviewSuccess(durationMs, modelName, usage);
          updateRawJson(lastRawResponse);
          updateTraceTimelineFromResponse(data, durationMs, { ok: true });
        }
      } catch (err) {
        console.error(err);
        const durationMs = performance.now() - start;
        lastCallDurationMs = durationMs;

        updateCallOverviewError("ç½‘ç»œé”™è¯¯", durationMs, null);
        lastRawResponse = String(err || "Unknown error");
        updateRawJson(lastRawResponse);
        updateTraceTimelineFromResponse(null, durationMs, {
          ok: false,
          status: "network-error",
        });
        showToast("ç½‘ç»œå¼‚å¸¸ï¼Œæ— æ³•è®¿é—® Workerã€‚");
      } finally {
        isSending = false;
        setSendingState(false);
      }

      if (ok) {
        const assistantMsg = createMessage(
          currentSessionId,
          "assistant",
          outputText || "ï¼ˆWorker æœªè¿”å›å†…å®¹ï¼‰"
        );
        await dbPut(MESSAGE_STORE, assistantMsg);

        const session = sessions.find((s) => s.id === currentSessionId);
        if (session) {
          const usedTokens =
            (usage && (usage.total_tokens || usage.totalTokens)) || 0;
          session.totalTokens = (session.totalTokens || 0) + usedTokens;
          session.updatedAt = Date.now();

            // âœ… è®°å½•æœ¬æ¬¡è°ƒç”¨æ¦‚è§ˆå’ŒåŸå§‹ JSONï¼Œåˆ·æ–°åä¹Ÿèƒ½æ¢å¤
    session.lastOverview = {
      durationMs: lastCallDurationMs,
      status: "success",
      model: modelName,
      usage: usage || null,
    };
    session.lastRawJson = lastRawResponse || "";
          
          await dbPut(SESSION_STORE, session);
        }

        appendMessageBubble("assistant", assistantMsg.content, true);
        scrollToBottom();
        renderSessionList();
      }
    }

    function setSendingState(sending) {
      if (el.btnSend) el.btnSend.disabled = sending;
      if (el.btnSendLabel)
        el.btnSendLabel.textContent = sending ? "è°ƒç”¨ä¸­â€¦" : "å‘é€";
      if (el.requestMetaHint)
        el.requestMetaHint.textContent = sending
          ? "æ­£åœ¨è°ƒç”¨ Cloudflare Worker æ™ºèƒ½ä½“â€¦"
          : "å°±ç»ªï¼šè°ƒç”¨ Cloudflare Worker æ™ºèƒ½ä½“ã€‚";
    }

    // ==========================
    // ä¼šè¯æ ‡é¢˜ï¼šæŒ‰æ„å›¾è‡ªåŠ¨å‘½å
    // ==========================
    function deriveTitleFromText(text) {
      const trimmed = text.replace(/\s+/g, " ").trim();
      if (!trimmed) return "æ–°ä¼šè¯";

      const lower = trimmed.toLowerCase();

      // ç²—ç²’åº¦â€œæ„å›¾è¯†åˆ«â€ï¼Œä¸ç”¨é¢å¤–è¯·æ±‚æ¨¡å‹
      const rules = [
        { test: /(bug|é”™è¯¯|å¼‚å¸¸|æŠ¥é”™|trace|stack)/i, prefix: "é”™è¯¯æ’æŸ¥" },
        { test: /(éƒ¨ç½²|å‘å¸ƒ|docker|k8s|ä¸Šçº¿|ç¯å¢ƒ)/i, prefix: "éƒ¨ç½²è¿ç»´" },
        { test: /(sql|æ•°æ®åº“|æŸ¥è¯¢|ç´¢å¼•|è¡¨ç»“æ„)/i, prefix: "æ•°æ®åº“é—®é¢˜" },
        { test: /(æ¥å£|api|http|è¯·æ±‚å¤´|è¿”å›å€¼)/i, prefix: "æ¥å£è°ƒè¯•" },
        { test: /(å‰ç«¯|react|vue|æ ·å¼|css|dom)/i, prefix: "å‰ç«¯é—®é¢˜" },
        { test: /(åç«¯|node|java|spring|go|gin)/i, prefix: "åç«¯é—®é¢˜" },
        { test: /(æ–‡æ¡ˆ|æ”¹å†™|æ¶¦è‰²|ç¿»è¯‘|æ€»ç»“)/i, prefix: "å†…å®¹å¤„ç†" },
        { test: /(prompt|æç¤ºè¯|æ™ºèƒ½ä½“|agent)/i, prefix: "æ™ºèƒ½ä½“è®¾è®¡" },
      ];

      for (const rule of rules) {
        if (rule.test.test(trimmed) || rule.test.test(lower)) {
          const tail =
            trimmed.length > 18 ? trimmed.slice(0, 18).trim() + "â€¦" : trimmed;
          return `${rule.prefix} Â· ${tail}`;
        }
      }

      // é»˜è®¤ï¼šæˆªå–å¼€å¤´ä¸€æ®µ
      return trimmed.length > 22 ? trimmed.slice(0, 22) + "â€¦" : trimmed;
    }

    // ==========================
    // æ¶ˆæ¯æ¸²æŸ“
    // ==========================
    function appendMessageBubble(role, content, hideEmptyHint) {
      if (!el.chatMessages) return;

      if (hideEmptyHint) {
        clearEmptyHint();
      } else {
        // ä¿é™©ï¼šåªè¦æœ‰æ¶ˆæ¯æ¸²æŸ“ï¼Œç¡®ä¿ä¼ªæç¤ºä¸å†å‡ºç°
        clearEmptyHint();
      }

      const bubble = document.createElement("div");
      bubble.className = "chat-message " + role;
      bubble.textContent = content;
      el.chatMessages.appendChild(bubble);
    }

    function scrollToBottom() {
      if (!el.chatMessages) return;
      requestAnimationFrame(() => {
        el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
      });
    }

    // ==========================
    // è°ƒç”¨æ¦‚è§ˆ & JSON
    // ==========================
    function updateCallOverviewSuccess(durationMs, modelName, usage) {
      if (el.ovDuration)
        el.ovDuration.textContent = `${durationMs.toFixed(0)} ms`;

      if (el.ovStatus) {
        const pill = document.createElement("span");
        pill.className = "call-status-pill";
        pill.innerHTML = `<span class="call-status-dot"></span> æˆåŠŸ`;
        el.ovStatus.innerHTML = "";
        el.ovStatus.appendChild(pill);
      }

      if (el.ovModel) el.ovModel.textContent = modelName || "gpt-5-mini";

      const pt =
        (usage && (usage.prompt_tokens || usage.promptTokens)) || "-";
      const ct =
        (usage && (usage.completion_tokens || usage.completionTokens)) || "-";
      const tt =
        (usage && (usage.total_tokens || usage.totalTokens)) || "-";

      if (el.ovPromptTokens) el.ovPromptTokens.textContent = pt;
      if (el.ovCompletionTokens) el.ovCompletionTokens.textContent = ct;
      if (el.ovTotalTokens) el.ovTotalTokens.textContent = tt;
    }

    function updateCallOverviewError(status, durationMs, usage) {
      if (el.ovDuration) {
        el.ovDuration.textContent =
          typeof durationMs === "number" ? `${durationMs.toFixed(0)} ms` : "-";
      }

      if (el.ovStatus) {
        const pill = document.createElement("span");
        pill.className = "call-status-pill error";
        pill.innerHTML = `<span class="call-status-dot"></span> å¤±è´¥ï¼ˆ${status}ï¼‰`;
        el.ovStatus.innerHTML = "";
        el.ovStatus.appendChild(pill);
      }

      if (!usage) {
        if (el.ovPromptTokens) el.ovPromptTokens.textContent = "-";
        if (el.ovCompletionTokens) el.ovCompletionTokens.textContent = "-";
        if (el.ovTotalTokens) el.ovTotalTokens.textContent = "-";
      }
    }

    function updateRawJson(text) {
      if (!el.rawJsonPlaceholder || !el.rawJsonPre) return;

      if (!text) {
        el.rawJsonPlaceholder.style.display = "block";
        el.rawJsonPre.style.display = "none";
        el.rawJsonPre.textContent = "";
        return;
      }

      el.rawJsonPlaceholder.style.display = "none";
      el.rawJsonPre.style.display = "block";

      try {
        const parsed = typeof text === "string" ? JSON.parse(text) : text;
        el.rawJsonPre.textContent = JSON.stringify(parsed, null, 2);
      } catch {
        el.rawJsonPre.textContent = text;
      }
    }
function applySessionMetaToUi() {
  const session = sessions.find((s) => s.id === currentSessionId);
  if (!session) {
    // âœ… æ²¡æœ‰å½“å‰ä¼šè¯æ—¶æ¸…ç©ºå³ä¾§æ¦‚è§ˆ & JSON
    if (el.ovDuration) el.ovDuration.textContent = "-";
    if (el.ovStatus) el.ovStatus.innerHTML = "";
    if (el.ovModel) el.ovModel.textContent = "";
    if (el.ovPromptTokens) el.ovPromptTokens.textContent = "-";
    if (el.ovCompletionTokens) el.ovCompletionTokens.textContent = "-";
    if (el.ovTotalTokens) el.ovTotalTokens.textContent = "-";
    lastRawResponse = "";
    updateRawJson("");
    return;
  }

  const overview = session.lastOverview;
  if (overview) {
    const { durationMs, status, model, usage } = overview;
    if (!status || status === "success") {
      updateCallOverviewSuccess(
        typeof durationMs === "number" ? durationMs : 0,
        model,
        usage || null
      );
    } else {
      updateCallOverviewError(
        status,
        typeof durationMs === "number" ? durationMs : "-",
        usage || null
      );
    }
  } else {
    // âœ… æ²¡æœ‰è®°å½•ï¼šæ¸…ç©ºæ¦‚è§ˆ
    if (el.ovDuration) el.ovDuration.textContent = "-";
    if (el.ovStatus) el.ovStatus.innerHTML = "";
    if (el.ovModel) el.ovModel.textContent = "";
    if (el.ovPromptTokens) el.ovPromptTokens.textContent = "-";
    if (el.ovCompletionTokens) el.ovCompletionTokens.textContent = "-";
    if (el.ovTotalTokens) el.ovTotalTokens.textContent = "-";
  }

  if (session.lastRawJson) {
    lastRawResponse = session.lastRawJson;
    updateRawJson(session.lastRawJson);
  } else {
    lastRawResponse = "";
    updateRawJson("");
  }
}

    // ==========================
    // è¿è¡Œè½¨è¿¹ / æ—¶é—´çº¿
    // ==========================
    function resetTraceTimeline() {
      if (!el.traceTimeline) return;
      el.traceTimeline.innerHTML = "";
      if (el.traceEmpty) el.traceEmpty.style.display = "block";
    }

    function updateTraceTimelineFromResponse(data, durationMs, meta) {
      if (!el.traceTimeline) return;

      el.traceTimeline.innerHTML = "";
      if (el.traceEmpty) el.traceEmpty.style.display = "none";

      const list = document.createElement("ul");
      list.className = "trace-list";

      const cfg = getCurrentAgentConfig();
      const model = (data && data.model) || currentModelName || "gpt-5-mini";

      // å¦‚æœ Worker å°†æ¥è¿”å› data.traceï¼ˆæ•°ç»„ï¼‰ï¼ŒæŒ‰æ­¥éª¤æ¸²æŸ“
      if (data && Array.isArray(data.trace) && data.trace.length > 0) {
        data.trace.forEach((step, idx) => {
          const li = document.createElement("li");
          li.className = "trace-item";

          const name = step.name || `Step ${idx + 1}`;
          const t =
            typeof step.latencyMs === "number"
              ? `${step.latencyMs.toFixed(0)} ms`
              : "-";

          li.innerHTML = `
            <div class="trace-item-main">
              <div class="trace-item-title">${name}</div>
              <div class="trace-item-sub">
                ${step.type || ""} Â· ${t}
              </div>
            </div>
          `;
          list.appendChild(li);
        });
      } else {
        // å…œåº•ï¼šè‡³å°‘å±•ç¤ºä¸€ä¸ª LLM è°ƒç”¨èŠ‚ç‚¹
        const li = document.createElement("li");
        li.className = "trace-item";

        const d = typeof durationMs === "number" ? `${durationMs.toFixed(0)} ms` : "-";
        const statusText = meta && meta.ok === false ? "å¤±è´¥" : "æˆåŠŸ";

        li.innerHTML = `
          <div class="trace-item-main">
            <div class="trace-item-title">LLM è°ƒç”¨ Â· ${cfg.label}</div>
            <div class="trace-item-sub">
              æ¨¡å‹ï¼š${model} Â· ç”¨æ—¶ï¼š${d} Â· çŠ¶æ€ï¼š${statusText}
            </div>
          </div>
        `;
        list.appendChild(li);
      }

      el.traceTimeline.appendChild(list);
    }

    // ==========================
    // Toast & Error
    // ==========================
    let toastTimer = null;

    function showToast(message) {
      if (!el.toast || !el.toastText) {
        console.log("[Toast]", message);
        return;
      }
      el.toastText.textContent = message;
      el.toast.classList.add("visible");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.toast.classList.remove("visible");
      }, 2800);
    }

    function showFatalError(err) {
      console.error(err);
      showToast("åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°ã€‚");
    }
  })();
</script>


</body>
</html>






