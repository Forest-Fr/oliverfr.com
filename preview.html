<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Section0 Carousel</title>
  <style>
    :root{
      --gap: 15px;
      --peek-desktop: clamp(52px, 9vw, 96px);
      --peek-mobile: 7vw;
    }

    /* =========================
       Carousel layout (Peek Preview)
       ========================= */

    /* Desktop */
    @media (min-width: 769px) {
      .section0-carousel{
        position: relative;
        width: 100%;
        height: 520px;
        overflow: hidden;
        margin: 10px auto 0 auto;      /* 下方间距由按钮条统一控制 */
        padding: 0;
        box-sizing: border-box;
        touch-action: pan-y;           /* 保留上下滚动 */
      }
      .section0-track{
        display: flex;
        width: 100%;
        gap: var(--gap);
        column-gap: var(--gap);
        row-gap: 0;
        justify-content: flex-start;
        will-change: transform;
      }
      .section0-slide{
        flex: 0 0 auto;
        width: calc(100% - (var(--peek-desktop) * 2));
        max-width: calc(100% - (var(--peek-desktop) * 2));
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 1 !important;
        transition: opacity .3s ease-in-out;
        position: relative;
        border-radius: 10px;
        overflow: hidden;
      }
      .section0-slide img{
        width: 100%;
        height: auto;
        display: block;
        border-radius: 10px;
        filter: none !important;
        opacity: 1 !important;
      }
    }

    /* Mobile */
    @media (max-width: 768px) {
      .section0-carousel{
        width: 100vw;
        padding-left: calc((100vw - 85vw) / 2);
        padding-right: calc((100vw - 85vw) / 2);
        overflow: hidden;
        margin: 5px auto 0 auto;
        position: relative;
        box-sizing: border-box;
        touch-action: pan-y;
      }
      .section0-track{
        display: flex;
        width: 100%;
        gap: var(--gap);
        column-gap: var(--gap);
        align-items: center;
        will-change: transform;
      }
      .section0-slide{
        flex: 0 0 auto;
        width: 85vw;
        aspect-ratio: 9 / 16;
        overflow: hidden;
        position: relative;
        border-radius: 10px;
      }
      .section0-slide img{
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        filter: none !important;
        opacity: 1 !important;
      }
    }

    /* =========================
       ✅ 固定在轮播下方 15px 的圆点胶囊条
       ========================= */
    .section0-buttonRow{
      width: min(920px, 92vw);
      height: 44px;
      margin: 15px auto 16px auto;     /* ✅ 与轮播区域下方总间隔 15px */
      position: relative;              /* 固定在轮播下方（非 sticky） */
      z-index: 999;
      background: rgba(240,240,240,.96);
      border-radius: 999px;
      box-sizing: border-box;
      /* ✅ 阴影调浅 */
      box-shadow: 0 10px 26px rgba(0,0,0,.05);
    }

    .btn-container{
      position: absolute;
      top: 50%;
      opacity: 1;
      pointer-events: auto;
      transform: translateY(-50%);
    }
    #leftBtnContainer{
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #rightBtnContainer{
      right: 10px;
      left: auto;
    }

    #section0-leftCapsule{
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .dots{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 14px;
      user-select: none;
    }

    /* Dot style (capsule active, small dots inactive) */
    .dot{
      --dotS: 6px;
      --pillW: 36px;
      --pillH: 8px;

      width: var(--dotS);
      height: var(--dotS);
      border-radius: 999px;
      background: rgba(0,0,0,.30);
      opacity: .85;
      cursor: pointer;
      transition: width .26s ease, height .26s ease, background-color .26s ease, opacity .26s ease, transform .26s ease;
      transform: translateZ(0);
    }
    .dot.is-active{
      width: var(--pillW);
      height: var(--pillH);
      background: rgba(0,0,0,.78);
      opacity: 1;
    }
    .dot.is-active.is-pre{
      width: var(--dotS);
      height: var(--dotS);
      background: rgba(0,0,0,.45);
      opacity: .92;
    }

    /* Play/Pause */
    #section0-rightButton{
      width: 34px;
      height: 34px;
      border: none;
      border-radius: 50%;
      background: rgba(0,0,0,.10);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      /* ✅ 阴影调浅 */
      box-shadow: 0 6px 16px rgba(0,0,0,.08);
      transition: transform .18s ease, background-color .18s ease, opacity .18s ease, box-shadow .18s ease;
    }
    #section0-rightButton:active{ transform: scale(.96); }
    #section0-rightButton.is-paused{
      background: rgba(0,0,0,.14);
      box-shadow: 0 6px 18px rgba(0,0,0,.09);
    }
    #section0-playIcon{
      font-size: 14px;
      line-height: 1;
      color: rgba(0,0,0,.72);
      letter-spacing: -1px;
      user-select: none;
      transform: translateX(1px);
    }

    /* =========================
       ✅ 只保留 hero-content（一个框），中心显示
       ========================= */
    .section0-slide .hero-content{
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(92%, 760px);
      text-align: center;

      /* 一个“框” */
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      padding: 18px 16px;

      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease;
    }

    .section0-slide.is-center .hero-content{
      opacity: 1;
      pointer-events: auto;
    }

    .section0-slide .hero-content h1{
      margin: 0 0 10px 0;
      color: #fff;
      font-weight: 900;
      letter-spacing: .2px;
      line-height: 1.12;
      font-size: clamp(20px, 3.8vw, 46px);
      /* ✅ 文本阴影调浅 */
      text-shadow: 0 10px 24px rgba(0,0,0,.18);
    }
    .section0-slide .hero-content p{
      margin: 0 0 14px 0;
      color: rgba(255,255,255,.92);
      line-height: 1.5;
      font-size: clamp(12px, 1.5vw, 18px);
      /* ✅ 文本阴影调浅 */
      text-shadow: 0 10px 24px rgba(0,0,0,.16);
    }
    .section0-slide .hero-content .btn{
      display: inline-block;
      background: #1677ff;
      color: #fff;
      font-weight: 800;
      padding: 10px 18px;
      border-radius: 8px;
      text-decoration: none;
      /* ✅ 按钮阴影调浅 */
      box-shadow: 0 12px 28px rgba(0,0,0,.16);
      transition: transform .18s ease, filter .18s ease;
      user-select: none;
    }
    .section0-slide .hero-content .btn:active{ transform: scale(.98); }

    .section0-slide.is-center{ cursor: pointer; }
    .section0-slide.is-neighbor{ cursor: pointer; }
  </style>
</head>

<body>

  <!-- 轮播容器 -->
  <div class="section0-carousel">
    <div class="section0-track">
      <div class="section0-slide"><img src="slide1.jpg" alt="nature1" /></div>
      <div class="section0-slide"><img src="slide2.jpg" alt="nature2" /></div>
      <div class="section0-slide"><img src="slide3.jpg" alt="nature3" /></div>
    </div>
  </div>

  <!-- 固定在轮播下方 15px 的圆点 + 播放暂停 -->
  <div id="section0-buttonRow" class="section0-buttonRow">
    <div id="leftBtnContainer" class="btn-container">
      <div id="section0-leftCapsule">
        <div class="dots" id="section0-dotsWrap">
          <div class="dot" data-index="0"></div>
          <div class="dot" data-index="1"></div>
          <div class="dot" data-index="2"></div>
        </div>
      </div>
    </div>

    <div id="rightBtnContainer" class="btn-container">
      <div id="section0-rightButton" aria-label="Play/Pause">
        <span id="section0-playIcon">❚❚</span>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const container = document.querySelector('.section0-carousel');
      const track = document.querySelector('.section0-track');
      const rightButton = document.getElementById('section0-rightButton');
      const playIcon = document.getElementById('section0-playIcon');
      const dotsWrap = document.getElementById('section0-dotsWrap');

      if (!container || !track) return;

      const LINK_URL = 'https://oliverfr.com/agent-test.html';

      // ===== Speed (slower, friendly) =====
      const TRANSITION_MS = 680;
      const INTERVAL_MS   = 4500;
      const SWIPE_PX_DESK = 50;
      const SWIPE_PX_MOB  = 35;

      // ===== Triple clones =====
      let originalSlides = Array.from(track.querySelectorAll('.section0-slide'));
      const realCount = originalSlides.length;

      function syncDotsCount() {
        if (!dotsWrap) return;
        const exist = Array.from(dotsWrap.querySelectorAll('.dot'));
        if (exist.length === realCount) return;
        dotsWrap.innerHTML = '';
        for (let i = 0; i < realCount; i++) {
          const d = document.createElement('div');
          d.className = 'dot';
          d.dataset.index = String(i);
          dotsWrap.appendChild(d);
        }
      }

      function ensureHeroContent(slide) {
        if (!slide) return;
        if (slide.querySelector('.hero-content')) return;

        const hero = document.createElement('div');
        hero.className = 'hero-content';
        hero.innerHTML = `
          <h1>MeFan AI 智能体 - 让运维与开发更「自动」</h1>
          <p>基于 Python · FastAPI · LangChain · LangGraph · Supa · Github · Cloudflare · google cloud搭建的全栈 AI Agent 平台。</p>
          <a href="agent-test.html" class="btn">Let's智能体</a>
        `;
        slide.appendChild(hero);

        const a = hero.querySelector('a.btn');
        if (a) {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.open(LINK_URL, '_blank', 'noopener');
          });
        }
      }

      function cloneTriple() {
        if (realCount <= 1) return;

        const base = originalSlides.map(n => n.cloneNode(true));
        track.innerHTML = '';

        for (let pass = 0; pass < 3; pass++) {
          for (let i = 0; i < base.length; i++) {
            const node = base[i].cloneNode(true);
            node.dataset.realIndex = String(i);
            node.dataset.pass = String(pass);
            track.appendChild(node);
          }
        }
      }

      syncDotsCount();
      cloneTriple();

      let slides = Array.from(track.querySelectorAll('.section0-slide'));
      slides.forEach(ensureHeroContent);

      // Start at middle copy
      let currentPos = (realCount > 1) ? realCount : 0;

      // ===== Measurements (precision to 3 decimals) =====
      let slideSpan = 0;
      let slideWidth = 0;
      let gapPx = 15;

      function getGapPx() {
        const cs = getComputedStyle(track);
        const raw = cs.columnGap || cs.gap || '15';
        const g = parseFloat(raw);
        return Number.isFinite(g) ? g : 15;
      }

      function getContainerWidth() {
        const rect = container.getBoundingClientRect();
        return rect && rect.width ? rect.width : (container.offsetWidth || 0);
      }

      function recalcSpan() {
        if (!slides.length) return;

        const safePos = Math.min(Math.max(currentPos, 0), slides.length - 1);
        const el = slides[safePos];
        const rect = el ? el.getBoundingClientRect() : null;
        const wMeasured = rect && rect.width ? rect.width : (el ? el.offsetWidth : 0);

        const cw = getContainerWidth();
        const fallback = cw ? (window.innerWidth <= 768 ? cw * 0.85 : cw * 0.82) : 0;

        slideWidth = (Number.isFinite(wMeasured) && wMeasured > 0) ? wMeasured : fallback;

        gapPx = getGapPx();
        slideSpan = slideWidth + gapPx;
      }

      function applyTransform(animated) {
        if (!slideSpan) recalcSpan();

        const contW = getContainerWidth();
        const offset = currentPos * slideSpan - ((contW - slideWidth) / 2);

        track.style.transition = animated
          ? `transform ${TRANSITION_MS}ms cubic-bezier(.22,.61,.36,1)`
          : 'none';

        track.style.transform = `translate3d(-${offset.toFixed(3)}px, 0, 0)`;
      }

      function getRealIndexByMod() {
        if (realCount <= 1) return 0;
        // 用 mod 保证即便 currentPos 越界也能得到正确 realIndex
        let r = currentPos % realCount;
        if (r < 0) r += realCount;
        return r;
      }

      function setActiveDot(idx, pop) {
        const dots = Array.from(document.querySelectorAll('.dot'));
        dots.forEach(d => d.classList.remove('is-active', 'is-pre'));

        const active = dots[idx];
        if (!active) return;

        active.classList.add('is-active');
        if (pop) {
          active.classList.add('is-pre');
          requestAnimationFrame(() => active.classList.remove('is-pre'));
        }
      }

      function updateCenterClasses() {
        slides.forEach(s => s.classList.remove('is-center', 'is-neighbor'));

        const center = slides[currentPos];
        const left = slides[currentPos - 1];
        const right = slides[currentPos + 1];

        if (center) center.classList.add('is-center');
        if (left) left.classList.add('is-neighbor');
        if (right) right.classList.add('is-neighbor');
      }

      // ===== Normalize (NO blank even if transitionend never fires) =====
      let normalizeTimer = null;

      function snapToMiddleNoAnim() {
        if (realCount <= 1) return;
        const ri = getRealIndexByMod();
        currentPos = realCount + ri;      // 永远回到中间副本
        recalcSpan();
        applyTransform(false);
        updateCenterClasses();
        setActiveDot(ri, false);
      }

      function scheduleNormalize() {
        clearTimeout(normalizeTimer);
        normalizeTimer = setTimeout(() => {
          // 兜底：无论 transitionend 触发与否，最终都能回到中间副本
          snapToMiddleNoAnim();
        }, TRANSITION_MS + 80);
      }

      // transitionend 仍然保留（正常情况下更顺滑）
      track.addEventListener('transitionend', (e) => {
        if (e.propertyName !== 'transform') return;
        snapToMiddleNoAnim();
      });

      // ===== Autoplay (play/pause) =====
      let isPlaying = true;
      let timer = null;

      // ✅ 用户手动暂停标记：防止“后台回来后自动乱续播”
      let userPaused = false;
      // ✅ 后台前是否在播放：用于后台回来后决定是否续播
      let wasPlayingBeforeHide = false;

      function updatePlayButtonUI() {
        if (!rightButton || !playIcon) return;
        if (isPlaying) {
          playIcon.textContent = '❚❚';
          rightButton.classList.remove('is-paused');
        } else {
          playIcon.textContent = '►';
          rightButton.classList.add('is-paused');
        }
      }

      function schedule() {
        clearTimeout(timer);
        if (!isPlaying || realCount <= 1) return;

        timer = setTimeout(() => {
          next(true);
          schedule();
        }, INTERVAL_MS);
      }

      function play(internal = false) {
        isPlaying = true;
        if (!internal) userPaused = false;
        updatePlayButtonUI();
        schedule();
      }

      function pause(internal = false) {
        isPlaying = false;
        clearTimeout(timer);
        timer = null;
        if (!internal) userPaused = true;
        updatePlayButtonUI();
      }

      // ===== Navigation =====
      function next(popDot) {
        if (realCount <= 1) return;

        // ✅ 每次移动前先把位置拉回中间副本，避免后台节流导致越界
        snapToMiddleNoAnim();

        currentPos += 1;                 // 右 -> 左
        applyTransform(true);
        setActiveDot(getRealIndexByMod(), !!popDot);
        updateCenterClasses();

        // ✅ 双保险兜底
        scheduleNormalize();
      }

      function prev(popDot) {
        if (realCount <= 1) return;

        snapToMiddleNoAnim();

        currentPos -= 1;
        applyTransform(true);
        setActiveDot(getRealIndexByMod(), !!popDot);
        updateCenterClasses();

        scheduleNormalize();
      }

      function goToRealIndex(realIdx) {
        if (realCount <= 1) return;
        currentPos = realCount + realIdx;
        recalcSpan();
        applyTransform(true);
        setActiveDot(realIdx, true);
        updateCenterClasses();
        scheduleNormalize();
      }

      // ===== Controls =====
      if (rightButton) {
        rightButton.addEventListener('click', () => {
          if (isPlaying) pause(false);   // manual pause
          else play(false);              // manual play
        });
      }

      // Dots click
      document.addEventListener('click', (e) => {
        const t = e.target;
        if (!t || !t.classList || !t.classList.contains('dot')) return;
        const idx = parseInt(t.getAttribute('data-index') || '0', 10);
        if (!Number.isFinite(idx)) return;

        const shouldResume = isPlaying;
        goToRealIndex(idx);
        if (shouldResume) schedule();
      });

      // Slide click behavior:
      // center: open new window
      // neighbors/others: only move
      track.addEventListener('click', (e) => {
        const slide = e.target && e.target.closest ? e.target.closest('.section0-slide') : null;
        if (!slide) return;

        const idx = slides.indexOf(slide);
        if (idx < 0) return;

        if (idx === currentPos) {
          window.open(LINK_URL, '_blank', 'noopener');
          return;
        }

        pause(true);                     // 内部暂停，不算用户手动暂停
        if (idx < currentPos) prev(true);
        else next(true);
      });

      // ===== Touch swipe (mobile sensitive; keep vertical scroll) =====
      let sx = 0, sy = 0, ex = 0, ey = 0;

      track.addEventListener('touchstart', (e) => {
        const t = e.touches && e.touches[0];
        if (!t) return;
        sx = t.clientX;
        sy = t.clientY;
      }, { passive: true });

      track.addEventListener('touchend', (e) => {
        const t = e.changedTouches && e.changedTouches[0];
        if (!t) return;
        ex = t.clientX;
        ey = t.clientY;

        const dx = ex - sx;
        const dy = ey - sy;

        // 横向明显大于纵向才触发，保证上下滚动灵敏
        if (Math.abs(dx) <= Math.abs(dy)) return;

        const thr = (window.innerWidth <= 768) ? SWIPE_PX_MOB : SWIPE_PX_DESK;
        if (Math.abs(dx) < thr) return;

        pause(true);                     // 内部暂停
        if (dx < 0) next(true);
        else prev(true);
      }, { passive: true });

      // ===== Heal: solve "back to tab => stopped/blank" =====
      function heal(reason) {
        // 容器宽度为 0 时（某些恢复瞬间），稍后再试
        const cw = container.getBoundingClientRect().width || container.offsetWidth || 0;
        if (!cw) {
          setTimeout(() => heal(reason + ':retry'), 120);
          return;
        }

        // 强制重算尺寸 + 回中间副本 + 修正 transform
        recalcSpan();
        snapToMiddleNoAnim();

        // 如果后台回来前在播放，且用户没有手动暂停，则续播
        if (wasPlayingBeforeHide && !userPaused) {
          play(true);
        } else {
          updatePlayButtonUI();
        }
      }

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          wasPlayingBeforeHide = isPlaying;
          if (isPlaying) pause(true);   // 后台内部暂停（不改 userPaused）
        } else {
          heal('visibility');
        }
      });

      // BFCache / 返回历史页面时常见：pageshow 会触发
      window.addEventListener('pageshow', () => heal('pageshow'));

      // 重新聚焦也做一次修复
      window.addEventListener('focus', () => heal('focus'));

      // Resize
      window.addEventListener('resize', () => {
        recalcSpan();
        snapToMiddleNoAnim();
      });

      // ===== Init =====
      function init() {
        recalcSpan();
        snapToMiddleNoAnim();
        updatePlayButtonUI();
        play(true);
      }

      window.addEventListener('load', init, { once: true });
    })();
  </script>
</body>
</html>
