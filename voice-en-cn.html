<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>åŒæ¨¡å¼è¯­éŸ³åŠ©æ‰‹</title>
  <style>
    /* â€¦ ä¿ç•™åŸæœ‰æ ·å¼ä¸å˜ â€¦ */
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:'Segoe UI',sans-serif;
      background:#f0f2f5; color:#333;
      min-height:100vh;
      display:flex; justify-content:center; align-items:center;
      padding:1rem;
    }
    #main { /* â€¦ */ }
    /* å…¶ä½™æ ·å¼åŒåŸç‰ˆ */
  </style>
</head>
<body>
  <div id="main">
    <h1>è¯­éŸ³åŠ©æ‰‹</h1>
    <div class="mode-switch">
      <label><input type="radio" name="mode" value="chat" checked/> å¯¹è¯æ¨¡å¼</label>
      <label><input type="radio" name="mode" value="trans"/> åŒä¼ æ¨¡å¼</label>
    </div>
    <button id="recBtn" disabled>ğŸ¤ æŒ‰ä½è¯´è¯</button>
    <div id="chat"></div>
  </div>

  <div id="authModal">
    <div class="box">
      <h2>è¯·è¾“å…¥æˆæƒç </h2>
      <input id="authInput" type="password" placeholder="æˆæƒç "/>
      <button id="authBtn" disabled>ç¡®è®¤</button>
      <div id="authErr"></div>
    </div>
  </div>

  <script>
  (function(){
    const BASE    = 'https://translate-assistant.mefans.workers.dev';
    const AUTH    = BASE + '/admin-api/validate-code';
    const WS_BASE = BASE.replace(/^http/,'ws') + '/admin-api/ws';

    const authModal = document.getElementById('authModal');
    const authInput = document.getElementById('authInput');
    const authBtn   = document.getElementById('authBtn');
    const authErr   = document.getElementById('authErr');
    const recBtn    = document.getElementById('recBtn');
    const chatEl    = document.getElementById('chat');
    const modes     = document.getElementsByName('mode');

    let socket, recorder;
    let sessionId, authCode;

    // åˆå§‹åŒ–ï¼šç¦ç”¨å½•éŸ³
    window.addEventListener('DOMContentLoaded', ()=> recBtn.disabled = true);

    // æˆæƒå¼¹çª—ç›‘å¬
    authInput.addEventListener('input', () => {
      authBtn.disabled = !authInput.value.trim();
      authErr.style.display = 'none';
    });
    authBtn.addEventListener('click', async () => {
      authBtn.disabled = true;
      try {
        const res = await fetch(AUTH, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ code: authInput.value.trim() })
        });
        const j = await res.json();
        if (res.ok && j.ok) {
          // ç”Ÿæˆæœ¬æ¬¡ä¼šè¯ ID å’Œè®°å½•æˆæƒç 
          sessionId = crypto.randomUUID();
          authCode  = authInput.value.trim();

          authModal.style.display = 'none';
          recBtn.disabled = false;
          initSession();
        } else {
          throw new Error(j.error || 'æˆæƒå¤±è´¥');
        }
      } catch (e) {
        authErr.textContent = e.message || 'ç½‘ç»œé”™è¯¯';
        authErr.style.display = '';
      } finally {
        authBtn.disabled = false;
      }
    });

    // å»ºç«‹ WS ä¼šè¯ & å½•éŸ³é€»è¾‘
    function initSession() {
      chatEl.innerHTML = '';
      if (socket) socket.close();

      const mode = [...modes].find(r=>r.checked).value;
      // åœ¨ URL ä¸Šä¼ é€’ sessionIdã€authCodeã€mode
      const wsUrl = `${WS_BASE}?mode=${mode}&session=${sessionId}&auth=${authCode}`;
      socket = new WebSocket(wsUrl);
      socket.binaryType = 'arraybuffer';

      socket.onopen    = ()=> append('bot','ğŸ¤– [å·²è¿æ¥]');
      socket.onerror   = ()=> append('bot','ğŸ¤– [æœåŠ¡å¼‚å¸¸]');
      socket.onclose   = ()=> append('bot','ğŸ¤– [å·²æ–­å¼€]');
      socket.onmessage = async evt => {
        // æ–‡æœ¬æ¶ˆæ¯
        if (typeof evt.data === 'string') {
          const msg = JSON.parse(evt.data);
          append(msg.who, msg.text);
          // Bot å›å¤æ–‡æœ¬ä¸å†ç”¨æµè§ˆå™¨ TTSï¼Œå·²ç”±åç«¯æ¨é€äºŒè¿›åˆ¶éŸ³é¢‘
        }
        // éŸ³é¢‘äºŒè¿›åˆ¶
        else if (evt.data instanceof ArrayBuffer) {
          await play(new Blob([evt.data], { type:'audio/webm' }));
        }
      };

      [...modes].forEach(r=>r.onchange = initSession);

      // å½•éŸ³å¼€å§‹/ç»“æŸ
      const startRec = async () => {
        recBtn.classList.add('recording');
        recBtn.textContent = 'ğŸ›‘ å½•éŸ³ä¸­...';
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = e => {
            if (socket.readyState === 1) socket.send(e.data);
          };
          recorder.start(250);
          append('user','ğŸ‘¤ [å¼€å§‹å½•éŸ³]');
        } catch {
          alert('è¯·å…è®¸éº¦å…‹é£');
        }
      };
      const stopRec = () => {
        recBtn.classList.remove('recording');
        recBtn.textContent = 'ğŸ¤ æŒ‰ä½è¯´è¯';
        if (recorder && recorder.state !== 'inactive') {
          recorder.stop();
          append('user','ğŸ‘¤ [ç»“æŸå½•éŸ³]');
        }
      };
      recBtn.addEventListener('pointerdown', startRec);
      recBtn.addEventListener('pointerup',   stopRec);
      recBtn.addEventListener('touchstart',  startRec);
      recBtn.addEventListener('touchend',    stopRec);
    }

    // è¿½åŠ æ°”æ³¡
    function append(who, txt) {
      const d = document.createElement('div');
      d.className = 'msg ' + who;
      d.textContent = txt;
      chatEl.appendChild(d);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // æ’­æ”¾äºŒè¿›åˆ¶éŸ³é¢‘
    function play(blob) {
      return new Promise(res => {
        const url = URL.createObjectURL(blob);
        const a   = new Audio(url);
        a.onended = ()=> { URL.revokeObjectURL(url); res(); };
        a.play();
      });
    }
  })();
  </script>
</body>
</html>
