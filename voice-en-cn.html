<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>åŒæ¨¡å¼è¯­éŸ³åŠ©æ‰‹</title>
  <style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family:'Segoe UI',sans-serif;
  background:#f0f2f5; color:#333;
  min-height:100vh;
  display:flex; justify-content:center; align-items:center;
  padding:1rem;
}
#main {
  width:100%;
  max-width:700px;            /* ä» 500px æ”¹ä¸º 700px */
  background:#fff;border-radius:12px;
  padding:1.5rem;box-shadow:0 8px 24px rgba(0,0,0,0.1);
  position:relative; z-index:1;
}
h1 { font-size:1.25rem; margin-bottom:1rem; }
.mode-switch { display:flex;gap:1rem;margin-bottom:1rem; }
.mode-switch label { cursor:pointer; user-select:none; }
.mode-switch input { margin-right:.3rem; }

/* å½•éŸ³æŒ‰é’® */
#recBtn {
  width:100%;padding:.75rem;font-size:1rem;
  background:#3b82f6;color:#fff;border:none;
  border-radius:6px;cursor:pointer;transition:background .2s;
  margin-bottom:1rem;
}
#recBtn.recording { background:#dc2626; }
#recBtn:disabled { background:#aac4f7; cursor:not-allowed; }

/* å¯¹è¯åŒº */
#chat {
  width:100%;
  height:240px;overflow-y:auto;
  border:1px solid #ddd;border-radius:6px;
  padding:.5rem;background:#fafafa;
  box-sizing:border-box;
}
/* å…¬å…± msg æ ·å¼ï¼Œå˜æˆ flex container */
.msg {
  display:flex;
  flex-wrap:wrap;
  margin-bottom:.5rem;
  padding:.25rem .5rem;
  border-radius:6px;
}
/* ç”¨æˆ·æ¶ˆæ¯ï¼šå·¦å¯¹é½ï¼Œæµ…è“èƒŒæ™¯ */
.msg.user {
  justify-content:flex-start;
  background:#e0f2ff;
  color:#1f2937;
}
/* æœºå™¨äºº & metaï¼šå³å¯¹é½ï¼Œæµ…ç°èƒŒæ™¯ */
.msg.bot,
.msg._meta {
  justify-content:flex-end;
  background:#f0f0f0;
  color:#374151;
}
/* å†…å®¹æœ€å¤§å®½åº¦ï¼Œè‡ªåŠ¨æ¢è¡Œ */
.msg > * {
  max-width:80%;
  word-break:break-word;
}

/* æˆæƒå¼¹çª—ï¼šé€æ˜é®ç½©å¯è§ä¸»ç•Œé¢ */
#authModal {
  position:fixed;inset:0;
  display:flex;justify-content:center;align-items:center;
  background:rgba(0,0,0,0);
  z-index:1000;
}
#authModal .box {
  background:rgba(255,255,255,0.95);
  border-radius:12px;padding:24px 32px;
  box-shadow:0 8px 24px rgba(0,0,0,0.15);
  text-align:center;min-width:320px;
}
#authModal h2 {font-size:1.5rem;margin-bottom:1rem;}
#authModal input {
  width:100%;padding:.75rem;font-size:1rem;
  border:1px solid #ccc;border-radius:6px;
  margin-bottom:1rem;
}
#authModal button {
  width:100%;padding:.75rem;font-size:1rem;
  border:none;border-radius:6px;
  background:#3b82f6;color:#fff;cursor:pointer;
  transition:background .2s;
}
#authModal button:disabled {
  background:#8fbefc;cursor:not-allowed;
}
#authErr {
  color:#d9534f;margin-top:.5rem;font-size:.9rem;
  display:none;
}

  </style>
</head>
<body>
  <div id="main">
    <h1>è¯­éŸ³åŠ©æ‰‹</h1>
    <div class="mode-switch">
      <label><input type="radio" name="mode" value="chat" checked/> å¯¹è¯æ¨¡å¼</label>
      <label><input type="radio" name="mode" value="trans"/> åŒä¼ æ¨¡å¼</label>
    </div>
    <button id="recBtn" disabled>ğŸ¤ æŒ‰ä½è¯´è¯</button>
    <div id="chat"></div>
  </div>

  <div id="authModal">
    <div class="box">
      <h2>è¯·è¾“å…¥æˆæƒç </h2>
      <input id="authInput" type="password" placeholder="æˆæƒç "/>
      <button id="authBtn" disabled>ç¡®è®¤</button>
      <div id="authErr"></div>
    </div>
  </div>

  <script>
 
  // åœ¨é¡µé¢æœ€ä¸Šæ–¹æ’å…¥ DEBUG æ ‡è®°
  document.body.insertAdjacentHTML('afterbegin',
    '<div style="position:fixed;top:0;left:0;background:red;color:white;padding:4px;font-size:12px;z-index:9999;">[DEBUG BUILD]</div>'
  );
  console.log('--- DEBUG BUILD LOADED ---');

  (function(){
    const BASE    = 'https://translate-assistant.mefans.workers.dev';
    const AUTH    = BASE + '/admin-api/validate-code';
    const WS_BASE = BASE.replace(/^http/,'ws') + '/admin-api/ws';

    const authModal = document.getElementById('authModal');
    const authInput = document.getElementById('authInput');
    const authBtn   = document.getElementById('authBtn');
    const authErr   = document.getElementById('authErr');
    const recBtn    = document.getElementById('recBtn');
    const chatEl    = document.getElementById('chat');
    const modes     = document.getElementsByName('mode');

    let socket = null, recorder = null;
    let sessionId = '', authCode = '';

    // é¡µé¢åˆå§‹ï¼šå…ˆç¦ç”¨å½•éŸ³æŒ‰é’®
    window.addEventListener('DOMContentLoaded', () => {
      recBtn.disabled = true;
    });

    // ========== æˆæƒæµç¨‹ ==========
    authInput.addEventListener('input', () => {
      authBtn.disabled = !authInput.value.trim();
      authErr.style.display = 'none';
    });
    authBtn.addEventListener('click', async () => {
      authBtn.disabled = true;
      try {
        const r = await fetch(AUTH, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ code: authInput.value.trim() })
        });
        const j = await r.json();
        if (r.ok && j.ok) {
          // æˆæƒé€šè¿‡
          sessionId = crypto.randomUUID();
          authCode  = authInput.value.trim();
          authModal.style.display = 'none';
          recBtn.disabled = false;  // å¯ç”¨å½•éŸ³
          initSession();
        } else {
          throw new Error(j.error || 'æˆæƒå¤±è´¥');
        }
      } catch(e) {
        authErr.textContent = e.message || 'ç½‘ç»œé”™è¯¯';
        authErr.style.display = '';
      } finally {
        authBtn.disabled = false;
      }
    });

    // ========== åªç»‘å®šä¸€æ¬¡å½•éŸ³æŒ‰é’®äº‹ä»¶ ==========
    recBtn.addEventListener('pointerdown', onPointerDown);
    recBtn.addEventListener('pointerup',   onPointerUp);
    recBtn.addEventListener('touchstart',  onPointerDown);
    recBtn.addEventListener('touchend',    onPointerUp);

    async function onPointerDown() {
      if (recBtn.disabled || socket?.readyState !== 1) return;
      await startRec();
    }
    function onPointerUp() {
      stopRec();
    }

    // ========== WebSocket åˆå§‹åŒ– & æ¨¡å¼åˆ‡æ¢ ==========
    function initSession(){
      chatEl.innerHTML = '';
      // å…³é—­æ—§ socket
      if (socket) {
        socket.close();
        socket = null;
      }
      // é‡ç½®å½•éŸ³æŒ‰é’®çŠ¶æ€
      recBtn.disabled = true;
      recBtn.classList.remove('recording');
      recBtn.textContent = 'ğŸ¤ æŒ‰ä½è¯´è¯';

      const mode = [...modes].find(r=>r.checked).value;
      const url  = `${WS_BASE}?mode=${mode}&session=${sessionId}&auth=${authCode}`;
      console.log('Attempting WS connect to:', url);
      socket = new WebSocket(url);
      socket.binaryType = 'arraybuffer';

      socket.onopen = () => {
        console.log('WS onopen â readyState', socket.readyState);
        append('bot','ğŸ¤– [å·²è¿æ¥]');
        recBtn.disabled = false;  // è¿æ¥æˆåŠŸåå¯ç”¨å½•éŸ³
      };
      socket.onerror = e => {
        console.error('WS.onerror', e);
        socket = null;
        append('bot','ğŸ¤– [æœåŠ¡å¼‚å¸¸]');
        recBtn.disabled = true;
      };
      socket.onclose = e => {
        console.log('WS.onclose', e.code, e.reason);
        socket = null;
        append('bot','ğŸ¤– [å·²æ–­å¼€ï¼Œ5 ç§’åé‡è¿]');
        recBtn.disabled = true;
        setTimeout(initSession, 5000);  // 5 ç§’åè‡ªåŠ¨é‡è¿
      };

      socket.onmessage = async evt => {
        console.log('WS æ”¶åˆ° raw evt:', evt);
        if (typeof evt.data === 'string') {
          const msg = JSON.parse(evt.data);
          if (msg.who === '_meta') {
            console.log('æ”¶åˆ° _meta å¸§ï¼š', msg);
          } else {
            console.log('æ”¶åˆ° æ–‡æœ¬æ¶ˆæ¯ï¼š', msg);
            append(msg.who, msg.text);
          }
        }
        else if (evt.data instanceof ArrayBuffer) {
          console.log('æ”¶åˆ° éŸ³é¢‘å¸§ï¼Œé•¿åº¦ bytes:', evt.data.byteLength);
          const blob = new Blob([evt.data], { type: 'audio/webm; codecs=opus' });
          const audioURL = URL.createObjectURL(blob);
          const audio = new Audio(audioURL);
          audio.onerror = e => console.error('audio.onerror', e);
          audio.play()
               .then(()=> console.log('audio.play() æˆåŠŸ'))
               .catch(err=> console.error('audio.play() å¤±è´¥', err));
        }
      };

      // åˆ‡æ¢æ¨¡å¼æ—¶é‡æ–°å»ºç«‹
      [...modes].forEach(r=>r.onchange = initSession);
    }

    // ========== å½•éŸ³é€»è¾‘ï¼šå®Œæ•´æ®µå½•å®Œå†å‘ ==========
    let chunks = [];
    async function startRec(){
      recBtn.classList.add('recording');
      recBtn.textContent = 'ğŸ›‘ å½•éŸ³ä¸­...';
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        recorder = new MediaRecorder(stream);
        chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type:'audio/webm' });
          if (socket?.readyState === 1) socket.send(blob);
        };
        recorder.start();
        append('user','ğŸ‘¤ [å¼€å§‹å½•éŸ³]');
      } catch(err) {
        console.error('startRec å‡ºé”™', err);
        recBtn.classList.remove('recording');
        recBtn.textContent = 'ğŸ¤ æŒ‰ä½è¯´è¯';
        alert('è¯·å…è®¸éº¦å…‹é£');
      }
    }
    function stopRec(){
      try {
        if (recorder && recorder.state !== 'inactive') {
          recorder.stop();
          append('user','ğŸ‘¤ [ç»“æŸå½•éŸ³]');
        }
      } catch(err) {
        console.error('stopRec å‡ºé”™', err);
      } finally {
        recBtn.classList.remove('recording');
        recBtn.textContent = 'ğŸ¤ æŒ‰ä½è¯´è¯';
      }
    }

    // ========== åœ¨å¯¹è¯æ¡†é‡Œè¿½åŠ ä¸€æ¡è®°å½• ==========
    function append(who, txt){
      const d = document.createElement('div');
      d.className = 'msg ' + who;
      d.textContent = txt;
      chatEl.appendChild(d);
      chatEl.scrollTop = chatEl.scrollHeight;
    }
  })();


  </script>
</body>
</html>
