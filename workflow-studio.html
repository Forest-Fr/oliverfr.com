<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Section0 Carousel</title>
  <style>
    /* =========================
       Carousel layout (Peek Preview)
       ========================= */

     /* Desktop */
    @media (min-width: 769px) {
      .section0-carousel{
  width: 100%;
  padding: 0 10%;
  margin: 0 auto;
  box-sizing: border-box;
  background: #f9f9f9;
  overflow-x: clip;
  overflow-y: visible;
  position: relative;
  height: 495px;
  margin-top: 55px; /* 把原本的间距拉近 */
      }
      .section0-track{
  display: flex;
  gap: 15px; /* 图片之间间隔 15px */
  transition: transform 0.5s ease-in-out;
  justify-content: flex-start;
  will-change: transform;
      }
      .section0-slide{
  flex: 0 0 auto;
  width: 100%;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
      }
      .section0-slide img{
  width: 1013px;
  height: 495px;
  object-fit: cover;
  border-radius: 16px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
  transition: transform 0.4s ease, opacity 0.4s ease;
      }
    }

    /* Mobile */
    @media (max-width: 768px) {
      .section0-carousel{
    width: 100vw;
    /* 左右内边距 = (100vw - 85vw)/2 */
    padding-left: calc((100vw - 85vw) / 2);
    padding-right: calc((100vw - 85vw) / 2);
    overflow-x: hidden; /* 避免transform与scroll-snap冲突 */
    margin: 0 auto;
  position: relative !important;
      }
        

      .section0-track{
    display: flex;
    gap: 15px;
    align-items: center;
    /* 保留 transform 过渡（若脚本依然用 transform 切换） */
    transition: transform 0.5s ease-in-out;
      }
      .section0-slide{
    flex: 0 0 auto;
    width: 85vw;
    max-width: 400px;
    aspect-ratio: 1 / 0.7; /* 宽高比例1:0.7 */
    scroll-snap-align: center;
    overflow: hidden;
    position: relative;
      }
      .section0-slide img{
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    filter: none !important;
    opacity: 1 !important;
      }
    }

    /* =========================
       Apple TV-like dots + play (NO keyframes)
       ========================= */

    .section0-buttonRow{
      width: min(920px, 92vw);
      height: 44px;
      margin: 15px auto 16px auto;  /* ✅ 与轮播区域下方总间隔 15px */
      position: relative;
      z-index: 999;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .section0-buttonRow.is-hidden{
      opacity: 0;
      transform: translateY(-10px) scale(.96);
      pointer-events: none;
    }

    .btn-container{
      position: absolute;
      top: 50%;
      opacity: 1;
      pointer-events: auto;
    }
    #leftBtnContainer{
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #rightBtnContainer{
      right: 10px;
      left: auto;
      transform: translateY(-50%);
    }

    #section0-leftCapsule{
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      border-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dots{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 14px;
      user-select: none;
    }

    /* ✅ 物理进度：外层浅灰 pill + 内层深色 fill（scaleX 缓慢推进） */
    .dot{
      --dotS: 6px;      /* 小圆直径 */
      --pillW: 44px;    /* 胶囊宽 */
      --pillH: 8px;     /* 胶囊高 */
      --p: 0;           /* 进度 0..1 */

      width: var(--dotS);
      height: var(--dotS);
      border-radius: 999px;
      background: rgba(0,0,0,.30);
      opacity: .85;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transform: translateZ(0);
      transition:
        width .34s cubic-bezier(.22,.61,.36,1),
        height .34s cubic-bezier(.22,.61,.36,1),
        background-color .22s ease,
        opacity .22s ease;
    }
    /* 进度 fill */
    .dot::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 999px;
      background: rgba(0,0,0,.80);
      transform-origin: left center;
      transform: scaleX(var(--p));
      opacity: 0;
      transition: opacity .18s ease;
      box-shadow: inset 0 0 0 0 rgba(0,0,0,0);
    }

    /* Active pill base track */
    .dot.is-active{
      width: var(--pillW);
      height: var(--pillH);
      background: rgba(0,0,0,.16);  /* ✅ 浅灰轨道 */
      opacity: 1;
    }
    .dot.is-active::after{
      opacity: 1;
      /* ✅ 轻微质感，让“推进”更像截图里的物理变化 */
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
    }

    /* 蓄力阶段：保持小圆（停顿），然后放开进入胶囊拉伸 */
    .dot.is-active.is-charge{
      width: var(--dotS);
      height: var(--dotS);
      background: rgba(0,0,0,.40);
      opacity: .95;
    }

    /* ===== Play/Pause button (with shadow) ===== */
    #section0-rightButton{
      width: 34px;
      height: 34px;
      border: none;
      border-radius: 50%;
      background: rgba(0,0,0,.06);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,.18); /* ✅ 你要求：加阴影 */
      transition: transform .18s ease, opacity .18s ease, background-color .18s ease, box-shadow .18s ease;
      user-select: none;
    }
    #section0-rightButton:hover{
      background: rgba(0,0,0,.08);
      box-shadow: 0 12px 26px rgba(0,0,0,.20);
    }
    #section0-rightButton:active{ transform: scale(.96); }

    #section0-playIcon{
      font-size: 14px;
      line-height: 1;
      color: rgba(0,0,0,.62);
      letter-spacing: -1px;
      user-select: none;
      transform: translateX(1px);
    }

    /* Click hints（overlay已删除） */
    .section0-slide.is-center{ cursor: pointer; }
    .section0-slide.is-neighbor{ cursor: pointer; }
  </style>
</head>

<body>

  <!-- 轮播容器 -->
  <div class="section0-carousel">
    <div class="section0-track">
      <div class="section0-slide"><img src="rag test.png" alt="nature1" /></div>
      <div class="section0-slide"><img src="cloud-page.png" alt="nature2" /></div>
      <div class="section0-slide"><img src="frontend test.png" alt="nature3" /></div>
      <div class="section0-slide"><img src="grafana chart.png" alt="nature4" /></div>
      <div class="section0-slide"><img src="real test.png" alt="nature5" /></div>
    </div>
  </div>

  <!-- 按钮行容器 -->
  <div id="section0-buttonRow" class="section0-buttonRow is-hidden">
    <div id="leftBtnContainer" class="btn-container">
      <div id="section0-leftCapsule">
        <div class="dots" id="section0-dotsWrap">
          <div class="dot" data-index="0"></div>
          <div class="dot" data-index="1"></div>
          <div class="dot" data-index="2"></div>
          <div class="dot" data-index="3"></div>
          <div class="dot" data-index="4"></div>
        </div>
      </div>
    </div>

    <div id="rightBtnContainer" class="btn-container">
      <div id="section0-rightButton" aria-label="Play/Pause">
        <span id="section0-playIcon">❚❚</span>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const container = document.querySelector('.section0-carousel');
      const track = document.querySelector('.section0-track');
      const buttonRow = document.getElementById('section0-buttonRow');
      const rightButton = document.getElementById('section0-rightButton');
      const playIcon = document.getElementById('section0-playIcon');
      const dotsWrap = document.getElementById('section0-dotsWrap');

      if (!container || !track || !dotsWrap) return;

      // ===== “缺口”保留：未来可恢复跳转（当前不启用） =====
      const ENABLE_OPEN_LINK = false;
      const LINK_URL = 'https://oliverfr.com/agent-test.html';

      // ===== Motion tuning (slower + friendly) =====
      const TRANSITION_MS = 720;         // 滑动更柔和
      const SWIPE_PX_DESK = 50;
      const SWIPE_PX_MOB  = 35;          // 手机更灵敏

      // Dot physics: 小圆 → 蓄力停顿 → 拉伸 → 进度推进（无 keyframes）
      const DOT_CHARGE_MS   = 240;       // 蓄力停顿
      const DOT_STRETCH_MS  = 320;       // 拉伸完成时间（CSS transition）
      const DOT_PROGRESS_MS = 4600;      // 胶囊内进度推进时长（截图那种“缓慢推进”）

      // ===== Build triple clones (no edge flash) =====
      let originalSlides = Array.from(track.querySelectorAll('.section0-slide'));
      const realCount = originalSlides.length;

      function syncDotsCount() {
        const exist = Array.from(dotsWrap.querySelectorAll('.dot'));
        if (exist.length === realCount) return;
        dotsWrap.innerHTML = '';
        for (let i = 0; i < realCount; i++) {
          const d = document.createElement('div');
          d.className = 'dot';
          d.dataset.index = String(i);
          dotsWrap.appendChild(d);
        }
      }

      function cloneTriple() {
        if (realCount <= 1) return;
        const base = originalSlides.map(n => n.cloneNode(true));
        track.innerHTML = '';
        for (let pass = 0; pass < 3; pass++) {
          for (let i = 0; i < base.length; i++) {
            const node = base[i].cloneNode(true);
            node.dataset.realIndex = String(i);
            node.dataset.pass = String(pass);
            track.appendChild(node);
          }
        }
      }

      syncDotsCount();
      cloneTriple();

      let slides = Array.from(track.querySelectorAll('.section0-slide'));

      // Start at middle copy
      let currentPos = (realCount > 1) ? realCount : 0;

      // ===== Measurements (precision to 4 decimals, >=3 required) =====
      let slideSpan = 0;
      let centerOffset = 0; // ===== [PATCH] 用于强制“左右 peek 对称” =====

      function getGapPx() {
        const cs = getComputedStyle(track);
        const raw = (cs.gap && cs.gap !== 'normal') ? cs.gap : (cs.columnGap || '0px');
        const g = parseFloat(raw || '0');
        return Number.isFinite(g) ? g : 0;
      }

      function recalcSpan() {
        if (!slides.length) return 0;

        const idx = Math.min(Math.max(currentPos, 0), slides.length - 1);
        const slideRect = slides[idx].getBoundingClientRect();
        const slideW = slideRect ? slideRect.width : 0;

        const contRect = container.getBoundingClientRect();
        const contW = contRect ? contRect.width : 0;

        const gap = getGapPx();
        const span = slideW + gap;

        slideSpan = (Number.isFinite(span) && span > 0) ? span : 0;

        // ===== [PATCH] 关键：把“当前卡片”始终居中，从而左右漏出永远相等 =====
        // centerOffset = (可视容器宽度 - 当前卡片宽度) / 2
        centerOffset = (Number.isFinite(contW) && contW > 0 && Number.isFinite(slideW) && slideW > 0)
          ? (contW - slideW) / 2
          : 0;

        return slideSpan;
      }

      function applyTransform(animated) {
        if (!slideSpan) recalcSpan();
        // 防御：避免 NaN / 0 导致 translateX(NaNpx) 或全白
        if (!slideSpan || !Number.isFinite(slideSpan)) return;

        track.style.transition = animated
          ? `transform ${TRANSITION_MS}ms cubic-bezier(.22,.61,.36,1)`
          : 'none';

        // ===== [PATCH] 不再只是 -currentPos*span，而是加上 centerOffset 保证对称 =====
        // tx = centerOffset - currentPos * slideSpan
        const tx = centerOffset - (currentPos * slideSpan);

        // ≥3 位小数：这里统一 4 位
        track.style.transform = `translateX(${tx.toFixed(4)}px)`;
      }

      function getRealIndex() {
        if (realCount <= 1) return 0;
        const el = slides[currentPos];
        const ri = el ? parseInt(el.dataset.realIndex || '0', 10) : 0;
        return Number.isFinite(ri) ? ri : 0;
      }

      function updateCenterClasses() {
        slides.forEach(s => s.classList.remove('is-center', 'is-neighbor'));
        const center = slides[currentPos];
        const left = slides[currentPos - 1];
        const right = slides[currentPos + 1];
        if (center) center.classList.add('is-center');
        if (left) left.classList.add('is-neighbor');
        if (right) right.classList.add('is-neighbor');
      }

      // ===== Infinite loop boundary fix =====
      function normalizePositionIfNeeded() {
        if (realCount <= 1) return false;

        let changed = false;
        if (currentPos >= realCount * 2) {
          currentPos -= realCount;
          changed = true;
        }
        if (currentPos < realCount) {
          currentPos += realCount;
          changed = true;
        }
        if (changed) applyTransform(false);
        updateCenterClasses();
        return changed;
      }

      // ===== Dot physics + progress =====
      let isPlaying = true;
      let isMoving = false;

      let rafId = 0;
      let chargeTimer = 0;
      let cycleToken = 0;
      let activeDotIdx = 0;

      function dotsAll() {
        return Array.from(dotsWrap.querySelectorAll('.dot'));
      }

      function resetAllDots() {
        const dots = dotsAll();
        dots.forEach(d => {
          d.classList.remove('is-active', 'is-charge');
          d.style.setProperty('--p', '0');
        });
      }

      function activateDot(idx) {
        const dots = dotsAll();
        resetAllDots();

        const d = dots[idx];
        if (!d) return;

        activeDotIdx = idx;
        d.classList.add('is-active', 'is-charge');
        d.style.setProperty('--p', '0');

        clearTimeout(chargeTimer);
        chargeTimer = setTimeout(() => {
          d.classList.remove('is-charge');
        }, DOT_CHARGE_MS);
      }

      function setDotProgress(idx, p) {
        const dots = dotsAll();
        const d = dots[idx];
        if (!d) return;
        const v = Math.max(0, Math.min(1, p));
        d.style.setProperty('--p', String(v));
      }

      function stopProgressLoop() {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = 0;
      }

      function startProgressCycle() {
        stopProgressLoop();
        if (!isPlaying || document.hidden || realCount <= 1) return;
        if (isMoving) return;

        const myToken = ++cycleToken;
        const idx = getRealIndex();
        activateDot(idx);

        const startAt = performance.now();
        const effectiveStart = startAt + DOT_CHARGE_MS + DOT_STRETCH_MS;

        function tick(now) {
          if (myToken !== cycleToken) return;
          if (!isPlaying || document.hidden) { stopProgressLoop(); return; }
          if (isMoving) { stopProgressLoop(); return; }

          const t = now - effectiveStart;
          const p = t <= 0 ? 0 : (t / DOT_PROGRESS_MS);
          setDotProgress(activeDotIdx, p);

          if (p >= 1) {
            stopProgressLoop();
            next(true);
            return;
          }
          rafId = requestAnimationFrame(tick);
        }

        rafId = requestAnimationFrame(tick);
      }

      // ===== Navigation (with transitionend lost fallback) =====
      let moveDoneTimer = 0;

      function endMoveSafely() {
        if (!isMoving) return;
        isMoving = false;

        clearTimeout(moveDoneTimer);
        moveDoneTimer = 0;

        normalizePositionIfNeeded();
        hardSyncLayout();

        if (isPlaying && !document.hidden) startProgressCycle();
      }

      function moveToPos(newPos, animated) {
        if (realCount <= 1) return;

        stopProgressLoop();
        clearTimeout(moveDoneTimer);

        currentPos = newPos;
        isMoving = !!animated;

        applyTransform(!!animated);
        updateCenterClasses();

        if (!animated) {
          isMoving = false;
          if (isPlaying && !document.hidden) startProgressCycle();
          return;
        }

        moveDoneTimer = setTimeout(endMoveSafely, TRANSITION_MS + 90);
      }

      function next(pop) {
        if (realCount <= 1) return;
        if (isMoving) return;
        moveToPos(currentPos + 1, true);
      }

      function prev(pop) {
        if (realCount <= 1) return;
        if (isMoving) return;
        moveToPos(currentPos - 1, true);
      }

      function goToRealIndex(realIdx) {
        if (realCount <= 1) return;
        if (!Number.isFinite(realIdx)) return;
        moveToPos(realCount + realIdx, true);
      }

      track.addEventListener('transitionend', (e) => {
        if (e.propertyName !== 'transform') return;
        endMoveSafely();
      });

      // ===== Play/Pause =====
      function updatePlayButtonUI() {
        if (!playIcon) return;
        playIcon.textContent = isPlaying ? '❚❚' : '►';
      }

      function play() {
        isPlaying = true;
        updatePlayButtonUI();
        startProgressCycle();
      }

      function pause() {
        isPlaying = false;
        updatePlayButtonUI();
        stopProgressLoop();
      }

      if (rightButton) {
        rightButton.addEventListener('click', () => {
          if (isPlaying) pause();
          else play();
        });
      }

      // Dots click
      dotsWrap.addEventListener('click', (e) => {
        const t = e.target;
        if (!t || !t.classList || !t.classList.contains('dot')) return;
        const idx = parseInt(t.getAttribute('data-index') || '0', 10);
        if (!Number.isFinite(idx)) return;

        const wasPlaying = isPlaying;
        goToRealIndex(idx);
        if (!wasPlaying) pause();
      });

      // Slide click behavior (no link)
      track.addEventListener('click', (e) => {
        const slide = e.target && e.target.closest ? e.target.closest('.section0-slide') : null;
        if (!slide) return;

        const idx = slides.indexOf(slide);
        if (idx < 0) return;

        if (idx === currentPos) {
          if (ENABLE_OPEN_LINK) {
            window.open(LINK_URL, '_blank', 'noopener');
          } else {
            if (isPlaying) pause();
            else play();
          }
          return;
        }

        pause();
        if (idx < currentPos) prev(true);
        else next(true);
      });

      // ===== Touch swipe =====
      let sx = 0, sy = 0, ex = 0, ey = 0;

      track.addEventListener('touchstart', (e) => {
        const t = e.touches && e.touches[0];
        if (!t) return;
        sx = t.clientX;
        sy = t.clientY;
      }, { passive: true });

      track.addEventListener('touchend', (e) => {
        const t = e.changedTouches && e.changedTouches[0];
        if (!t) return;
        ex = t.clientX;
        ey = t.clientY;

        const dx = ex - sx;
        const dy = ey - sy;

        if (Math.abs(dx) <= Math.abs(dy)) return;

        const thr = (window.innerWidth <= 768) ? SWIPE_PX_MOB : SWIPE_PX_DESK;
        if (Math.abs(dx) < thr) return;

        pause();
        if (dx < 0) next(true);
        else prev(true);
      }, { passive: true });

      // ===== ButtonRow show/hide (IntersectionObserver) =====
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (!buttonRow) return;
          buttonRow.classList.toggle('is-hidden', !entry.isIntersecting);
        });
      }, { threshold: 0 });
      observer.observe(container);

      window.addEventListener('scroll', () => {
        if (!buttonRow) return;
        const br = buttonRow.getBoundingClientRect();
        buttonRow.style.transform = (br.bottom > window.innerHeight)
          ? 'translateY(-180px)'
          : (buttonRow.classList.contains('is-hidden') ? 'translateY(-10px) scale(.96)' : '');
      }, { passive: true });

      // ===== Hard-fix: background lifecycle / width=0 / transitionend lost =====
      function hardSyncLayout() {
        let tries = 0;

        function tryMeasure() {
          tries++;
          const span = recalcSpan();
          if (span && span > 0) {
            applyTransform(false);
            normalizePositionIfNeeded();
            applyTransform(false);
            updateCenterClasses();
            return;
          }
          if (tries < 6) requestAnimationFrame(tryMeasure);
        }

        tryMeasure();
      }

      function onVisibleResume() {
        hardSyncLayout();
        if (isPlaying) startProgressCycle();
      }

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopProgressLoop();
          clearTimeout(moveDoneTimer);
          moveDoneTimer = 0;
        } else {
          onVisibleResume();
        }
      });

      window.addEventListener('pagehide', () => {
        stopProgressLoop();
        clearTimeout(moveDoneTimer);
        moveDoneTimer = 0;
      });

      window.addEventListener('pageshow', (e) => {
        hardSyncLayout();
        updatePlayButtonUI();
        if (!document.hidden && isPlaying) startProgressCycle();
      });

      window.addEventListener('resize', () => {
        hardSyncLayout();
      });

      // ===== Init: wait images ready to avoid width=0 =====
      function waitImagesReady() {
        const imgs = Array.from(track.querySelectorAll('img'));
        const tasks = imgs.map(img => {
          if (!img) return Promise.resolve();
          if (img.complete && img.naturalWidth > 0) return Promise.resolve();
          if (img.decode) return img.decode().catch(() => {});
          return new Promise(res => {
            img.addEventListener('load', () => res(), { once: true });
            img.addEventListener('error', () => res(), { once: true });
          });
        });
        return Promise.all(tasks);
      }

      async function init() {
        updatePlayButtonUI();

        await waitImagesReady();

        hardSyncLayout();
        applyTransform(false);
        normalizePositionIfNeeded();
        applyTransform(false);
        updateCenterClasses();

        resetAllDots();
        activateDot(getRealIndex());

        if (isPlaying) startProgressCycle();
      }

      window.addEventListener('load', init, { once: true });
    })();
  </script>
</body>
</html>

